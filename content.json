{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://cuiyuangeng.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-03-07T12:56:44.596Z","updated":"2022-03-06T07:25:58.953Z","comments":false,"path":"/404.html","permalink":"https://cuiyuangeng.cn/404.html","excerpt":"","text":""},{"title":"about","date":"2022-03-06T08:33:45.000Z","updated":"2022-06-09T06:55:50.528Z","comments":true,"path":"about/index.html","permalink":"https://cuiyuangeng.cn/about/index.html","excerpt":"","text":"崔源耕软件工程专业精通低并发编程（狗头）喜欢编程，喜欢探索新技术 “总有一天你将破蛹而出，成长得比人们期待的还要美丽。但这个过程会很痛，会很辛苦，有时候还会觉得灰心。面对着汹涌而来的现实，觉得自己渺小无力。但这，也是生命的一部分。做好现在你能做的，然后，一切都会好的。我们都将孤独地长大，不要害怕。” 这是毛星云博客上的一段话，他注释： “ 这句话一直写在我C++笔记本的扉页上。 每当我对前路迷茫的时候，就会翻开扉页，看着这段文字淡淡的笔迹发一会呆，然后就渐渐释然了。 今天我把它留在自己的博客里，希望它也能帮助到那些迷茫的朋友们。”"},{"title":"分类","date":"2022-03-07T12:56:44.599Z","updated":"2022-03-06T07:25:58.956Z","comments":false,"path":"categories/index.html","permalink":"https://cuiyuangeng.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-07T12:56:44.601Z","updated":"2022-03-06T08:04:26.314Z","comments":false,"path":"tags/index.html","permalink":"https://cuiyuangeng.cn/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-07T12:56:44.601Z","updated":"2022-03-06T07:25:58.959Z","comments":false,"path":"repository/index.html","permalink":"https://cuiyuangeng.cn/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"JOIN原理","slug":"JOIN底层原理","date":"2022-03-23T16:00:00.000Z","updated":"2022-04-05T03:45:24.992Z","comments":true,"path":"2022/03/24/JOIN底层原理/","link":"","permalink":"https://cuiyuangeng.cn/2022/03/24/JOIN%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"JOIN 原理join方式连接多个表，本质就是各个表之间数据的循环匹配。 MySQL 5.5 版本之前，MySQL只支持一种表间关联方式，就是嵌套循环（Nested Loop Join）。如果关联表的数据量很大，则join关联的执行时间会非常长。 在MySQL 5.5 之后，MySQL通过引入BNLJ算法来优化嵌套执行。 1. 驱动表和被驱动表 对于内连接来说： 1SELECT * FROM A JOIN B ON ··· 在两个表都存在索引的情况下，小表驱动大表； 在只有一个索引的情况下，查询优化器会让有索引的表作为被驱动表； Q：A一定是驱动表吗？ A：不一定优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，可以通过explain关键字查看 对于外连接来说： 123SELECT * FROM A LEFT JOIN B ON ···# 或SELECT * FROM B RIGHT JOIN A ON ··· 通常，大家会认为A就是驱动表，B是被驱动表。但不一定。测试如下： 123456789CREATE TABLE a(f1 INT, f2 INT, INDEX(f1))ENGINE=INNODB;CREATE TABLE b(f1 INT, f2 INT)ENGINE=INNODB;INSERT INTO a VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);INSERT INTO b VALUES(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) WHERE (a.f2=b.f2);EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) AND (a.f2=b.f2) ; a表是有索引的，所以查询优化器会将外连接改造为内连接，将a 有索引的表作为被驱动表执行； 2. Simple Nested-Loop Join（简单嵌套循环连接）从表 A 中取出一条数据 1，遍历表 B，将匹配到的数据放到 result 以此类推，驱动表 A 中的每一条记录与被驱动表 B 的记录进行判断： 可以看到这种方式效率是非常低的，以上述表 A 数据100条，表 B 数据1000条计算，则 A * B = 10万次。开销统计如下： 开销统计 SNLJ 外表扫描次数： 1 内表扫描次数： A 读取记录次数： A+B*A JOIN比较次数： B*A 回表读取记录次数： 0 性能最差，所以MySQL对Nested-Loop Join 升级了后面两种优化算法。 3. Index Nested-Loop Join（索引嵌套循环连接）Index Nested-Loop Join 其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。 驱动表中的每条记录通过被驱动表的索引进行访问，因为索引的查询成本是稳定的，所以MySQL优化器倾向于使用记录数少的表作为驱动表（外表）。 如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引。效率会更高。 4. Block Nested-Loop Join（）","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://cuiyuangeng.cn/tags/MySQL/"}]},{"title":"索引的创建和设计原则","slug":"索引的设计原则","date":"2022-03-17T16:00:00.000Z","updated":"2022-03-24T11:52:02.312Z","comments":true,"path":"2022/03/18/索引的设计原则/","link":"","permalink":"https://cuiyuangeng.cn/2022/03/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"三、索引的创建与设计原则1. 索引的声明与使用1.1 索引的分类MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照作用字段个数进行划分，分为 单列索引和联合索引。 1. 普通索引在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在student表的字段name建立一个普通索引，查询记录时就可以根据该索引进行查询。 2. 唯一索引使用UNIQUE参数可以设置索引为唯一索引，在创建唯一索引时，限制该索引的值必须是唯一的，但允许有空值。在一张表中可以有多个唯一索引。 例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须唯一，通过唯一索引，可以快速地确定某条记录。 3. 主键索引主键索引就是一种特殊的唯一索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL + UNIQUE,一张表里最多只有一个主键索引。 因为这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。 4. 单列索引在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。 5. 多列（组合、联合）索引多列索引是在表的多个字段组合上创建一个索引，该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀法则。 6. 全文索引全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法只能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结构。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。 使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT 类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。 全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。 自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数，在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。 MySQL数据库从3.23版开始支持全文索引，但MySQL5.6.4以前只有MyISAM支持，5.6.4版本以后InnoDB才支持，但是官方版本不支持中文分词，需要第三方分词插件。在5.7.6版本中，MySQL内置了ngram全文解析器，用来支持亚洲语种的分词。 随着大数据时代的到来，关系型数据库对全文索引的需求已力不从心，逐渐被solr、ElastaicSearch等专门的搜索引擎所替代。 7. 空间索引使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。 1.2 创建索引MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句CREATE TABLE中指定索引列，使用ALTER TABLE语句在存在的表上创建索引，或者使用CREATE INDEX语句在已存在的表上添加索引。 1. 创建表的时候创建索引隐式的方式创建索引。在声明有主键约束、唯一性约束、外键约束的字段上，会自动的添加相关的索引 1234567891011CREATE TABLE dept(dept_id INT PRIMARY KEY AUTO_INCREMENT,dept_name VARCHAR(20));CREATE TABLE emp(emp_id INT PRIMARY KEY AUTO_INCREMENT,emp_name VARCHAR(20) UNIQUE,dept_id INT,CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)); 显式的创建索引，基本语法： 12CREATE TABLE table_name [col_name data_type][UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ADC | DESC] UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示 唯一索引、全文索引和空间索引 INDEX与KEY为同义词，两者的作用相同，用来指定创建索引 index_name指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名 col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列种选择 length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度 ASC或DESC指定升序或者降序的索引值存储。 ① 创建普通索引12345678910CREATE TABLE book(book_id INT,book_name VARCHAR(100),AUTHORS VARCHAR(100),info VARCHAR(100),COMMENT VARCHAR(100),year_publication YEAR,# 声明索引INDEX idx_book_name(book_name)); 查看索引 1234# 方式1SHOW CREATE TABLE book\\G;# 方式2SHWO INDEX FROM book; ② 创建唯一索引 （UNIQUE）12345678910CREATE TABLE book1(book_id INT,book_name VARCHAR(100),AUTHORS VARCHAR(100),info VARCHAR(100),COMMENT VARCHAR(100),year_publication YEAR,# 声明索引UNIQUE INDEX uk_idx_comment(COMMENT)); ③ 主键索引通过定义主键约束的方式定义主键索引 12345678CREATE TABLE book2(book_id INT PRIMARY KEY,book_name VARCHAR(100),AUTHORS VARCHAR(100),info VARCHAR(100),COMMENT VARCHAR(100),year_publication YEAR); 通过删除主键约束的方式删除主键索引 1ALTER TABLE book2 DROP PRIMARY KEY; ④ 创建组合索引12345678910CREATE TABLE book3(book_id INT,book_name VARCHAR(100),AUTHORS VARCHAR(100),info VARCHAR(100),COMMENT VARCHAR(100),year_publication YEAR,# 声明联合索引INDEX mul_id_name(book_id,book_name,info)); ⑤ 创建全文索引FULLTEXT全文索引可以用于全文搜索，并且只为CHAR、VARCHAR、TEXT列创建索引。索引总是对整个列进行，不支持局部（前缀）索引。 12345678910CREATE TABLE book4(book_id INT,book_name VARCHAR(100),AUTHORS VARCHAR(100),info VARCHAR(100),COMMENT VARCHAR(100),year_publication YEAR,# 声明全文索引FULLTEXT INDEX futxt_idx_info(info(length))); 不同于like方式的查询： 1SELECT * FROM papers WHERE content LIKE &#x27;%查询字符串%&#x27;； 全文索引用match+ageinst方式查询： 1SELECT * FROM papers WHERE MATCH(title,content) AGAINST (&#x27;查询字符串&#x27;); 明显的提高查询效率。 注意： 全文索引比 like + % 快 N 倍，但是可能存在精度问题； 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。 ⑥ 创建空间索引空间索引创建中，要求空间类型的字段必须为非空。 1234CREATE TABLE test(geo GEOMETRY NOT NULL,SPATIAL INDEX spa_idx_geo(geo))ENGINE=MyISAM; 2. 在已经存在的表上创建索引1. 使用ALTER TABLE 语句创建索引ALTER TABLE 语句创建索引的基本语法如下： 12ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY][index_name] (col_name[length],...) [ASC|DESC] 2. 使用CREATE INDEX 创建索引12CREATE [UNIQUE | FULLTEXT | SPATITAL] INDEX index_nameON table_name (col_name[length],...) [ASC | DESC] 1.3 删除索引MySQL中删除索引使用ALTER TABLE ... DROP 或者DROP INDEX语句。 1. 使用ALTER TABLE 删除索引1ALTER TABLE table_name DROP INDEX index_name; 添加AUTO_INCREMENT约束字段的唯一索引不能删除。 2. 使用DROP INDEX删除索引1DROP INDEX index_name ON table_name; 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列被删除，则整个索引将被删除。 2. MySQL8.0 索引新特性（待完善） MySQL高级130P 2.1 支持降序索引3. 索引的设计原则为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获得良好的性能非常重要。 3.1 数据准备第一步：创建数据库、创建表 1234567891011121314151617181920CREATE DATABASE index_demo_db;USE index_demo_db;#1.创建学生表和课程表CREATE TABLE `student_info`(`id` INT(11) NOT NULL AUTO_INCREMENT,`student_id` INT NOT NULL,`name` VARCHAR(20) DEFAULT NULL,`course_id` INT NOT NULL,`class_id` INT(11) DEFAULT NULL,`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,PRIMARY KEY (`id`))ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE `course`(`id` INT(11) NOT NULL AUTO_INCREMENT,`course_id` INT NOT NULL,`course_name` VARCHAR(40) DEFAULT NULL,PRIMARY KEY(`id`))ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 第二步：创建模拟数据 12345678910111213141516171819202122232425262728293031#函数1：创建随机产生字符串函数DELIMITER //CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255) #该函数会返回一个字符串BEGIN DECLARE chars_str VARCHAR(100) DEFAULT &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;; DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;; DECLARE i INT DEFAULT 0; WHILE i &lt; n DO SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1)); SET i = i + 1; END WHILE; RETURN return_str;END //DELIMITER ;SELECT @@log_bin_trust_function_creators;SET GLOBAL log_bin_trust_function_creators = 1;#函数2：创建随机数函数DELIMITER //CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)BEGIN DECLARE i INT DEFAULT 0; SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;RETURN i; END //DELIMITER ; 第三步：创建存储过程 123456789101112131415161718192021222324252627282930# 存储过程1：创建插入课程表存储过程DELIMITER //CREATE PROCEDURE insert_course( max_num INT )BEGIN DECLARE i INT DEFAULT 0; SET autocommit = 0; #设置手动提交事务 REPEAT #循环 SET i = i + 1; #赋值 INSERT INTO course (course_id, course_name ) VALUES (rand_num(10000,10100),rand_string(6)); UNTIL i = max_num END REPEAT; COMMIT; #提交事务END //DELIMITER ;# 存储过程2：创建插入学生信息表存储过程DELIMITER //CREATE PROCEDURE insert_stu( max_num INT )BEGIN DECLARE i INT DEFAULT 0; SET autocommit = 0; #设置手动提交事务 REPEAT #循环 SET i = i + 1; #赋值 INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6)); UNTIL i = max_num END REPEAT; COMMIT; #提交事务END //DELIMITER ; 第四步：调用存储过程 12345678#调用存储过程：CALL insert_course(100);SELECT COUNT(*) FROM course;CALL insert_stu(1000000);SELECT COUNT(*) FROM student_info; 3.2 哪些情况适合创建索引1. 字段的数值有唯一性的限制索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。 2. 频繁作为where查询条件的字段3. 经常GROUP BY 和 ORDER BY的列4. UPDATE、DELETE和WHERE条件列5. DISTINCT 字段需要创建索引6. 多表JOIN连接操作时，创建索引注意事项7. 使用列的类型小的创建索引8. 使用字符串前缀创建索引9. 区分度高（散列性高）的列适合作为索引10. 使用最频繁的列放到联合索引的左侧11. 在多个字段都要创建索引的情况下，联合索引优于单值索引3.3 索引失效的情况1. 索引列不独立索引列不独立是指 被索引的这列不能是表达式的一部分，不能是函数的参数，比如下面的这种情况 1select id,name,age,salary from table_name where salary + 1000 = 6000; salary 列被用户表达式的计算了，这种情况下索引就会失效，解决方式就是提前计算好条件值，不要让索引列参与表达式计算，修改后 sql 如下 1select id,name,age,salary from table_name where salary = 5000; 2.使用了左模糊3. 使用 or 查询部分字段没有使用索引1select id,name,age,salary from table_name where name =&#x27;lucs&#x27; and age &gt;25 这种情况，可以为 name 和 age 都建立索引，否则会走全表扫描。 4. 字符串条件没有使用 ‘’5. 不符合最左前缀原则的查询例如有这样一个组合索引 index(a,b,c) 1234select * from table_name where b=&#x27;1&#x27;and c=&#x27;2&#x27;select * from table_name where c=&#x27;2&#x27;// 上面这两条 SQL 都是无法走索引执行的 6. 索引字段没有添加 not null 约束7. 隐式转换导致索引失效1234select * from table_name t1 left join table_name2 t2 on t1.id=t2.tid;// 上面这条语句里，如果 t1 表的id 类型和 t2 表的tid 类型不一致的时候，就无法// 按索引执行了。// 解决方式就是统一设置字段类型。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://cuiyuangeng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://cuiyuangeng.cn/tags/MySQL/"}]},{"title":"索引的数据结构","slug":"索引的数据结构","date":"2022-03-15T16:00:00.000Z","updated":"2022-04-05T03:48:01.600Z","comments":true,"path":"2022/03/16/索引的数据结构/","link":"","permalink":"https://cuiyuangeng.cn/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"二、索引的数据结构1. 为什么使用索引索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描 对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即二叉搜索树，二叉搜索树的每个节点存储的是(K,V)结构，key是该字段，value是该key所在行的文件指针（地址）。 目的是为了减少磁盘I/O的次数，加速查询速率 2. 索引的优缺点2.1 索引概述索引是在存储引擎中实现的，因此每种存储引擎的索引不一定相同。同时存储引擎可以定义每个表的最大索引数和最大索引长度。 所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。 2.2 优点 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本,这也是创建索引最主要的原因。 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 在实现数据的参考完整性方面，可以加速表和表之间的连接。 ​ 即对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的功耗。 2.3 缺点 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。 索引需要占用 磁盘空间，除了数据表占数据空间，每个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 虽然索引提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增删改，索引也需要动态地维护 因此，选择使用索引时，要综合考虑索引的优点和缺点。 提示： 索引可以提高查询的速度，但会影响插入记录的速度。这种情况，最好的办法是 先删除表中的索引，然后插入数据，插入完成后再创建索引 3. InnoDB中索引的推演3.1 索引之前的查找先来看一个精确匹配的例子： 1SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 1.在单页中查找 存储数据的基本单位：数据页。一个数据页的默认大小为:16 KB 以主键为搜索条件 ​ 可以在页目录中使用 二分法快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录 以其他列作为搜索条件 ​ 因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比。 2.在很多页中查找在很多页中查找记录的话可以分为两个步骤： 定位到记录所在的页 从所在的页内中查找相应的记录 在没有索引的情况下，无论是根据主键列或其他列进行查找，只能从第一个页沿着双向链表一直往下找。 3.2 设计索引1. 一个简单的索引设计方案建表： 123456CREATE TABLE index_demo( c1 INT, c2 INT, c3 CHAR(1), PRIMARY KEY(c1)) ROW_FORMAT = Compact; record_type：记录头信息的一项属性，表示记录的类型，0表示普通记录,2表示最小记录、3表示最大记录 next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁 各个列的值：这里只记录在index_demo表中的三个列，分别是c1、c2、c3 其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。 把一些记录放到页里的示意图就是： 给所有的页建立一个目录项 由于数据页的编号可能是不连续的，所以在向index_demo表中插入许多记录后，可能是： 因为这些16KB的页在物理存储上是不连续的，所以如果想从这么多页种根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每页对应一个目录项，每个目录项包括下边两个部分： 页的用户记录中最小的主键值，我们用key来表示 页号，我们用page_no表示 所以我们为上边几个页做好的目录就像这样： 我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的记录： 先从目录项中根据二分法快速确定出主键值20的记录在目录项3中，它对应的页为页9 再根据二分法查找记录的方式去页9中定位具体的记录 至此，针对数据页做的简易目录就搞定了。这个目录我们可以称为索引 2. InnoDB中的索引方案①迭代1次：目录项记录的页设计的简易索引方案，是因为我们为了在根据主键值进行查找时，使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储,但是这样做有几个问题： InnoDB时使用页作为管理存储空间的基本单位，最多保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。 我们经常会对记录进行增删，假设我们把页28中的记录都删除了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样导致了操作效率很差。 所以，我们需要一种可以灵活管理所有目录项的方式。我们发现目录项其实长的跟我们用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。InnoDB如何区分一条记录是普通的用户记录还是目录项记录么？使用记录头信息的record_type属性，它的各个取值代表的意思如下： 0：普通的用户记录 1：目录项记录 2：最小记录 3：最大记录 把使用的目录项放到数据页中的样子就是这样： 从图中可以看出来，我们分配了一个编号为30的页来专门存储目录项记录。 目录项记录和普通的用户记录的不同点： 目录项记录的record_type值是1，而普通用户记录的record_type值是0 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。 了解：记录头信息里还有一个叫min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都为0 相同点：两者用的是一样的数据页，都会为主键值生成Page Directory（页目录），从而在按照主键值进行查找时，可以使用二分法来加快查询速度。 现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两部： 先到存储目录项记录的页，也就是页30中通过二分法 快速定位到对应目录项，因为12 &lt; 20 &lt; 209，所以 ②迭代2次：多个目录项记录的页虽然说目录项记录中只存储主键值和对应的页号,比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，能存放的目录项记录也是有限的，那如果表中的数据太多,以至于一个数据页不足以存放所有的目录项记录，如何处理呢？ 这里我们假设一个存储目录项记录的页最多只能存放4条目录项记录,所以如果此时我们再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储目录项记录的页: ③迭代3次：目录项记录页的目录页在第二次迭代的查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些页是不连续的，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像一个多级目录，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子： 如图，我们生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1, 320)之间,则到页30中查找更详细的目录项记录，如果主键值不小于320的话，就到页32中查找更详细的目录项记录。 随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它： 这个数据结构，就是B+树 ④B+Tree无论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，即叶子节点,B+树最上边的节点称为根节点. 用户记录存放在B+树的叶子节点上，每一个叶子节点中的每一行数据通过单向链表的方式存储，而叶子节点之间是双向链表。 树的层次越低，IO次数越少 一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找三个目录项页和一个用户记录页），又因为在每个页面内又所谓的Page Directory（页目录），所以在页面内也可以通过二分法来实现快速定位记录。 总结叶子节点：存储实际数据记录，其中又record_type=2标记最小主键值,record_type=3标记最大主键值 内节点：存储每一个数据页的页码以及每一页record_type=2的最小主键值，即数据的目录页，record_type=1 根节点或第二层节点：存储的是目录页的记录，每一个目录页的最小主键值以及目录页的页码 3.3 常见索引概念索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或辅助索引 1. 聚簇索引聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。 术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。 特点： 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 数据页内的记录是按照主键的大小顺序排成一个单向链表。 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。 B+树的叶子节点存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引. 优点： 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树种，因此从聚簇索引中获取数据比非聚簇索引更快。 聚簇索引对于主键的排序查找和范围查找速度非常快 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的IO操作 缺点： 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列作为主键 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。 限制： 对于MySQL数据库目前著有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。 由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况就是该表的主键。 如果没有定义主键，InnoDB会选择非空的唯一索引代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。 为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。 2. 二级索引（辅助索引、非聚簇索引）聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？ 我们可以多建几棵B+树，不同的B+树种的数据采用不同的排序规则。比如我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如图： 概念：回表 我们根据以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一边，这个过程称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树。 因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（secondary index）,或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。 非聚簇索引的存在不影响数据再聚簇索引中的组织，所以一张表可以有多个非聚簇索引。 小结： 聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。 一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。 使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。 3. 联合索引我们也可以同时以多列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这包含两层含义： 先把各个记录和页按照c2列进行排序。 在记录的c2列相同的情况下，采用c3列进行排序 为c2和c3列建立的索引的示意图如下： 如图： 每条目录项记录由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。 B+树叶子节点处的用户记录由c2、c3和主键c1列组成。 以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列建立索引的表述是不同的，不同点： 建立联合索引只会建立如上图一样的1棵B+树。 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树 3.4 InnoDB的B+树索引的注意事项1. 根页面位置万年不动我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的: 每当为某个表创建一个B+树索引 (聚簇索引不是人为创建的，默认就有)的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。 这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。 2. 内节点中目录项记录的唯一性B+树索引的内节点中目录项记录的内容是索引列 + 页号的搭配，但是对于二级索引来说不严谨。以index_demo表为例，假设表中的数据是： c1 c2 c3 1 1 ‘u’ 3 1 ‘d’ 5 1 ‘y’ 7 1 ‘a’ 如果二级索引中目录项记录的内容只是索引列 + 页号的搭配的话，那么为c2列建立索引后的B+树应该长这样： 如果此时我们插入一行记录，其中c1、c2、c3的值分别为：9、1、&#39;c&#39;，那么在修改这个为c2列建立的二级索引对应的B+树时便遇到了问题： 由于页3中存储的目录项记录是由c2列 + 页号的值构成的，页3中的两条目录项记录对应的c2列的值都为1，而我们新插入的这条记录的c2列的值也是1，那此时我们应该插入到页4中还是页5中呢？ 为了让新插入记录能找到自己的位置，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成： 索引列的值 主键值 页号 这样就保证了B+树每一层节点中各条目录项记录除页号以外是唯一的所以我们为c2列建立二级索引后的示意图应该是： 3. 一个页面最少存储2条记录4. MyISAM中的索引方案B树索引使用存储引擎： 索引/存储引擎 MyISAM InnoDB Memory B-Tree索引 支持 支持 支持 InnoDB和MyISAM默认的索引是BTree索引；而Memory默认的索引是Hash索引。 MyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址。 MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储： 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。 使用MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过索引的叶子节点存储的不是完整的用户记录，而是主键值 + 数据记录的地址。 5. 索引的代价 空间上的代价 每建立一个索引都要为它建立一颗B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一篇存储空间。 时间上的代价 每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树的索引。而且，B+树每层节点都是按照索引列的值从小到大的顺序而组成了双向链表。无论是叶子节点中的记录，还是内节点的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。 一个表上的索引创建的越多，就会占用越多的空间，增删改的性能越差。 6. MySQL数据结构选择的合理性从MySQL的角度讲，不得不考虑的现实问题就是磁盘IO。如果我们能让索引的数据结构尽量减少磁盘的I/O操作，所消耗的时间也就越小。磁盘的 I/O 操作次数对索引的使用效率至关重要。 查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，数据库索引时存储在外部磁盘上的。当我们利用索引查询的时候，只能逐一加载索引到内存中，那么MySQL衡量查询效率的标准就是磁盘IO次数。 6.1 全表遍历性能极差！ 6.2 Hash结构Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。 Hash算法时通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。相同的输入永远可以得到相同的输出。 提升查询效率的数据结构，常见的有两类： 树，例如 平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(log2N)； 哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1); 采用Hash进行检索效率非常高，基本一次检索就可以找到数据，而B+树需要自顶向下一次查找，多次访问节点才能找到数据，中间需要多次I/O操作，从效率来说 Hash 比 B+ 树更快 Hash结构效率高，为什么索引结构要设计成树？ Hash索引仅能满足 = 、!= 和 IN查询。如果进行范围查询，哈希索引，时间复杂度会退化为O(n)；而树的有序特性，依然能够保持O(log2N)的高效。 Hash索引，数据存储是无序的,在ORDER BY 的情况下，使用Hash索引还需要对数据重新排序。 对于联合索引的情况，Hash值是将联合索引键合并后一起计算的，无法对单独的一个键或者几个索引键进行查询。 对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多。效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如性别、年龄。 Hash索引使用存储引擎： 索引/存储引擎 MyISAM InnoDB Memory Hash索引 不支持 不支持 支持 Hash索引的适用性： MySQL中的Memory 存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，可以采用Hash索引。 InnoDB本身不支持Hash索引，但是提供自适应 Hash 索引(Adaptive Hash Index)。 如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样就让B+树也具备了Hash索引的优点。 采用自适应Hash索引目的是方便根据SQL的查询条件加速定位到叶子节点，特别是当B+树比较深的时候，通过自适应Hash索引可以明显提高数据的检索效率。 我们可以通过innodb_adaptive_hash_index变量来查看是否开启了自适应Hash，比如： 1show variables like &#x27;%adaptive_hash_index&#x27;; Redis 存储的核心就是 Hash 表 6.3 二叉搜索树如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。 二叉树的一般情况的查找就不赘述了。 极端情况： 有时二叉树的深度非常大。比如我们给出的数据顺序是（5，22，23，34，77，89，91），此时二叉树就是这样的： 上面的树也属于二叉树，但是性能上退化为了链表，查找数据的时间复杂度变成了O(n)。 那么为了提高查询效率，就需要减少磁盘IO次数。为了减少磁盘IO次数，就需要尽量降低树的高度，将原来瘦高的树结构变成矮胖，树的每层的分叉越多越好。 6.4 AVL树为了解决二叉树退化成链表的问题，我们就提出了平衡二叉搜索树(Balanced Binary Tree)，又称为AVL树，它在二叉搜索树的基础上增加了约束，具有以下性质： 它是一棵空树或它的左右两个字数的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。 每访问一次节点就需要进行一次磁盘 I/O 操作，对于上面的树来说，我们需要进行5次I/O操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。 6.5 B-TreeB树（Balance Tree），也就是多路平衡二叉树。简写为B-Tree。它的高度远小于平衡二叉树的高度。 B树的结构如下图： B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，M 称为 B 树的阶。每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包含了 x 个关键字，那么指针数就是 x+1。对于一个100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的。 一个M阶的B树（M &gt; 2）有以下的特性： 根节点的儿子数的范围是 [2 , M). 每个中间节点包含k-1个关键字和k个孩子，孩子的数量 = 关键字的数量 + 1，k的取值范围为[ceil (M / 2), M]。 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k的取值范围为[ceil (M / 2), M]。 假设中间节点，节点的关键字为：Key[1],Key[2],…,Key[k - 1],且关键字按照升序排序，即 Key[ i ]&lt;Key[i + 1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k],其中P[1]指向关键字小于Key[1]的子树。P[i]指向关键字属于（Key[i - 1],Key[i]）的子树，P[k]指向关键字大于 Key[k - 1]的子树。 所有叶子节点位于同一层。 小结： B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。 关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束 其搜索性能等价于在关键字全集内做一次二分查找。 举例： 6.6 B+TreeB+树也是一种多路搜索树，基于 B 树做出了改进，主流的DBMS都支持 B+树的索引方式，比如 MySQL。相比于B-Tree，B+Tree适合文件索引系统。 B+树和B树的差异： 有k个孩子的节点就有k个关键字。也就是孩子数量 = 关键字数，而 B树种，孩子数量 = 关键字数 + 1。 非叶子节点的关键字也会同时存在在子节点中，并且是在子结点中所有关键字的最大（或最小）。 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点既保存索引，也保存数据记录。 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到达顺序链接。 B+ 树和 B 树有个根本的差异在于，B+ 树的中间节点并不直接存储数据。这样的好处都有什么呢？ B+树的查询效率更稳定 B+树的查询效率更高，这是因为通常B+ 树比B 树更矮胖（阶数更大，深度更低），查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。 不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的。而在B树种则需要通过中序遍历才能完成查询范围的查找，效率要低很多。 B树和B+树都可以作为索引的数据结构，在MySQL中采用的是B+树。 但B树和B+树各有自己的应用场景。 B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/（8B+8B）=1K个键值（因为是估值，方便计算，K的取值为10^3），也就是说一个深度为 3 的B+Tree索引可以维护 10 ^ 3 * 10 ^ 3 * 10 ^ 3 = 10 亿条记录。这里假定一个数据也也存储10 ^ 3条行记录 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在 2~4 层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时，最多只需要1~3次磁盘IO操作。 Hash 索引与 B+树索引的区别 1、Hash索引不能进行范围查询，而B+树可以。因为Hash索引指向的数据是无序的，而B+树的叶子节点是一个有序的链表。 2、Hash索引不支持联合索引的最左前缀法则（即联合索引的部分索引无法使用）。 3、Hash索引不支持 ORDER BY 排序，因为Hash索引指向的数据是无序的，无法起到排序优化的作用。同理我们也无法使用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（%结尾）的话就可以起到优化作用 4、InnoDB不支持Hash索引 6.7 R树R-Tree在MySQL中很少使用，仅支持geometry数据类型。R树很好的解决了高维空间搜索问题。地图的搜索，20公里内所有的餐厅。 R树就是一棵用来存储高维数据的平衡树。 索引/存储引擎 MyISAM InnoDB Memory R-Tree索引 支持 支持 不支持","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://cuiyuangeng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://cuiyuangeng.cn/tags/MySQL/"}]},{"title":"InnoDB锁算法与锁机制","slug":"InnoDB锁算法与锁机制","date":"2022-03-13T16:00:00.000Z","updated":"2022-03-21T07:14:09.587Z","comments":true,"path":"2022/03/14/InnoDB锁算法与锁机制/","link":"","permalink":"https://cuiyuangeng.cn/2022/03/14/InnoDB%E9%94%81%E7%AE%97%E6%B3%95%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、常用的两种存储引擎1. MyISAM与InnoDB 是否支持行级锁 MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。 是否支持事务 MyISAM不提供事务支持，InnoDB提供事务支持，具有提交（commit）和回滚（rollback）的事务能力。 是否支持外键 MyISAM不支持外键，InnoDB支持外键 是否支持数据库异常崩溃后的安全恢复 MyISAM不支持，InnoDB支持。 使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log。 InnoDB 使用redo log（重做日志）保证事务的持久性，使用undo log（回滚日志）来保证事务的原子性。 通过 锁机制，MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEATABLE-READ） 保证了事务的持久性，原子性，隔离性之后，一致性才能得到保障 2. 锁机制与InnoDB锁算法MyISAM和InnoDB存储引擎使用的锁： MyISAM采用表级锁。 InnoDB支持行级锁和表级锁默认为行级锁。 表级锁和行级锁对比： 表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。 行级锁：MySQL中锁定粒度最小的一种锁，对当前操作的行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持三种行锁定： 行锁（Record Lock）：锁直接加在索引记录上面，锁住的是key。 间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而设计的。 后码锁（Next-Key Lock）：行锁和间隙锁组合起来就叫Next-Key Lock。 默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。 2.1 行锁（Record Lock） 当需要对表中的某条数据进行写操作（insert，update，delete，select for update）时，需要先获取记录的排他锁（X锁），这个就称为行锁。 123456789101112131415create table x(`id` int, `num` int, index `idx_id` (`id`));insert into x values(1, 1), (2, 2);-- 事务ASTART TRANSACTION;update x set id = 1 where id = 1;-- 事务B-- 如果事务A没有commit，id=1的记录拿不到X锁，将出现等待START TRANSACTION;update x set id = 1 where id = 1;-- 事务C-- id=2的记录可以拿到X锁，不会出现等待START TRANSACTION;update x set id = 2 where id = 2; 针对InnoDB RR隔离级别，行锁的特点：“锁定特定行不允许进行修改”，但行锁是基于表索引的，如果where条件中用的是num字段（非索引列）将产生不一样的现象： 123456789101112131415161718-- 事务ASTART TRANSACTION;update x set num = 1 where num = 1;-- 事务B-- 由于事务A中num字段上没有索引将产生表锁，导致整张表的写操作都会出现等待START TRANSACTION;update x set num = 1 where num = 1;-- 事务C-- 同理，会出现等待START TRANSACTION;update x set num = 2 where num = 2;-- 事务D-- 等待START TRANSACTION;insert into x values(3, 3); 2.2 Gap锁（Gap Lock）在MySQL中select称为快照读，不需要锁，而insert、update、delete、select for update则称为当前读，需要给数据加锁，幻读中的“读”即是针对当前读。 RR事务隔离级别允许存在幻读，但InnoDB RR级别却通过Gap锁避免了幻读 产生间隙锁的条件（RR事务隔离级别下） 使用普通索引锁定 使用多列唯一索引 使用唯一索引锁定多行记录 唯一索引的间隙锁 数据表 12345CREATE TABLE `test` ( `id` int(1) NOT NULL AUTO_INCREMENT, `name` varchar(8) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据 1234INSERT INTO `test` VALUES (&#x27;1&#x27;, &#x27;小罗&#x27;);INSERT INTO `test` VALUES (&#x27;5&#x27;, &#x27;小黄&#x27;);INSERT INTO `test` VALUES (&#x27;7&#x27;, &#x27;小明&#x27;);INSERT INTO `test` VALUES (&#x27;11&#x27;, &#x27;小红&#x27;); 只使用记录锁，不会产生间隙锁1234567891011121314151617/* 开启事务1 */BEGIN;/* 查询 id = 5 的数据并加记录锁 */SELECT * FROM `test` WHERE `id` = 5 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 name = &#x27;小张&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小张&#x27;); # 正常执行/* 事务3插入一条 name = &#x27;小张&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;小东&#x27;); # 正常执行/* 提交事务1，释放事务1的锁 */COMMIT; 以上，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以，只会对id=5的数据加上记录锁，而不会产生间隙锁。 产生间隙锁1234567891011121314151617181920212223242526272829303132/* 开启事务1 */BEGIN;/* 查询 id 在 7 - 11 范围的数据并加记录锁 */SELECT * FROM `test` WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (3, &#x27;小张1&#x27;); # 正常执行/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小白&#x27;); # 正常执行/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (6, &#x27;小东&#x27;); # 阻塞/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;大罗&#x27;); # 阻塞/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (9, &#x27;大东&#x27;); # 阻塞/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (11, &#x27;李西&#x27;); # 阻塞/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (12, &#x27;张三&#x27;); # 正常执行/* 提交事务1，释放事务1的锁 */COMMIT; 锁住不存在的数据1234567891011121314151617181920212223/* 开启事务1 */BEGIN;/* 查询 id = 3 这一条不存在的数据并加记录锁 */SELECT * FROM `test` WHERE `id` = 3 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (2, &#x27;小张1&#x27;); # 阻塞/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小白&#x27;); # 阻塞/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (6, &#x27;小东&#x27;); # 正常执行/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;大罗&#x27;); # 正常执行/* 提交事务1，释放事务1的锁 */COMMIT; 我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁 结论 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：WHERE id = 5 FOR UPDATE; 对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE id BETWEEN 5 AND 7 FOR UPDATE; 普通索引的间隙锁数据准备 创建test1表： number 不是唯一值 123456CREATE TABLE `test1` ( `id` int(1) NOT NULL AUTO_INCREMENT, `number` int(1) NOT NULL COMMENT &#x27;数字&#x27;, PRIMARY KEY (`id`), KEY `number` (`number`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; id 是主键，number上建立了一个普通索引。先加一些数据： 1234INSERT INTO `test1` VALUES (1, 1);INSERT INTO `test1` VALUES (5, 3);INSERT INTO `test1` VALUES (7, 8);INSERT INTO `test1` VALUES (11, 12); test1表中 number 索引存在的隐藏间隙： (-infinity, 1](1, 3](3, 8](8, 12](12, +infinity] 执行以下的事务（事务1最后提交)1234567891011121314151617181920212223242526272829303132/* 开启事务1 */BEGIN;/* 查询 number = 5 的数据并加记录锁 */SELECT * FROM `test1` WHERE `number` = 3 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 number = 0 的数据 */INSERT INTO `test1` (`number`) VALUES (0); -- 正常执行/* 事务3插入一条 number = 1 的数据 */INSERT INTO `test1` (`number`) VALUES (1); -- 被阻塞/* 事务4插入一条 number = 2 的数据 */INSERT INTO `test1` (`number`) VALUES (2); -- 被阻塞/* 事务5插入一条 number = 4 的数据 */INSERT INTO `test1` (`number`) VALUES (4); -- 被阻塞/* 事务6插入一条 number = 8 的数据 */INSERT INTO `test1` (`number`) VALUES (8); -- 正常执行/* 事务7插入一条 number = 9 的数据 */INSERT INTO `test1` (`number`) VALUES (9); -- 正常执行/* 事务8插入一条 number = 10 的数据 */INSERT INTO `test1` (`number`) VALUES (10); -- 正常执行/* 提交事务1 */COMMIT; 这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。 123456789101112131415161718192021222324252627282930/* 开启事务1 */BEGIN;/* 查询 number = 5 的数据并加记录锁 */SELECT * FROM `test1` WHERE `number` = 3 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);/* 事务1插入一条 id = 2， number = 1 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (2, 1); -- 阻塞/* 事务2插入一条 id = 3， number = 2 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (3, 2); -- 阻塞/* 事务3插入一条 id = 6， number = 8 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (6, 8); -- 阻塞/* 事务4插入一条 id = 8， number = 8 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (8, 8); -- 正常执行/* 事务5插入一条 id = 9， number = 9 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (9, 9); -- 正常执行/* 事务6插入一条 id = 10， number = 12 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (10, 12); -- 正常执行/* 事务7修改 id = 11， number = 12 的数据 */UPDATE `test1` SET `number` = 5 WHERE `id` = 11 AND `number` = 12; -- 阻塞/* 提交事务1 */COMMIT; 这里有一个奇怪的现象： 事务3添加 id = 6，number = 8 的数据，给阻塞了；事务4添加 id = 8，number = 8 的数据，正常执行了。事务7将 id = 11，number = 12 的数据修改为 id = 11， number = 5的操作，给阻塞了； 当 number 相同时，会根据主键 id 来排序，所以： 事务3添加的 id = 6，number = 8，这条数据是在 （3, 8） 的区间里边，所以会被阻塞；事务4添加的 id = 8，number = 8，这条数据则是在（8, 12）区间里边，所以不会被阻塞；事务7的修改语句相当于在 （3, 8） 的区间里边插入一条数据，所以也被阻塞了。 结论 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序 2.3 后码锁（Next-key Lock）后码锁是记录锁与间隙锁的组合，也是为了避免幻读。如果把事务的隔离级别降级为RC，Next-key Lock 则也会失效。 总结 记录锁、间隙锁、后码锁，都属于排它锁； 记录锁就是锁住一行记录； 间隙锁只有在事务级别RR中才会产生； 唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁； 普通索引不管是锁住单条，还是多条记录，都会产生间隙锁； 间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其他事务在这个区域插入、修改、删除数据，这是为了防止出现幻读现象； 普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序； 事务级别RC（读已提交）级别的话。间隙锁将会失效。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://cuiyuangeng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://cuiyuangeng.cn/tags/MySQL/"}]},{"title":"Linux简单的开发环境搭建","slug":"Linux服务器简单开发环境搭建","date":"2022-03-06T10:14:00.000Z","updated":"2022-03-09T08:25:23.165Z","comments":true,"path":"2022/03/06/Linux服务器简单开发环境搭建/","link":"","permalink":"https://cuiyuangeng.cn/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Linux开发环境搭建( CentOS-7 )1. 安装JDK 将jdk通过 xftp5 上传到 /opt 下 12345678910# 解压缩到/opt下tar -zxvf jdk-8u231-linux-x64.tar.gz# 配置环境变量vi /etc/profile# 在profile文件末尾追加以下指令JAVA_HOME=/OPT/jdk1.8.0_231PATH=/opt/jdk1.8.0_231/bin:$PATHexport JAVA_HOME PATH# 让配置文件生效source /etc/profile 2. 安装MySql123456789101112131415161718192021222324252627282930yum install mysql mysql-server mysql-devel -y# 启动服务yum install -y mariadb-serversystemctl start mariadb.service# 开放3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reloadfirewall-cmd --zone=public --list-ports# 或关闭防火墙systemctl stop firewalld.servicesystemctl disable firewalld.service# 启动mysql客户端mysql -u root -p# 默认没有密码 回车即可use mysql;update user set password=password(&#x27;root&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;flush privileges;# 授权远程访问grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;root&#x27;;flush privileges;# 设置开机启动systemctl enable mariadb.service# 修改字符编码cd /usr/share/mysqlcp my-small.cnf /etc/my.cnfvi /etc/my.cnf# 修改内容character_set_server=utf8# 重启mysql服务systemctl restart mariadb.service 3. 安装Tomcat12345678tar -zxvf apache-tomcat-9.0.34.tar.gzcd apache-tomcat-9.0.34/cd bin# 启动tomcat./startup.sh# 开放8080端口 防火墙关闭则不用firewall-cmd --zone=public --add-port=8080/tcp --permanentsystemctl restart firewalld.service 4. 安装Redis-3.0.0 Redis是C语言开发，需要gcc环境 yum -y install gcc 将redis-x-x-x.tar.gz 上传至/usr/local下 123456789101112# 解压 # 进入redis目录 使用make命令编译rediscd redis-3.0.0make# 建立软连接 类似于windows下的快捷方式ln -s /usr/local/redis-3.0.0/src/redis-server /usr/bin/redis-serverln -s /usr/local/redis-3.0.0/src/redis-cli /usr/bin/redis-cli# 修改redis.conf daemonize=yes# 后台模式启动redisredis-server redis.conf 5. 安装Docker123456789yum install docker# 启动dockersystemctl start docker# 查看docker版本docker -v# 开机启动docker systemctl enable docker# 停止dockersystemctl stop docker 6.安装Zookeeper，部署Dubbo123456789101112131415161718192021222324252627282930# 拉取zookeeper镜像docker pull zookeeper# 启动镜像docker run --name zookeeper01 -p 2181:2181 --restart always -d 镜像id# 拉取tomcat镜像docker pull tomcat:9.0.59-jdk8# 启动tomcatdocker run --name tomcat_dubbo -d -p 8080:8080 --privileged=true tomcat# 进入tomcat容器docker exec -it tomcat_dubbo /bin/bash# webapps是空的此时测试tomcat为404 将webapps.dist 改名为webappsmv webapps webapps2mv webapps.dist webapps# 复制 dubbo-admin-2.6.0.war 到容器内的webapps下docker cp dubbo-admin-2.5.7.war tomcat_dubbo:/usr/local/tomcat/webapps/# 重启tomcat容器docker restart tomcat_dubbo# 进入容器docker exec -it tomcat_dubbo /bin/bash# 容器内安装vim编辑器apt-get updateapt-get install vim# 修改dubbo.propertiesvim /usr/local/tomcat/webapps/dubbo-admin-2.5.7/WEB-INF/dubbo.properties# 修改内容如下dubbo.registry.address=zookeeper://82.157.232.222:2181dubbo.admin.root.password=rootdubbo.admin.guest.password=guest# 重启tomcatdocker restart tomcat_dubbo 测试Dubbo http://82.157.232.222:2181/dubbo-admin-2.5.7/","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cuiyuangeng.cn/tags/Linux/"}]},{"title":"Mybatis框架","slug":"Mybatis框架","date":"2021-12-11T13:47:08.000Z","updated":"2022-04-05T03:45:02.597Z","comments":true,"path":"2021/12/11/Mybatis框架/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Java框架（Framework）框架技术123是一个应用程序的半成品提供可重用的公共结构按一定规则组织的一组组件 优势12345不用再考虑公共问题专心在业务实现上结构统一，易于学习、维护 主流框架介绍1234567891011121314151617181920212223242526272829303132333435363738Struts2 MVC设计模式的重现 拦截器 可变和可重用的标签HIBERNATE ORM,简化数据库操作 Dao层Spring 依赖注入容器/AOP实现 声明式事务 简化Java EE应用 粘合剂，将大家组装到一起Spring MVC 结构最清晰的MVC Model2实现 高度可配置，支持多种视图技术 定制化开发 MyBatis 半自动化的ORM实现 DAO层 动态SQL 持久化与ORM（Object Relational Mapping）123456789持久化是程序数据在瞬时状态和持久状态转换的过程ORM 编写程序的时候，以面向对象的方式处理数据 保存数据的时候，却以关系型数据库的方式存储ORM解决方案包含下面四个部分 在持久化对象上执行基本的增删改查操作 对持久化对象提供一种查询语言或者API 对象关系映射工具 提供与事务对象交互、执行检查、延迟加载以及其他优化功能 MyBatis 1234567891011MyBatis前身是iBatis，本是Apache的一个开源项目官网 http：//mybatis.orgORM框架实体类和SQL语句之间建立映射关系特点 基于SQL语法，简单易学 能了解底层封装过程 SQL语句封装在配置文件中，便于统一管理与维护，降低程序的耦合度 方便程序代码调试MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 一、安装MyBatispom.xml依赖1234567891011&lt;!--版本号--&gt;&lt;properties&gt; &lt;mabits-version&gt;3.2.2&lt;/mabits-version&gt;&lt;/properties&gt;&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mabits-version&#125;&lt;/version&gt;&lt;/dependency&gt; 二、使用MyBatis的开发步骤12345678下载mybatis-3.2.2jar包并导入工程编写MyBatis核心配置文件(configuration.xml)创建实体类-POJODAO层-SQL映射文件(mapper.xml)创建测试类 读取全局配置文件mybatis-config.xml 创建SqlSessionFactory对象，读取配置文件 创建SqlSession对象 database.properties1234567jdbc.driver=com.mysql.jdbc.Driver#数据库jdbc.url=jdbc:mysql://localhost:3306/leavedb?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8#用户名jdbc.username=root#密码jdbc.password=123456 mybatis-config.xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入外部文件--&gt; &lt;properties resource=&quot;database.properties&quot;&gt;&lt;/properties&gt; &lt;!--别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.cyg.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 从 XML 中构建 SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易 1234567891011121314151617181920212223242526public class MyBatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; // 获取sqlSessionFactory对象 String resource = &quot;mybatisconfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句 public static SqlSession getSqlSession() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125; //关闭SqlSession public static void closeSqlSession(SqlSession sqlSession)&#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 从 SqlSessionFactory 中获取 SqlSession既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如: 123try (SqlSession session = sqlSessionFactory.openSession()) &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; 现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换 1234try (SqlSession session = sqlSessionFactory.openSession()) &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; 三、编写代码实体类–&gt;pojo123456789public class Student &#123; private Integer studentNo; private String loginPwd; private String studentName; private String sex; private Integer gradeId; private String phone; private String gName;&#125; 接口–&gt;mapper12345678910111213141516public interface StudentMapper &#123; //查询所有学生 List&lt;Student&gt; getAllStudent(); //根据学号studentNo查询学生 Student getStudentByStudentNo(Integer studentNo); //根据姓名studentName模糊查询 List&lt;Student&gt; getStudentByStudentName(@Param(&quot;studentName&quot;) String studentName, @Param(&quot;gradeId&quot;)Integer gradeId); //查询用户总记录数 Integer countStudentInfo(); //根据id修改用户信息 Integer updateStudent(Student student); //添加用户 Integer addStudent(Student student); //删除 Integer deleteStudent(Student student);&#125; Mapper.xml配置123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!---mapper路径--&gt;&lt;mapper namespace=&quot;cn.cyg.mapper.StudentMapper&quot;&gt; &lt;!--增删改查标签--&gt; &lt;select&gt;&lt;/select&gt; &lt;update&gt;&lt;/update&gt; &lt;insert&gt;&lt;/insert&gt; &lt;delete&gt;&lt;/delete&gt;&lt;/mapper&gt; 四、动态mysql动态SQL是MyBatis的强大特性之一 if1234567891011&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; trim123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; set和trim12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125;&lt;/update&gt; foreach​ 动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如： 123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 bind12345&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot; /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 标签 作用 if 单条件分支，相当于java的if choose、when、otherwise 不想使用所有的条件，而只是想从多个条件中选择一个使用。相当于switch语句；如果都没有传入when标签，那么就会执行otherwise where、set 只会在子元素返回任何内容的情况下才插入where子句，而且where元素会自动去除and和or；set会自动去除 –&gt; ， &lt;– trim 可以通过自定义trim元素来定制where和set；prefix前缀；prefixOverrides去除前缀；suffix后缀；suffixOverrides去除后缀 foreach 对集合进行遍历（构建IN条件语句时）声明可以在元素体内使用集合项（item）和索引（index）变量。也允许指定开头与结尾的字符串以及集合迭代之间的分隔符。当使用Map对象时，index是键，item是值 bind 允许在OGNL表达式以外创建一个变量，并将其绑定到当前的上下文 name；value OGNL表达式Object Graphic Navigation Language(对象 图 导航 语言)==对象导航图语言 语法：#{} 参数1.parameterType(输入类型)​ 1）传递简单类型 ​ 2）传递pojo对象 ​ Mybatis使用ognl表达式解析对象字段的值，#{}或者${}中的值为pojo属性名称 ​ 3）传递pojo包装对象 ​ 开发中通过pojo传递查询条件，不仅包括用户查询条件还包括其他的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数 2.resultType(输出类型)​ 1）输出简单类型 ​ ​ 2）输出pojo对象 123&lt;select id=&quot;queryUserById&quot; resultType=&quot;User&quot;&gt; select * from user where id=#&#123;id&#125;&lt;/select&gt; ​ 3）输出pojo列表 3.resultMap结果类型​ resultType可以指定将查询结果映射为pojo，但是需要pojo的属性名和sql查询的列名一致方可映射成功 ​ 如果sql查询字段名和pojo属性名不一致，可以通过resultMap将字段名和属性名作为一个对应关系，resultMap实质上还需要将查询结果映射到pojo对象中 ​ resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询 返回列名和实体类属性不一致解决方案一：别名 123&lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt; select id,userName name from user&lt;/select&gt; 解决方案二：使用resultMap 优势：开发效率高，降低代码耦合度 1234567&lt;resultMap id=&quot;uesrList&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;userName&quot; property=&quot;name&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllUser&quot; resultMap=&quot;userList&quot;&gt; select * from user&lt;/select&gt; 多数据库支持如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子： 1234567891011&lt;insert id=&quot;insert&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt; &lt;if test=&quot;_databaseId == &#x27;oracle&#x27;&quot;&gt; select seq_users.nextval from dual &lt;/if&gt; &lt;if test=&quot;_databaseId == &#x27;db2&#x27;&quot;&gt; select nextval for seq_users from sysibm.sysdummy1&quot; &lt;/if&gt; &lt;/selectKey&gt; insert into users values (#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt; 五、Mybatis中的多表查询1.一对一查询123456789101112&lt;resultMap id=&quot;aMap&quot; type=&quot;Account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;uId&quot; column=&quot;uId&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt; &lt;!--一对一的映射关系：配置封装user的内容--&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;uId&quot;&gt; &lt;id column=&quot;userId&quot; property=&quot;id&quot; /&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 2.一对多查询用户信息和账户信息为一对多关系，如果用户没有账户，也要将该用户查出来，所以此时使用左外连接查询 一对多关系映射，主表实体包含从表实体的集合引用 123456789101112&lt;resultMap id=&quot;uMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;userName&quot; property=&quot;userName&quot;/&gt; &lt;!--配置user对象中account集合的映射--&gt; &lt;collection property=&quot;accountList&quot; ofType=&quot;Account&quot;&gt; &lt;id column=&quot;aId&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt; &lt;result column=&quot;uId&quot; property=&quot;uId&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 3.多对多查询一个用户可以有多个角色，一个角色可以赋予多个用户 RoleMapper.xml文件 1234567891011121314151617&lt;resultMap id=&quot;rMap&quot; type=&quot;Role&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;roleName&quot; column=&quot;roleName&quot;/&gt; &lt;result column=&quot;roleDesc&quot; property=&quot;roleDesc&quot;/&gt; &lt;collection property=&quot;userList&quot; ofType=&quot;User&quot;&gt; &lt;id column=&quot;uId&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;userName&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getAllRoleAndUser&quot; resultMap=&quot;rMap&quot;&gt; SELECT r.*, u.id uId, u.userName, u.sex, u.birthday FROM role r LEFT JOIN user_role ur ON r.id = ur.rid LEFT JOIN USER u ON u.id = ur.uId &lt;/select&gt; UserMapper.xml文件 1234567891011121314151617&lt;resultMap id=&quot;uMap1&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;userName&quot; property=&quot;userName&quot;/&gt; &lt;collection property=&quot;roleList&quot; ofType=&quot;Role&quot;&gt; &lt;id column=&quot;rId&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;roleName&quot; property=&quot;roleName&quot;/&gt; &lt;result column=&quot;roleDesc&quot; property=&quot;roleDesc&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getAllUser1&quot; resultMap=&quot;uMap1&quot;&gt; SELECT u.*, r.roleName, r.id rId, r.roleDesc FROM USER u LEFT JOIN user_role ur ON ur.uId = u.id LEFT JOIN role r ON ur.rId = r.id &lt;/select&gt; 六、Mybatis延迟加载一、概述1.mybatis中的延迟加载，也称为懒加载 2.是指在进行关联查询时，按照设置延迟规则对关联对象的select查询。 延迟加载可以有效的减少数据库的压力 3.延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓的延迟加载就是挡在真正需要的时候，才真正执行数据的加载 二、关联对象加载时机 直接加载： ​ 执行完对主加载对象的select语句，马上执行对关联对象的select查询 侵入式加载： ​ 侵入式延迟加载，执行主对象属性时，会走关联对象SQL语句，如果不访问主对象的属性，则不会走关联对象 深度延迟加载： ​ 执行对主加载对象的查询时，不会执行对关联对象的查询，访问主加载对象的详情时，也不会执行关联对象的select查询，只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。 访问主对象的属性，只执行了主对象的sql操作，并没有走关联对象的sql语句 延迟加载的应用要求： 关联对象的查询与主加载对象的查询必须是分别进行的select语句，不能使用多表连接所进行的select查询 三、直接加载、侵入式加载、深度加载1.核心配置文件 2.测试直接加载： 侵入式加载： 深度延迟加载： 四、总结延迟加载： 延迟加载对主对象都是直接加载，只有对关联对象时延迟加载 延迟加载可以减轻数据库压力 延迟加载不可以是一条SQL查询多表信息，这样构不成延迟加载，会形成直接加载 七、Mybatis中的缓存1.什么是缓存？缓存就是数据交换的缓冲区（Cache），是存储数据（使用频繁的数据）的临时空间 当要读取数据时，会首先从缓存查询数据，有就直接执行，不存在时从内存/数据库中获取 默认情况下，mabatis只开启一级缓存 2.为什么使用缓存减少和数据库交互的次数，提高执行效率 3.什么样的数据能使用缓存适用于缓存： ​ 1）经常查询并且经常使用 ​ 2）数据的正确与否对最终结果影响不大 不适用于缓存： ​ 1）经常改变的数据 ​ 2）数据的正确与否对最终结果影响很大 ​ 3）比如：商品的库存，银行汇率，股票价格 Mybatis的一级缓存 它指的是Mybatis中SqlSession对象的缓存 同一个SqlSession对象，在参数和SQL完全一样的情况下，只执行一次SQL语句 当我们执行查询之后，查询的结果会同时存入到SqlSession提供一块区域，该区域的结构是一个Map，当我们再次查询同样的数据，mybatis会先去SqlSession中查询，如果有直接使用；当SqlSession消失时，mybatis的一级缓存也就消失了 清空一级缓存的方法： 关闭SqlSession对象==&gt;sqlSession.close() 调用SqlSession对象的clearCache()方法==&gt;sqlSession.clearCache() 调用增删改方法 Mybatis的二级缓存​ 它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存 二级缓存开关全局开关核心配置 分开关 Mapper.xml文件中配置 让当前的映射文件支持二级缓存 select标签中配置 让当前的操作支持二级缓存 flushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存 useCache默认为true，表示会将本条语句的结果进行二级缓存。","categories":[],"tags":[{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"https://cuiyuangeng.cn/tags/Mybatis%E6%A1%86%E6%9E%B6/"}]},{"title":"数据结构","slug":"数据结构","date":"2021-12-11T13:44:05.000Z","updated":"2022-04-05T03:46:32.013Z","comments":true,"path":"2021/12/11/数据结构/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构与算法数据结构数据1数据是表述客观事务的符号，是计算机中可以被操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符以及声音、图像、视频等非数值类型。 数据元素1是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项1一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象1数据对象是性质相同的数据元素的集合，是数据的子集。 数据结构12345678数据结构没有官方统一定义&quot;数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。&quot; Sartaj Sahni，《数据结构、算法与应用》&quot;数据结构是ADT(抽象数据类型Abstract Data Type)的物理实现&quot; Clifford A.Shaffer，《数据结构与算法分析》&quot;数据结构(data structure) 是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。&quot; 中文维基百科在计算机中数据元素并不是孤立杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式--《大话数据结构》 数据怎么组织 跟数据的规模有关系，不一样的规模处理起来的难度不一样。 解决问题方法的效率，跟数据的组织方式有关。 逻辑结构与物理结构逻辑结构1逻辑结构：是指数据对象中元素之间的相互关系 1.集合结构1集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据是“平等”的，他们的共同属性是“同属于一个集合” 2.线性结构1线性结构中的数据元素之间是一对一的关系 3.树形结构1树形结构中的数据元素存在一种一对多的层次关系 4.图形结构1图形结构的数据元素是多对多的关系 物理结构1.顺序存储结构12是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所占位置的大小乘以9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样依次摆放。 2.链式存储结构1把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置 逻辑结构是面向问题的，而物理结构就是面向计算机的，其最基本的目标就是将数据及其逻辑关系存储到计算机的内存中。 抽象数据类型数据类型1数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称 抽象数据类型1Abstract Data Type，ADT：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。 算法（Algorithm）123456789算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 一个有限指令集 接受一些输入 产生输出 一定在有限步骤之后终止 每一条指令必须： 有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖于任何一种计算机语言以及具体的实现手段 算法的五个基本特性12345输入、输出、有穷性、确定性和可行性·输入和输出：算法具有零个或多个输入，至少有一个输出或输出·有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成·确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义·可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 算法设计的要求12345678正确性：指算法至少应该具有输入。输出和加工处理无歧义性。能正确反映问题的需求、能够得到问题的正确答案。 1.算法程序没有语法错误。 2.算法程序对于合法的输入数据能够产生满足要求的输出的结果 3.算法程序对于非法的输入数据能够得出满足规格说明的结果。 4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果可读性：算法设计的另一个目的是为了便于阅读、理解和交流。健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。时间效率高和存储量低 时间与空间复杂度12时间复杂度:调用时间空间复杂度:所占内存 算法效率的度量方法12345671.事后统计法:通过统计,监控,利用计算机计时器对不同算法的运行时间进行比较,从而确定算法效率的高低,但是有非常大的局限性.2.事前分析估算:在计算机程序编制前,依据统计方法对算法进行估算.一个高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 1.算法采用的策略、方法 算法好坏的根本 2.编译产生的代码质量 软件来支持 3.问题的输入规模 4.机器执行指令的速度 计算机硬件性能 事后统计法:123456//递归实现 public static long fun1(long n )&#123; if(n&lt;=1) return n; return fun1(n-1)+fun1(n-2); &#125;//递归:自己调用自己 123456789101112131415//循环实现public static int fun2(int n)&#123; if(n&lt;=1) return n ; int first=0; int second=1; for(int i=0;i&lt;n-1;i++)&#123; int sum=first+second; first=second; second=sum; &#125; return second;&#125;public static void main(String[] args)&#123; System.out.println(fun1(n:4));&#125; 事前分析估算:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void cal01(int age)&#123; 6//1*unit-time O(1) if(age&gt;58)&#123;//unit-time System.out.println(&quot;阿姨&quot;); &#125;else if(age&gt;28)&#123; System.out.println(&quot;小姐姐&quot;); &#125;else&#123; System.out.println(&quot;美少女&quot;); &#125;&#125;int cal02(int n)&#123; int sum=0; //1 //3+3n unit-time O(n) int i=1;//1 //i执行n次 执行n次 for(;i&lt;=n;i++)&#123;//n //n sum=sum+i;//执行n次 &#125; return sum;//执行1次//1&#125;public void cal03(int n)&#123; //1+3n unit-time O(n) for(int i=0;i&lt;n;i++)&#123;//n n n +1 System.out.println(&quot;崔源耕&quot;);//执行n次 &#125;&#125;public void cal04(int n)&#123; //1+2n+n*(1+3n)=3n^2+3n+1 O(n^2) for(int i=0;i&lt;n;i++)&#123;//1 n n for(int j=0;j&lt;n;j++)&#123;n(1+n+n+n) System.out.println(&quot;Cui&quot;); &#125; &#125;&#125;public void cal05(int n)&#123; //1+2n+n*(1+20+20+20)=1+2n+61n=63n //T(n)=O(n) for(int i=0;i&lt;n;i++)&#123; for(int j=0;i&lt;20;j++)&#123; System.out.println(&quot;Cui&quot;); &#125; &#125;&#125;public void cal06(int n)&#123; //log2(n) //T(n)=O(logn)// int i=1;//1 while(i&lt;n)&#123; i=i*2;// &#125;&#125;public void cal07(int n)&#123; //1+2*log2(n)+log2(n)*(1+3n) //T(n)=O(nlog(n)) for(int i=1;i&lt;n;i=2i)&#123; for(int j=0;j&lt;n;j++)&#123; System.out.println(&quot;ayi&quot;); &#125; &#125;&#125; 空间复杂度1S(n) 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。 时间复杂度123456T(n)=O(f(n))T(n)表示代码执行时间;n表示数据规模的大小;f(n)表示每行代码执行的次数总和.因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比.大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度 函数的渐近增长1算法A 要做2n+3次操作 算法B要做3n+1次操作 次数 算法A（2n+3） 算法A‘（2n） 算法B（3n+1） 算法B’（3n） n=1 5 2 4 3 n=2 7 4 7 6 n=3 9 6 10 9 n=10 23 20 31 30 n=100 203 200 301 300 12输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。 线性表123456789一个线性表是0个或n个具有相同特性的数据元素的有限且有序数列数组按照顺讯存储在连续位置的存储器中数组与列表相比,在特定位置添加或者删除元素成本过高优点:空间利用率高查询速度高效,通过下标来直接存取缺点插入和删除比较慢,比如:插入或者删除一个元素时,整个表需要遍历移动元素来重新排一次排序不可以增长长度,有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现&quot;溢出&quot;问题,当元素个数远少于预先分配空间时,空间浪费巨大 选择排序1234567891011121314151617181920212223242526272829303132/** * 选择排序 * 比冒泡排序交换次数少，比较次数不变 * @author 10217 * */public class SortNum &#123; public static void main(String[] args) &#123; int arr[] = &#123; 4, 7, 3, 9, 1 &#125;; int min = -1;// 最小值下标 int temp = 0; //外层循环：比较几轮 for (int i = 0; i &lt; arr.length - 1; i++) &#123; min = i;//每轮min初始值 //内层循环：当前元素和后面的元素比较，记录最新的最小元素下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; //如果min值发生变化，说明发现了更小的值，则当前值和更小值交换，保证小值放在数组前面 if (min != i) &#123; temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; &#125; &#125; for(int num :arr) &#123; System.out.print(num+&quot;\\t&quot;); &#125; &#125;&#125; 二分（折半）查找法12345678910111213141516public static int binarySearch(int[] arr, int num) &#123; int startIndex = 0; int endIndex = arr.length - 1; Arrays.sort(arr);//快速排序 如果给定数组不是升序数组那么使用快排，是则忽略 while (startIndex &lt;= endIndex) &#123; int midIndex = startIndex + (endIndex - startIndex) / 2;//如果使用（endIndex+startIndex）/2计算 如果数组长度太大会导致溢出 if (num == arr[midIndex]) &#123;//如果num就是midindex所指向的元素 return true； return midIndex; &#125; else if (num &gt; arr[midIndex]) &#123;//如果num&gt;midindex 开始下标则是midindex的下一位 startIndex = midIndex + 1; &#125; else &#123;//如果num&lt;midindex 结束下标则是midindex的前一位 endIndex = midIndex - 1; &#125; &#125; return -1; &#125;","categories":[],"tags":[]},{"title":"设计模式（未完成）","slug":"设计模式(未完成)","date":"2021-12-11T13:43:03.000Z","updated":"2022-03-09T08:24:52.927Z","comments":true,"path":"2021/12/11/设计模式(未完成)/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/","excerpt":"","text":"设计模式（Design pattern）设计模式是一套被反复使用的，多数人知晓的，经过分类编目的、代码设计经验的总结。 为什么使用设计模式？使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 什么是GOF？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承 设计模式的类型共计23种设计模式 分为三大类： 创建型模式（Creational Patterns） 结构型模式（Structural Patterns） 行为型模式（Behavioral Patterns） ​ J2EE 设计模式 创建型模式 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定示例需要创建那些对象时更加灵活 12345·工厂模式(Factory Pattern)·抽象工厂模式(Abstract Factory Pattern)·单例模式(Singleton Pattern)·建造者模式(Builder Pattern)·原型模式(Prototype Pattern) 结构型模式 关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式 12345678·适配器模式（Adapter Pattern）·桥接模式（Bridge Pattern）·过滤器模式（Filter、Criteria Pattern）·组合模式（Composite Pattern）·装饰器模式（Decorator Pattern）·外观模式（Facade Pattern）·享元模式（Flyweight Pattern） ·代理模式（Proxy Pattern） 行为型模式 关注对象之间的通信 123456789101112·责任链模式（Chain of Responsibility Pattern）·命令模式（Command Pattern）·解释器模式（Interpreter Pattern）·迭代器模式（Iterator Pattern）·中介者模式（Mediator Pattern）·备忘录模式（Memento Pattern）·观察者模式（Observer Pattern）·状态模式（State Pattern）·空对象模式（Null Object Pattern）·策略模式（Strategy Pattern）·模板模式（Template Pattern）·访问者模式（Visitor Pattern） J2EE模式 特别关注表示层 12345678·MVC 模式（MVC Pattern）·业务代表模式（Business Delegate Pattern）·组合实体模式（Composite Entity Pattern）·数据访问对象模式（Data Access Object Pattern）·前端控制器模式（Front Controller Pattern）·拦截过滤器模式（Intercepting Filter Pattern）·服务定位器模式（Service Locator Pattern）·传输对象模式（Transfer Object Pattern） 设计模式的七大原则1.开闭原则对扩展开放、对修改关闭。在程序需要进行扩展时，不能去修改原有代码，实现一个热插拔的效果，为了使程序的扩展性好。易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类 2.里氏代换原则里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方。子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则时对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体规范 3.依赖倒转原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4.接口隔离原则使用多个隔离的接口，比使用单个接口要好。降低类的耦合度。 由此可见其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5.迪米特法则，又称最少知道原则一个实体应当尽量少地与其他实体之间发生相互作用，使用系统功能模块相对独立 6.合成复用原则尽量使用合成/聚合的方式，而不是使用继承 7.单一职责原则","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cuiyuangeng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"时间复杂度的计算","slug":"时间复杂度的计算","date":"2021-12-11T11:35:58.000Z","updated":"2022-03-19T13:54:38.903Z","comments":true,"path":"2021/12/11/时间复杂度的计算/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/","excerpt":"","text":"算法定义算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 一个有限指令集 接受一些输入 产生输出 一定在有限步骤后终止 每一条指令必须： 有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖于任何一种计算机语言以及具体的实现手段 算法设计的要求正确性、可读性、健壮性、时间效率高和存储量低 算法效率的度量方法事后统计法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低 例：求第n个斐波那契数列 **事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算** 程序在计算机上运行时所消耗的时间取决于以下几个因素： 算法采用的策略、方法==&gt;算法好坏的根本 编译产生的代码质量==&gt;由IDE、软件支持 问题的输入规模 机器执行指令的速度==&gt;看计算机硬件的性能 时间复杂度什么是时间复杂度 T(n)=O(f(n)) T(n)表示代码执行时间; n表示数据规模的大小; f(n)表示每行代码执行的次数总和. 因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比. 大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度 函数的渐近增长1算法A 要做2n+3次操作 算法B要做3n+1次操作 次数 算法A（2n+3） 算法A‘（2n） 算法B（3n+1） 算法B’（3n） n=1 5 2 4 3 n=2 7 4 7 6 n=3 9 6 10 9 n=10 23 20 31 30 n=100 203 200 301 300 12输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。 一秒之内能解决问题的数据规模 数据规模 时间复杂度 1 10 n！ 2 20~30 2^n 3 50 n^4 4 100 n^3 5 1000 n^2 6 10^6 nlogn 7 10^7 n 8 10^9 sqrt(n) 9 10^10 logn 10 无穷大 1 阿里面试题假设给出一个算法的时间复杂度递推关系式：T(n）=T(n-1)+n，T(0)=1；（n为整数）求该算法的时间复杂度","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://cuiyuangeng.cn/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://cuiyuangeng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","permalink":"https://cuiyuangeng.cn/tags/Linux/"},{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"https://cuiyuangeng.cn/tags/Mybatis%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"https://cuiyuangeng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}