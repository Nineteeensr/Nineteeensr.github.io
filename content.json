{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://cuiyuangeng.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-03-07T12:56:44.596Z","updated":"2022-03-06T07:25:58.953Z","comments":false,"path":"/404.html","permalink":"https://cuiyuangeng.cn/404.html","excerpt":"","text":""},{"title":"about","date":"2022-03-06T08:33:45.000Z","updated":"2022-03-19T13:47:08.873Z","comments":true,"path":"about/index.html","permalink":"https://cuiyuangeng.cn/about/index.html","excerpt":"","text":"崔源耕软件工程专业2022年6月应届生Java后端工程师精通低并发编程（狗头保命）喜欢编程，喜欢探索新技术 “总有一天你将破蛹而出，成长得比人们期待的还要美丽。但这个过程会很痛，会很辛苦，有时候还会觉得灰心。面对着汹涌而来的现实，觉得自己渺小无力。但这，也是生命的一部分。做好现在你能做的，然后，一切都会好的。我们都将孤独地长大，不要害怕。” 这是毛星云博客上的一段话，他注释： “ 这句话一直写在我C++笔记本的扉页上。 每当我对前路迷茫的时候，就会翻开扉页，看着这段文字淡淡的笔迹发一会呆，然后就渐渐释然了。 今天我把它留在自己的博客里，希望它也能帮助到那些迷茫的朋友们。”"},{"title":"分类","date":"2022-03-07T12:56:44.599Z","updated":"2022-03-06T07:25:58.956Z","comments":false,"path":"categories/index.html","permalink":"https://cuiyuangeng.cn/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-07T12:56:44.601Z","updated":"2022-03-06T07:25:58.959Z","comments":false,"path":"repository/index.html","permalink":"https://cuiyuangeng.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-07T12:56:44.601Z","updated":"2022-03-06T08:04:26.314Z","comments":false,"path":"tags/index.html","permalink":"https://cuiyuangeng.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库（未完成）","slug":"数据库","date":"2022-03-15T13:43:03.000Z","updated":"2022-03-19T13:45:22.537Z","comments":true,"path":"2022/03/15/数据库/","link":"","permalink":"https://cuiyuangeng.cn/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"一、常用的两种存储引擎MyISAM与InnoDB 是否支持行级锁 MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。 是否支持事务 MyISAM不提供事务支持，InnoDB提供事务支持，具有提交（commit）和回滚（rollback）的事务能力。 是否支持外键 MyISAM不支持外键，InnoDB支持外键 是否支持数据库异常崩溃后的安全恢复 MyISAM不支持，InnoDB支持。 使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log。 InnoDB 使用redo log（重做日志）保证事务的持久性，使用undo log（回滚日志）来保证事务的原子性。 通过 锁机制，MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEATABLE-READ） 保证了事务的持久性，原子性，隔离性之后，一致性才能得到保障 锁机制与InnoDB锁算法MyISAM和InnoDB存储引擎使用的锁： MyISAM采用表级锁。 InnoDB支持行级锁和表级锁默认为行级锁。 表级锁和行级锁对比： 表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。 行级锁：MySQL中锁定粒度最小的一种锁，对当前操作的行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持三种行锁定： 行锁（Record Lock）：锁直接加在索引记录上面，锁住的是key。 间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而设计的。 后码锁（Next-Key Lock）：行锁和间隙锁组合起来就叫Next-Key Lock。 默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。 行锁（Record Lock） 当需要对表中的某条数据进行写操作（insert，update，delete，select for update）时，需要先获取记录的排他锁（X锁），这个就称为行锁。 123456789101112131415create table x(`id` int, `num` int, index `idx_id` (`id`));insert into x values(1, 1), (2, 2);-- 事务ASTART TRANSACTION;update x set id = 1 where id = 1;-- 事务B-- 如果事务A没有commit，id=1的记录拿不到X锁，将出现等待START TRANSACTION;update x set id = 1 where id = 1;-- 事务C-- id=2的记录可以拿到X锁，不会出现等待START TRANSACTION;update x set id = 2 where id = 2; 针对InnoDB RR隔离级别，行锁的特点：“锁定特定行不允许进行修改”，但行锁是基于表索引的，如果where条件中用的是num字段（非索引列）将产生不一样的现象： 123456789101112131415161718-- 事务ASTART TRANSACTION;update x set num = 1 where num = 1;-- 事务B-- 由于事务A中num字段上没有索引将产生表锁，导致整张表的写操作都会出现等待START TRANSACTION;update x set num = 1 where num = 1;-- 事务C-- 同理，会出现等待START TRANSACTION;update x set num = 2 where num = 2;-- 事务D-- 等待START TRANSACTION;insert into x values(3, 3); Gap锁（Gap Lock）在MySQL中select称为快照读，不需要锁，而insert、update、delete、select for update则称为当前读，需要给数据加锁，幻读中的“读”即是针对当前读。 RR事务隔离级别允许存在幻读，但InnoDB RR级别却通过Gap锁避免了幻读 产生间隙锁的条件（RR事务隔离级别下） 使用普通索引锁定 使用多列唯一索引 使用唯一索引锁定多行记录 唯一索引的间隙锁 数据表 12345CREATE TABLE `test` ( `id` int(1) NOT NULL AUTO_INCREMENT, `name` varchar(8) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据 1234INSERT INTO `test` VALUES (&#x27;1&#x27;, &#x27;小罗&#x27;);INSERT INTO `test` VALUES (&#x27;5&#x27;, &#x27;小黄&#x27;);INSERT INTO `test` VALUES (&#x27;7&#x27;, &#x27;小明&#x27;);INSERT INTO `test` VALUES (&#x27;11&#x27;, &#x27;小红&#x27;); 只使用记录锁，不会产生间隙锁1234567891011121314151617/* 开启事务1 */BEGIN;/* 查询 id = 5 的数据并加记录锁 */SELECT * FROM `test` WHERE `id` = 5 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 name = &#x27;小张&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小张&#x27;); # 正常执行/* 事务3插入一条 name = &#x27;小张&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;小东&#x27;); # 正常执行/* 提交事务1，释放事务1的锁 */COMMIT; 以上，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以，只会对id=5的数据加上记录锁，而不会产生间隙锁。 产生间隙锁1234567891011121314151617181920212223242526272829303132/* 开启事务1 */BEGIN;/* 查询 id 在 7 - 11 范围的数据并加记录锁 */SELECT * FROM `test` WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (3, &#x27;小张1&#x27;); # 正常执行/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小白&#x27;); # 正常执行/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (6, &#x27;小东&#x27;); # 阻塞/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;大罗&#x27;); # 阻塞/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (9, &#x27;大东&#x27;); # 阻塞/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (11, &#x27;李西&#x27;); # 阻塞/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (12, &#x27;张三&#x27;); # 正常执行/* 提交事务1，释放事务1的锁 */COMMIT; 锁住不存在的数据1234567891011121314151617181920212223/* 开启事务1 */BEGIN;/* 查询 id = 3 这一条不存在的数据并加记录锁 */SELECT * FROM `test` WHERE `id` = 3 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (2, &#x27;小张1&#x27;); # 阻塞/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小白&#x27;); # 阻塞/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (6, &#x27;小东&#x27;); # 正常执行/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;大罗&#x27;); # 正常执行/* 提交事务1，释放事务1的锁 */COMMIT; 我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁 结论 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：WHERE id = 5 FOR UPDATE; 对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE id BETWEEN 5 AND 7 FOR UPDATE; 普通索引的间隙锁数据准备 创建test1表： number 不是唯一值 123456CREATE TABLE `test1` ( `id` int(1) NOT NULL AUTO_INCREMENT, `number` int(1) NOT NULL COMMENT &#x27;数字&#x27;, PRIMARY KEY (`id`), KEY `number` (`number`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; id 是主键，number上建立了一个普通索引。先加一些数据： 1234INSERT INTO `test1` VALUES (1, 1);INSERT INTO `test1` VALUES (5, 3);INSERT INTO `test1` VALUES (7, 8);INSERT INTO `test1` VALUES (11, 12); test1表中 number 索引存在的隐藏间隙： (-infinity, 1](1, 3](3, 8](8, 12](12, +infinity] 执行以下的事务（事务1最后提交)1234567891011121314151617181920212223242526272829303132/* 开启事务1 */BEGIN;/* 查询 number = 5 的数据并加记录锁 */SELECT * FROM `test1` WHERE `number` = 3 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句/* 事务2插入一条 number = 0 的数据 */INSERT INTO `test1` (`number`) VALUES (0); -- 正常执行/* 事务3插入一条 number = 1 的数据 */INSERT INTO `test1` (`number`) VALUES (1); -- 被阻塞/* 事务4插入一条 number = 2 的数据 */INSERT INTO `test1` (`number`) VALUES (2); -- 被阻塞/* 事务5插入一条 number = 4 的数据 */INSERT INTO `test1` (`number`) VALUES (4); -- 被阻塞/* 事务6插入一条 number = 8 的数据 */INSERT INTO `test1` (`number`) VALUES (8); -- 正常执行/* 事务7插入一条 number = 9 的数据 */INSERT INTO `test1` (`number`) VALUES (9); -- 正常执行/* 事务8插入一条 number = 10 的数据 */INSERT INTO `test1` (`number`) VALUES (10); -- 正常执行/* 提交事务1 */COMMIT; 这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。 123456789101112131415161718192021222324252627282930/* 开启事务1 */BEGIN;/* 查询 number = 5 的数据并加记录锁 */SELECT * FROM `test1` WHERE `number` = 3 FOR UPDATE;/* 延迟30秒执行，防止锁释放 */SELECT SLEEP(30);/* 事务1插入一条 id = 2， number = 1 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (2, 1); -- 阻塞/* 事务2插入一条 id = 3， number = 2 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (3, 2); -- 阻塞/* 事务3插入一条 id = 6， number = 8 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (6, 8); -- 阻塞/* 事务4插入一条 id = 8， number = 8 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (8, 8); -- 正常执行/* 事务5插入一条 id = 9， number = 9 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (9, 9); -- 正常执行/* 事务6插入一条 id = 10， number = 12 的数据 */INSERT INTO `test1` (`id`, `number`) VALUES (10, 12); -- 正常执行/* 事务7修改 id = 11， number = 12 的数据 */UPDATE `test1` SET `number` = 5 WHERE `id` = 11 AND `number` = 12; -- 阻塞/* 提交事务1 */COMMIT; 这里有一个奇怪的现象： 事务3添加 id = 6，number = 8 的数据，给阻塞了；事务4添加 id = 8，number = 8 的数据，正常执行了。事务7将 id = 11，number = 12 的数据修改为 id = 11， number = 5的操作，给阻塞了； 当 number 相同时，会根据主键 id 来排序，所以： 事务3添加的 id = 6，number = 8，这条数据是在 （3, 8） 的区间里边，所以会被阻塞；事务4添加的 id = 8，number = 8，这条数据则是在（8, 12）区间里边，所以不会被阻塞；事务7的修改语句相当于在 （3, 8） 的区间里边插入一条数据，所以也被阻塞了。 结论 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序 后码锁（Next-key Lock）后码锁是记录锁与间隙锁的组合，也是为了避免幻读。如果把事务的隔离级别降级为RC，Next-key Lock 则也会失效。 总结 记录锁、间隙锁、后码锁，都属于排它锁； 记录锁就是锁住一行记录； 间隙锁只有在事务级别RR中才会产生； 唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁； 普通索引不管是锁住单条，还是多条记录，都会产生间隙锁； 间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其他事务在这个区域插入、修改、删除数据，这是为了防止出现幻读现象； 普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序； 事务级别RC（读已提交）级别的话。间隙锁将会失效。 二、索引的数据结构1. 为什么使用索引索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描 对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即二叉搜索树，二叉搜索树的每个节点存储的是(K,V)结构，key是该字段，value是该key所在行的文件指针（地址）。 目的是为了减少磁盘I/O的次数，加速查询速率 2. 索引的优缺点2.1 索引概述索引是在存储引擎中实现的，因此每种存储引擎的索引不一定相同。同时存储引擎可以定义每个表的最大索引数和最大索引长度。 所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。 2.2 优点 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本,这也是创建索引最主要的原因。 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 在实现数据的参考完整性方面，可以加速表和表之间的连接。 ​ 即对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的功耗。 2.3 缺点 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。 索引需要占用 磁盘空间，除了数据表占数据空间，每个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 虽然索引提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增删改，索引也需要动态地维护 因此，选择使用索引时，要综合考虑索引的优点和缺点。 提示： 索引可以提高查询的速度，但会影响插入记录的速度。这种情况，最好的办法是 先删除表中的索引，然后插入数据，插入完成后再创建索引 3.InnoDB中索引的推演3.1 索引之前的查找先来看一个精确匹配的例子： 1SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 1.在单页中查找 存储数据的基本单位：数据页。一个数据页的默认大小为:16 KB 以主键为搜索条件 ​ 可以在页目录中使用 二分法快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录 以其他列作为搜索条件 ​ 因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比。 2.在很多页中查找在很多页中查找记录的话可以分为两个步骤： 定位到记录所在的页 从所在的页内中查找相应的记录 在没有索引的情况下，无论是根据主键列或其他列进行查找，只能从第一个页沿着双向链表一直往下找。 3.2 设计索引1. 一个简单的索引设计方案建表： 123456CREATE TABLE index_demo( c1 INT, c2 INT, c3 CHAR(1), PRIMARY KEY(c1)) ROW_FORMAT = Compact; record_type：记录头信息的一项属性，表示记录的类型，0表示普通记录,2表示最小记录、3表示最大记录 next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁 各个列的值：这里只记录在index_demo表中的三个列，分别是c1、c2、c3 其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。 把一些记录放到页里的示意图就是： 给所有的页建立一个目录项 由于数据页的编号可能是不连续的，所以在向index_demo表中插入许多记录后，可能是： 因为这些16KB的页在物理存储上是不连续的，所以如果想从这么多页种根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每页对应一个目录项，每个目录项包括下边两个部分： 页的用户记录中最小的主键值，我们用key来表示 页号，我们用page_no表示 所以我们为上边几个页做好的目录就像这样： 我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的记录： 先从目录项中根据二分法快速确定出主键值20的记录在目录项3中，它对应的页为页9 再根据二分法查找记录的方式去页9中定位具体的记录 至此，针对数据页做的简易目录就搞定了。这个目录我们可以称为索引 2. InnoDB中的索引方案①迭代1次：目录项记录的页设计的简易索引方案，是因为我们为了在根据主键值进行查找时，使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储,但是这样做有几个问题： InnoDB时使用页作为管理存储空间的基本单位，最多保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。 我们经常会对记录进行增删，假设我们把页28中的记录都删除了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样导致了操作效率很差。 所以，我们需要一种可以灵活管理所有目录项的方式。我们发现目录项其实长的跟我们用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。InnoDB如何区分一条记录是普通的用户记录还是目录项记录么？使用记录头信息的record_type属性，它的各个取值代表的意思如下： 0：普通的用户记录 1：目录项记录 2：最小记录 3：最大记录 把使用的目录项放到数据页中的样子就是这样： 从图中可以看出来，我们分配了一个编号为30的页来专门存储目录项记录。 目录项记录和普通的用户记录的不同点： 目录项记录的record_type值是1，而普通用户记录的record_type值是0 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。 了解：记录头信息里还有一个叫min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都为0 相同点：两者用的是一样的数据页，都会为主键值生成Page Directory（页目录），从而在按照主键值进行查找时，可以使用二分法来加快查询速度。 现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两部： 先到存储目录项记录的页，也就是页30中通过二分法 快速定位到对应目录项，因为12 &lt; 20 &lt; 209，所以 ②迭代2次：多个目录项记录的页虽然说目录项记录中只存储主键值和对应的页号,比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，能存放的目录项记录也是有限的，那如果表中的数据太多,以至于一个数据页不足以存放所有的目录项记录，如何处理呢？ 这里我们假设一个存储目录项记录的页最多只能存放4条目录项记录,所以如果此时我们再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储目录项记录的页: ③迭代3次：目录项记录页的目录页在第二次迭代的查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些页是不连续的，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像一个多级目录，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子： 如图，我们生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1, 320)之间,则到页30中查找更详细的目录项记录，如果主键值不小于320的话，就到页32中查找更详细的目录项记录。 随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它： 这个数据结构，就是B+树 ④B+Tree无论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，即叶子节点,B+树最上边的节点称为根节点. 用户记录存放在B+树的叶子节点上，每一个叶子节点中的每一行数据通过单向链表的方式存储，而叶子节点之间是双向链表。 树的层次越低，IO次数越少 一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找三个目录项页和一个用户记录页），又因为在每个页面内又所谓的Page Directory（页目录），所以在页面内也可以通过二分法来实现快速定位记录。 总结叶子节点：存储实际数据记录，其中又record_type=2标记最小主键值,record_type=3标记最大主键值 内节点：存储每一个数据页的页码以及每一页record_type=2的最小主键值，即数据的目录页 根节点或第二层节点：存储的是目录页的记录，每一个目录页的最小主键值以及目录页的页码 3.3 常见索引概念索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或辅助索引 1. 聚簇索引聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。 术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。 特点： 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内的记录是按照主键的大小顺序排成一个单向链表。 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。 B+树的叶子节点存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引. 优点： 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树种，因此从聚簇索引中获取数据比非聚簇索引更快。 聚簇索引对于主键的排序查找和范围查找速度非常快 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的IO操作 缺点： 插入速度严重依赖与插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列作为主键 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。 限制： 对于MySQL数据库目前著有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。 由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况就是该表的主键。 如果没有定义主键，InnoDB会选择非空的唯一索引代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。 为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://cuiyuangeng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Linux简单的开发环境搭建","slug":"Linux服务器简单开发环境搭建","date":"2022-03-06T10:14:00.000Z","updated":"2022-03-09T08:25:23.165Z","comments":true,"path":"2022/03/06/Linux服务器简单开发环境搭建/","link":"","permalink":"https://cuiyuangeng.cn/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Linux开发环境搭建( CentOS-7 )1. 安装JDK 将jdk通过 xftp5 上传到 /opt 下 12345678910# 解压缩到/opt下tar -zxvf jdk-8u231-linux-x64.tar.gz# 配置环境变量vi /etc/profile# 在profile文件末尾追加以下指令JAVA_HOME=/OPT/jdk1.8.0_231PATH=/opt/jdk1.8.0_231/bin:$PATHexport JAVA_HOME PATH# 让配置文件生效source /etc/profile 2. 安装MySql123456789101112131415161718192021222324252627282930yum install mysql mysql-server mysql-devel -y# 启动服务yum install -y mariadb-serversystemctl start mariadb.service# 开放3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reloadfirewall-cmd --zone=public --list-ports# 或关闭防火墙systemctl stop firewalld.servicesystemctl disable firewalld.service# 启动mysql客户端mysql -u root -p# 默认没有密码 回车即可use mysql;update user set password=password(&#x27;root&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;flush privileges;# 授权远程访问grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;root&#x27;;flush privileges;# 设置开机启动systemctl enable mariadb.service# 修改字符编码cd /usr/share/mysqlcp my-small.cnf /etc/my.cnfvi /etc/my.cnf# 修改内容character_set_server=utf8# 重启mysql服务systemctl restart mariadb.service 3. 安装Tomcat12345678tar -zxvf apache-tomcat-9.0.34.tar.gzcd apache-tomcat-9.0.34/cd bin# 启动tomcat./startup.sh# 开放8080端口 防火墙关闭则不用firewall-cmd --zone=public --add-port=8080/tcp --permanentsystemctl restart firewalld.service 4. 安装Redis-3.0.0 Redis是C语言开发，需要gcc环境 yum -y install gcc 将redis-x-x-x.tar.gz 上传至/usr/local下 123456789101112# 解压 # 进入redis目录 使用make命令编译rediscd redis-3.0.0make# 建立软连接 类似于windows下的快捷方式ln -s /usr/local/redis-3.0.0/src/redis-server /usr/bin/redis-serverln -s /usr/local/redis-3.0.0/src/redis-cli /usr/bin/redis-cli# 修改redis.conf daemonize=yes# 后台模式启动redisredis-server redis.conf 5. 安装Docker123456789yum install docker# 启动dockersystemctl start docker# 查看docker版本docker -v# 开机启动docker systemctl enable docker# 停止dockersystemctl stop docker 6.安装Zookeeper，部署Dubbo123456789101112131415161718192021222324252627282930# 拉取zookeeper镜像docker pull zookeeper# 启动镜像docker run --name zookeeper01 -p 2181:2181 --restart always -d 镜像id# 拉取tomcat镜像docker pull tomcat:9.0.59-jdk8# 启动tomcatdocker run --name tomcat_dubbo -d -p 8080:8080 --privileged=true tomcat# 进入tomcat容器docker exec -it tomcat_dubbo /bin/bash# webapps是空的此时测试tomcat为404 将webapps.dist 改名为webappsmv webapps webapps2mv webapps.dist webapps# 复制 dubbo-admin-2.6.0.war 到容器内的webapps下docker cp dubbo-admin-2.5.7.war tomcat_dubbo:/usr/local/tomcat/webapps/# 重启tomcat容器docker restart tomcat_dubbo# 进入容器docker exec -it tomcat_dubbo /bin/bash# 容器内安装vim编辑器apt-get updateapt-get install vim# 修改dubbo.propertiesvim /usr/local/tomcat/webapps/dubbo-admin-2.5.7/WEB-INF/dubbo.properties# 修改内容如下dubbo.registry.address=zookeeper://82.157.232.222:2181dubbo.admin.root.password=rootdubbo.admin.guest.password=guest# 重启tomcatdocker restart tomcat_dubbo 测试Dubbo http://82.157.232.222:2181/dubbo-admin-2.5.7/","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cuiyuangeng.cn/tags/Linux/"}]},{"title":"Mybatis框架","slug":"Mybatis框架","date":"2021-12-11T13:47:08.000Z","updated":"2022-03-19T13:54:21.716Z","comments":true,"path":"2021/12/11/Mybatis框架/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Java框架（Framework）框架技术123是一个应用程序的半成品提供可重用的公共结构按一定规则组织的一组组件 优势12345不用再考虑公共问题专心在业务实现上结构统一，易于学习、维护 主流框架介绍1234567891011121314151617181920212223242526272829303132333435363738Struts2 MVC设计模式的重现 拦截器 可变和可重用的标签HIBERNATE ORM,简化数据库操作 Dao层Spring 依赖注入容器/AOP实现 声明式事务 简化Java EE应用 粘合剂，将大家组装到一起Spring MVC 结构最清晰的MVC Model2实现 高度可配置，支持多种视图技术 定制化开发 MyBatis 半自动化的ORM实现 DAO层 动态SQL 持久化与ORM（Object Relational Mapping）123456789持久化是程序数据在瞬时状态和持久状态转换的过程ORM 编写程序的时候，以面向对象的方式处理数据 保存数据的时候，却以关系型数据库的方式存储ORM解决方案包含下面四个部分 在持久化对象上执行基本的增删改查操作 对持久化对象提供一种查询语言或者API 对象关系映射工具 提供与事务对象交互、执行检查、延迟加载以及其他优化功能 MyBatis 1234567891011MyBatis前身是iBatis，本是Apache的一个开源项目官网 http：//mybatis.orgORM框架实体类和SQL语句之间建立映射关系特点 基于SQL语法，简单易学 能了解底层封装过程 SQL语句封装在配置文件中，便于统一管理与维护，降低程序的耦合度 方便程序代码调试MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 一、安装MyBatispom.xml依赖1234567891011&lt;!--版本号--&gt;&lt;properties&gt; &lt;mabits-version&gt;3.2.2&lt;/mabits-version&gt;&lt;/properties&gt;&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mabits-version&#125;&lt;/version&gt;&lt;/dependency&gt; 二、使用MyBatis的开发步骤12345678下载mybatis-3.2.2jar包并导入工程编写MyBatis核心配置文件(configuration.xml)创建实体类-POJODAO层-SQL映射文件(mapper.xml)创建测试类 读取全局配置文件mybatis-config.xml 创建SqlSessionFactory对象，读取配置文件 创建SqlSession对象 database.properties1234567jdbc.driver=com.mysql.jdbc.Driver#数据库jdbc.url=jdbc:mysql://localhost:3306/leavedb?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8#用户名jdbc.username=root#密码jdbc.password=123456 mybatis-config.xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入外部文件--&gt; &lt;properties resource=&quot;database.properties&quot;&gt;&lt;/properties&gt; &lt;!--别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.cyg.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 从 XML 中构建 SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易 1234567891011121314151617181920212223242526public class MyBatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; // 获取sqlSessionFactory对象 String resource = &quot;mybatisconfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句 public static SqlSession getSqlSession() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125; //关闭SqlSession public static void closeSqlSession(SqlSession sqlSession)&#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 从 SqlSessionFactory 中获取 SqlSession既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如: 123try (SqlSession session = sqlSessionFactory.openSession()) &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; 现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换 1234try (SqlSession session = sqlSessionFactory.openSession()) &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; 三、编写代码实体类–&gt;pojo123456789public class Student &#123; private Integer studentNo; private String loginPwd; private String studentName; private String sex; private Integer gradeId; private String phone; private String gName;&#125; 接口–&gt;mapper12345678910111213141516public interface StudentMapper &#123; //查询所有学生 List&lt;Student&gt; getAllStudent(); //根据学号studentNo查询学生 Student getStudentByStudentNo(Integer studentNo); //根据姓名studentName模糊查询 List&lt;Student&gt; getStudentByStudentName(@Param(&quot;studentName&quot;) String studentName, @Param(&quot;gradeId&quot;)Integer gradeId); //查询用户总记录数 Integer countStudentInfo(); //根据id修改用户信息 Integer updateStudent(Student student); //添加用户 Integer addStudent(Student student); //删除 Integer deleteStudent(Student student);&#125; Mapper.xml配置123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!---mapper路径--&gt;&lt;mapper namespace=&quot;cn.cyg.mapper.StudentMapper&quot;&gt; &lt;!--增删改查标签--&gt; &lt;select&gt;&lt;/select&gt; &lt;update&gt;&lt;/update&gt; &lt;insert&gt;&lt;/insert&gt; &lt;delete&gt;&lt;/delete&gt;&lt;/mapper&gt; 四、动态mysql动态SQL是MyBatis的强大特性之一 if1234567891011&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; trim123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; set和trim12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125;&lt;/update&gt; foreach​ 动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如： 123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 bind12345&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot; /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 标签 作用 if 单条件分支，相当于java的if choose、when、otherwise 不想使用所有的条件，而只是想从多个条件中选择一个使用。相当于switch语句；如果都没有传入when标签，那么就会执行otherwise where、set 只会在子元素返回任何内容的情况下才插入where子句，而且where元素会自动去除and和or；set会自动去除 –&gt; ， &lt;– trim 可以通过自定义trim元素来定制where和set；prefix前缀；prefixOverrides去除前缀；suffix后缀；suffixOverrides去除后缀 foreach 对集合进行遍历（构建IN条件语句时）声明可以在元素体内使用集合项（item）和索引（index）变量。也允许指定开头与结尾的字符串以及集合迭代之间的分隔符。当使用Map对象时，index是键，item是值 bind 允许在OGNL表达式以外创建一个变量，并将其绑定到当前的上下文 name；value OGNL表达式Object Graphic Navigation Language(对象 图 导航 语言)==对象导航图语言 语法：#{} 参数1.parameterType(输入类型)​ 1）传递简单类型 ​ 2）传递pojo对象 ​ Mybatis使用ognl表达式解析对象字段的值，#{}或者${}中的值为pojo属性名称 ​ 3）传递pojo包装对象 ​ 开发中通过pojo传递查询条件，不仅包括用户查询条件还包括其他的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数 2.resultType(输出类型)​ 1）输出简单类型 ​ ​ 2）输出pojo对象 123&lt;select id=&quot;queryUserById&quot; resultType=&quot;User&quot;&gt; select * from user where id=#&#123;id&#125;&lt;/select&gt; ​ 3）输出pojo列表 3.resultMap结果类型​ resultType可以指定将查询结果映射为pojo，但是需要pojo的属性名和sql查询的列名一致方可映射成功 ​ 如果sql查询字段名和pojo属性名不一致，可以通过resultMap将字段名和属性名作为一个对应关系，resultMap实质上还需要将查询结果映射到pojo对象中 ​ resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询 返回列名和实体类属性不一致解决方案一：别名 123&lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt; select id,userName name from user&lt;/select&gt; 解决方案二：使用resultMap 优势：开发效率高，降低代码耦合度 1234567&lt;resultMap id=&quot;uesrList&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;userName&quot; property=&quot;name&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllUser&quot; resultMap=&quot;userList&quot;&gt; select * from user&lt;/select&gt; 多数据库支持如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子： 1234567891011&lt;insert id=&quot;insert&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt; &lt;if test=&quot;_databaseId == &#x27;oracle&#x27;&quot;&gt; select seq_users.nextval from dual &lt;/if&gt; &lt;if test=&quot;_databaseId == &#x27;db2&#x27;&quot;&gt; select nextval for seq_users from sysibm.sysdummy1&quot; &lt;/if&gt; &lt;/selectKey&gt; insert into users values (#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt; 五、Mybatis中的多表查询1.一对一查询123456789101112&lt;resultMap id=&quot;aMap&quot; type=&quot;Account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;uId&quot; column=&quot;uId&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt; &lt;!--一对一的映射关系：配置封装user的内容--&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;uId&quot;&gt; &lt;id column=&quot;userId&quot; property=&quot;id&quot; /&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 2.一对多查询用户信息和账户信息为一对多关系，如果用户没有账户，也要将该用户查出来，所以此时使用左外连接查询 一对多关系映射，主表实体包含从表实体的集合引用 123456789101112&lt;resultMap id=&quot;uMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;userName&quot; property=&quot;userName&quot;/&gt; &lt;!--配置user对象中account集合的映射--&gt; &lt;collection property=&quot;accountList&quot; ofType=&quot;Account&quot;&gt; &lt;id column=&quot;aId&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt; &lt;result column=&quot;uId&quot; property=&quot;uId&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 3.多对多查询一个用户可以有多个角色，一个角色可以赋予多个用户 RoleMapper.xml文件 1234567891011121314151617&lt;resultMap id=&quot;rMap&quot; type=&quot;Role&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;roleName&quot; column=&quot;roleName&quot;/&gt; &lt;result column=&quot;roleDesc&quot; property=&quot;roleDesc&quot;/&gt; &lt;collection property=&quot;userList&quot; ofType=&quot;User&quot;&gt; &lt;id column=&quot;uId&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;userName&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getAllRoleAndUser&quot; resultMap=&quot;rMap&quot;&gt; SELECT r.*, u.id uId, u.userName, u.sex, u.birthday FROM role r LEFT JOIN user_role ur ON r.id = ur.rid LEFT JOIN USER u ON u.id = ur.uId &lt;/select&gt; UserMapper.xml文件 1234567891011121314151617&lt;resultMap id=&quot;uMap1&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;result column=&quot;userName&quot; property=&quot;userName&quot;/&gt; &lt;collection property=&quot;roleList&quot; ofType=&quot;Role&quot;&gt; &lt;id column=&quot;rId&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;roleName&quot; property=&quot;roleName&quot;/&gt; &lt;result column=&quot;roleDesc&quot; property=&quot;roleDesc&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getAllUser1&quot; resultMap=&quot;uMap1&quot;&gt; SELECT u.*, r.roleName, r.id rId, r.roleDesc FROM USER u LEFT JOIN user_role ur ON ur.uId = u.id LEFT JOIN role r ON ur.rId = r.id &lt;/select&gt; 六、Mybatis延迟加载一、概述1.mybatis中的延迟加载，也称为懒加载 2.是指在进行关联查询时，按照设置延迟规则对关联对象的select查询。 延迟加载可以有效的减少数据库的压力 3.延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓的延迟加载就是挡在真正需要的时候，才真正执行数据的加载 二、关联对象加载时机 直接加载： ​ 执行完对主加载对象的select语句，马上执行对关联对象的select查询 侵入式加载： ​ 侵入式延迟加载，执行主对象属性时，会走关联对象SQL语句，如果不访问主对象的属性，则不会走关联对象 深度延迟加载： ​ 执行对主加载对象的查询时，不会执行对关联对象的查询，访问主加载对象的详情时，也不会执行关联对象的select查询，只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。 访问主对象的属性，只执行了主对象的sql操作，并没有走关联对象的sql语句 延迟加载的应用要求： 关联对象的查询与主加载对象的查询必须是分别进行的select语句，不能使用多表连接所进行的select查询 三、直接加载、侵入式加载、深度加载1.核心配置文件 2.测试直接加载： 侵入式加载： 深度延迟加载： 四、总结延迟加载： 延迟加载对主对象都是直接加载，只有对关联对象时延迟加载 延迟加载可以减轻数据库压力 延迟加载不可以是一条SQL查询多表信息，这样构不成延迟加载，会形成直接加载 七、Mybatis中的缓存1.什么是缓存？缓存就是数据交换的缓冲区（Cache），是存储数据（使用频繁的数据）的临时空间 当要读取数据时，会首先从缓存查询数据，有就直接执行，不存在时从内存/数据库中获取 默认情况下，mabatis只开启一级缓存 2.为什么使用缓存减少和数据库交互的次数，提高执行效率 3.什么样的数据能使用缓存适用于缓存： ​ 1）经常查询并且经常使用 ​ 2）数据的正确与否对最终结果影响不大 不适用于缓存： ​ 1）经常改变的数据 ​ 2）数据的正确与否对最终结果影响很大 ​ 3）比如：商品的库存，银行汇率，股票价格 Mybatis的一级缓存 它指的是Mybatis中SqlSession对象的缓存 同一个SqlSession对象，在参数和SQL完全一样的情况下，只执行一次SQL语句 当我们执行查询之后，查询的结果会同时存入到SqlSession提供一块区域，该区域的结构是一个Map，当我们再次查询同样的数据，mybatis会先去SqlSession中查询，如果有直接使用；当SqlSession消失时，mybatis的一级缓存也就消失了 清空一级缓存的方法： 关闭SqlSession对象==&gt;sqlSession.close() 调用SqlSession对象的clearCache()方法==&gt;sqlSession.clearCache() 调用增删改方法 Mybatis的二级缓存​ 它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存 二级缓存开关全局开关核心配置 分开关 Mapper.xml文件中配置 让当前的映射文件支持二级缓存 select标签中配置 让当前的操作支持二级缓存 flushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存 useCache默认为true，表示会将本条语句的结果进行二级缓存。","categories":[],"tags":[{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"https://cuiyuangeng.cn/tags/Mybatis%E6%A1%86%E6%9E%B6/"}]},{"title":"数据结构","slug":"数据结构","date":"2021-12-11T13:44:05.000Z","updated":"2022-03-19T13:53:11.064Z","comments":true,"path":"2021/12/11/数据结构/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构与算法数据结构数据1数据是表述客观事务的符号，是计算机中可以被操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符以及声音、图像、视频等非数值类型。 数据元素1是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项1一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象1数据对象是性质相同的数据元素的集合，是数据的子集。 数据结构12345678数据结构没有官方统一定义&quot;数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。&quot; Sartaj Sahni，《数据结构、算法与应用》&quot;数据结构是ADT(抽象数据类型Abstract Data Type)的物理实现&quot; Clifford A.Shaffer，《数据结构与算法分析》&quot;数据结构(data structure) 是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。&quot; 中文维基百科在计算机中数据元素并不是孤立杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式--《大话数据结构》 数据怎么组织 跟数据的规模有关系，不一样的规模处理起来的难度不一样。 解决问题方法的效率，跟数据的组织方式有关。 逻辑结构与物理结构逻辑结构1逻辑结构：是指数据对象中元素之间的相互关系 1.集合结构1集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据是“平等”的，他们的共同属性是“同属于一个集合” 2.线性结构1线性结构中的数据元素之间是一对一的关系 3.树形结构1树形结构中的数据元素存在一种一对多的层次关系 4.图形结构1图形结构的数据元素是多对多的关系 物理结构1.顺序存储结构12是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所占位置的大小乘以9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样依次摆放。 2.链式存储结构1把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置 逻辑结构是面向问题的，而物理结构就是面向计算机的，其最基本的目标就是将数据及其逻辑关系存储到计算机的内存中。 抽象数据类型数据类型1数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称 抽象数据类型1Abstract Data Type，ADT：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。 算法（Algorithm）123456789算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 一个有限指令集 接受一些输入 产生输出 一定在有限步骤之后终止 每一条指令必须： 有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖于任何一种计算机语言以及具体的实现手段 算法的五个基本特性12345输入、输出、有穷性、确定性和可行性·输入和输出：算法具有零个或多个输入，至少有一个输出或输出·有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成·确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义·可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 算法设计的要求12345678正确性：指算法至少应该具有输入。输出和加工处理无歧义性。能正确反映问题的需求、能够得到问题的正确答案。 1.算法程序没有语法错误。 2.算法程序对于合法的输入数据能够产生满足要求的输出的结果 3.算法程序对于非法的输入数据能够得出满足规格说明的结果。 4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果可读性：算法设计的另一个目的是为了便于阅读、理解和交流。健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。时间效率高和存储量低 时间与空间复杂度12时间复杂度:调用时间空间复杂度:所占内存 算法效率的度量方法12345671.事后统计法:通过统计,监控,利用计算机计时器对不同算法的运行时间进行比较,从而确定算法效率的高低,但是有非常大的局限性.2.事前分析估算:在计算机程序编制前,依据统计方法对算法进行估算.一个高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 1.算法采用的策略、方法 算法好坏的根本 2.编译产生的代码质量 软件来支持 3.问题的输入规模 4.机器执行指令的速度 计算机硬件性能 事后统计法:123456//递归实现 public static long fun1(long n )&#123; if(n&lt;=1) return n; return fun1(n-1)+fun1(n-2); &#125;//递归:自己调用自己 123456789101112131415//循环实现public static int fun2(int n)&#123; if(n&lt;=1) return n ; int first=0; int second=1; for(int i=0;i&lt;n-1;i++)&#123; int sum=first+second; first=second; second=sum; &#125; return second;&#125;public static void main(String[] args)&#123; System.out.println(fun1(n:4));&#125; 事前分析估算:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void cal01(int age)&#123; 6//1*unit-time O(1) if(age&gt;58)&#123;//unit-time System.out.println(&quot;阿姨&quot;); &#125;else if(age&gt;28)&#123; System.out.println(&quot;小姐姐&quot;); &#125;else&#123; System.out.println(&quot;美少女&quot;); &#125;&#125;int cal02(int n)&#123; int sum=0; //1 //3+3n unit-time O(n) int i=1;//1 //i执行n次 执行n次 for(;i&lt;=n;i++)&#123;//n //n sum=sum+i;//执行n次 &#125; return sum;//执行1次//1&#125;public void cal03(int n)&#123; //1+3n unit-time O(n) for(int i=0;i&lt;n;i++)&#123;//n n n +1 System.out.println(&quot;崔源耕&quot;);//执行n次 &#125;&#125;public void cal04(int n)&#123; //1+2n+n*(1+3n)=3n^2+3n+1 O(n^2) for(int i=0;i&lt;n;i++)&#123;//1 n n for(int j=0;j&lt;n;j++)&#123;n(1+n+n+n) System.out.println(&quot;Cui&quot;); &#125; &#125;&#125;public void cal05(int n)&#123; //1+2n+n*(1+20+20+20)=1+2n+61n=63n //T(n)=O(n) for(int i=0;i&lt;n;i++)&#123; for(int j=0;i&lt;20;j++)&#123; System.out.println(&quot;Cui&quot;); &#125; &#125;&#125;public void cal06(int n)&#123; //log2(n) //T(n)=O(logn)// int i=1;//1 while(i&lt;n)&#123; i=i*2;// &#125;&#125;public void cal07(int n)&#123; //1+2*log2(n)+log2(n)*(1+3n) //T(n)=O(nlog(n)) for(int i=1;i&lt;n;i=2i)&#123; for(int j=0;j&lt;n;j++)&#123; System.out.println(&quot;ayi&quot;); &#125; &#125;&#125; 空间复杂度1S(n) 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。 时间复杂度123456T(n)=O(f(n))T(n)表示代码执行时间;n表示数据规模的大小;f(n)表示每行代码执行的次数总和.因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比.大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度 函数的渐近增长1算法A 要做2n+3次操作 算法B要做3n+1次操作 次数 算法A（2n+3） 算法A‘（2n） 算法B（3n+1） 算法B’（3n） n=1 5 2 4 3 n=2 7 4 7 6 n=3 9 6 10 9 n=10 23 20 31 30 n=100 203 200 301 300 12输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。 线性表123456789一个线性表是0个或n个具有相同特性的数据元素的有限且有序数列数组按照顺讯存储在连续位置的存储器中数组与列表相比,在特定位置添加或者删除元素成本过高优点:空间利用率高查询速度高效,通过下标来直接存取缺点插入和删除比较慢,比如:插入或者删除一个元素时,整个表需要遍历移动元素来重新排一次排序不可以增长长度,有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现&quot;溢出&quot;问题,当元素个数远少于预先分配空间时,空间浪费巨大 选择排序1234567891011121314151617181920212223242526272829303132/** * 选择排序 * 比冒泡排序交换次数少，比较次数不变 * @author 10217 * */public class SortNum &#123; public static void main(String[] args) &#123; int arr[] = &#123; 4, 7, 3, 9, 1 &#125;; int min = -1;// 最小值下标 int temp = 0; //外层循环：比较几轮 for (int i = 0; i &lt; arr.length - 1; i++) &#123; min = i;//每轮min初始值 //内层循环：当前元素和后面的元素比较，记录最新的最小元素下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; //如果min值发生变化，说明发现了更小的值，则当前值和更小值交换，保证小值放在数组前面 if (min != i) &#123; temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; &#125; &#125; for(int num :arr) &#123; System.out.print(num+&quot;\\t&quot;); &#125; &#125;&#125; 二分（折半）查找法12345678910111213141516public static int binarySearch(int[] arr, int num) &#123; int startIndex = 0; int endIndex = arr.length - 1; Arrays.sort(arr);//快速排序 如果给定数组不是升序数组那么使用快排，是则忽略 while (startIndex &lt;= endIndex) &#123; int midIndex = startIndex + (endIndex - startIndex) / 2;//如果使用（endIndex+startIndex）/2计算 如果数组长度太大会导致溢出 if (num == arr[midIndex]) &#123;//如果num就是midindex所指向的元素 return true； return midIndex; &#125; else if (num &gt; arr[midIndex]) &#123;//如果num&gt;midindex 开始下标则是midindex的下一位 startIndex = midIndex + 1; &#125; else &#123;//如果num&lt;midindex 结束下标则是midindex的前一位 endIndex = midIndex - 1; &#125; &#125; return -1; &#125;","categories":[],"tags":[]},{"title":"设计模式（未完成）","slug":"设计模式(未完成)","date":"2021-12-11T13:43:03.000Z","updated":"2022-03-09T08:24:52.927Z","comments":true,"path":"2021/12/11/设计模式(未完成)/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/","excerpt":"","text":"设计模式（Design pattern）设计模式是一套被反复使用的，多数人知晓的，经过分类编目的、代码设计经验的总结。 为什么使用设计模式？使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 什么是GOF？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承 设计模式的类型共计23种设计模式 分为三大类： 创建型模式（Creational Patterns） 结构型模式（Structural Patterns） 行为型模式（Behavioral Patterns） ​ J2EE 设计模式 创建型模式 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定示例需要创建那些对象时更加灵活 12345·工厂模式(Factory Pattern)·抽象工厂模式(Abstract Factory Pattern)·单例模式(Singleton Pattern)·建造者模式(Builder Pattern)·原型模式(Prototype Pattern) 结构型模式 关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式 12345678·适配器模式（Adapter Pattern）·桥接模式（Bridge Pattern）·过滤器模式（Filter、Criteria Pattern）·组合模式（Composite Pattern）·装饰器模式（Decorator Pattern）·外观模式（Facade Pattern）·享元模式（Flyweight Pattern） ·代理模式（Proxy Pattern） 行为型模式 关注对象之间的通信 123456789101112·责任链模式（Chain of Responsibility Pattern）·命令模式（Command Pattern）·解释器模式（Interpreter Pattern）·迭代器模式（Iterator Pattern）·中介者模式（Mediator Pattern）·备忘录模式（Memento Pattern）·观察者模式（Observer Pattern）·状态模式（State Pattern）·空对象模式（Null Object Pattern）·策略模式（Strategy Pattern）·模板模式（Template Pattern）·访问者模式（Visitor Pattern） J2EE模式 特别关注表示层 12345678·MVC 模式（MVC Pattern）·业务代表模式（Business Delegate Pattern）·组合实体模式（Composite Entity Pattern）·数据访问对象模式（Data Access Object Pattern）·前端控制器模式（Front Controller Pattern）·拦截过滤器模式（Intercepting Filter Pattern）·服务定位器模式（Service Locator Pattern）·传输对象模式（Transfer Object Pattern） 设计模式的七大原则1.开闭原则对扩展开放、对修改关闭。在程序需要进行扩展时，不能去修改原有代码，实现一个热插拔的效果，为了使程序的扩展性好。易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类 2.里氏代换原则里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方。子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则时对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体规范 3.依赖倒转原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4.接口隔离原则使用多个隔离的接口，比使用单个接口要好。降低类的耦合度。 由此可见其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5.迪米特法则，又称最少知道原则一个实体应当尽量少地与其他实体之间发生相互作用，使用系统功能模块相对独立 6.合成复用原则尽量使用合成/聚合的方式，而不是使用继承 7.单一职责原则","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cuiyuangeng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"时间复杂度的计算","slug":"时间复杂度的计算","date":"2021-12-11T11:35:58.000Z","updated":"2022-03-19T13:54:38.903Z","comments":true,"path":"2021/12/11/时间复杂度的计算/","link":"","permalink":"https://cuiyuangeng.cn/2021/12/11/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/","excerpt":"","text":"算法定义算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 一个有限指令集 接受一些输入 产生输出 一定在有限步骤后终止 每一条指令必须： 有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖于任何一种计算机语言以及具体的实现手段 算法设计的要求正确性、可读性、健壮性、时间效率高和存储量低 算法效率的度量方法事后统计法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低 例：求第n个斐波那契数列 **事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算** 程序在计算机上运行时所消耗的时间取决于以下几个因素： 算法采用的策略、方法==&gt;算法好坏的根本 编译产生的代码质量==&gt;由IDE、软件支持 问题的输入规模 机器执行指令的速度==&gt;看计算机硬件的性能 时间复杂度什么是时间复杂度 T(n)=O(f(n)) T(n)表示代码执行时间; n表示数据规模的大小; f(n)表示每行代码执行的次数总和. 因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比. 大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度 函数的渐近增长1算法A 要做2n+3次操作 算法B要做3n+1次操作 次数 算法A（2n+3） 算法A‘（2n） 算法B（3n+1） 算法B’（3n） n=1 5 2 4 3 n=2 7 4 7 6 n=3 9 6 10 9 n=10 23 20 31 30 n=100 203 200 301 300 12输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。 一秒之内能解决问题的数据规模 数据规模 时间复杂度 1 10 n！ 2 20~30 2^n 3 50 n^4 4 100 n^3 5 1000 n^2 6 10^6 nlogn 7 10^7 n 8 10^9 sqrt(n) 9 10^10 logn 10 无穷大 1 阿里面试题假设给出一个算法的时间复杂度递推关系式：T(n）=T(n-1)+n，T(0)=1；（n为整数）求该算法的时间复杂度","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://cuiyuangeng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","permalink":"https://cuiyuangeng.cn/tags/Linux/"},{"name":"Mybatis框架","slug":"Mybatis框架","permalink":"https://cuiyuangeng.cn/tags/Mybatis%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"https://cuiyuangeng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}