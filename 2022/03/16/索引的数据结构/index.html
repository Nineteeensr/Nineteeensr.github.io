<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="baidu-site-verification" content="code-dlF10hpmks"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>索引的数据结构 | 崔源耕的个人博客</title><meta name="description" content="二、索引的数据结构1. 为什么使用索引索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描 对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即二叉搜索树，二叉搜索树的每个节点存储的是(K,V)结构，key是该字段，value是该key所在行的文件指针（地址"><meta property="og:type" content="article"><meta property="og:title" content="索引的数据结构"><meta property="og:url" content="https://cuiyuangeng.cn/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="二、索引的数据结构1. 为什么使用索引索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描 对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即二叉搜索树，二叉搜索树的每个节点存储的是(K,V)结构，key是该字段，value是该key所在行的文件指针（地址"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317202704784.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317203309169.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319142443944.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319150119906.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319153534036.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319174816454.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319175351088.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320154136216.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320160133477.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320161927231.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320162613758.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320175329092.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320175903317.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320180447767.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320180729812.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320182319384.png"><meta property="article:published_time" content="2022-03-15T16:00:00.000Z"><meta property="article:modified_time" content="2022-03-21T07:06:19.776Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="数据库、MySQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png"><link rel="canonical" href="https://cuiyuangeng.cn/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/nineteeensr" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">崔源耕</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Java后端 &amp; 菜鸟</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">Repository</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/nineteeensr" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/u/6575186617" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">Tags</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis%E6%A1%86%E6%9E%B6/" rel="tag">Mybatis框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81MySQL/" rel="tag">数据库、MySQL</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/Mybatis%E6%A1%86%E6%9E%B6/" style="font-size:13px">Mybatis框架</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81MySQL/" style="font-size:14px">数据库、MySQL</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:13px">设计模式</a></div></div><div class="widget"><h3 class="widget-title">Archive</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">4</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2022/03/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2022/03/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="title">索引的创建和设计原则</a></p><p class="item-date"><time datetime="2022-03-17T16:00:00.000Z" itemprop="datePublished">2022-03-18</time></p></div></li><li><div class="item-thumb"><a href="/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="title">索引的数据结构</a></p><p class="item-date"><time datetime="2022-03-15T16:00:00.000Z" itemprop="datePublished">2022-03-16</time></p></div></li><li><div class="item-thumb"><a href="/2022/03/14/InnoDB%E9%94%81%E7%AE%97%E6%B3%95%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2022/03/14/InnoDB%E9%94%81%E7%AE%97%E6%B3%95%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/" class="title">InnoDB锁算法与锁机制</a></p><p class="item-date"><time datetime="2022-03-13T16:00:00.000Z" itemprop="datePublished">2022-03-14</time></p></div></li><li><div class="item-thumb"><a href="/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="title">Linux简单的开发环境搭建</a></p><p class="item-date"><time datetime="2022-03-06T10:14:00.000Z" itemprop="datePublished">2022-03-06</time></p></div></li><li><div class="item-thumb"><a href="/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/" class="title">Mybatis框架</a></p><p class="item-date"><time datetime="2021-12-11T13:47:08.000Z" itemprop="datePublished">2021-12-11</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-索引的数据结构" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">索引的数据结构</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date"><time datetime="2022-03-15T16:00:00.000Z" itemprop="datePublished">2022-03-16</time> </a></span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81MySQL/" rel="tag">数据库、MySQL</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#comments" class="article-comment-link">Comments</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 9.4k(words)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 32(minutes)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="二、索引的数据结构"><a href="#二、索引的数据结构" class="headerlink" title="二、索引的数据结构"></a>二、索引的数据结构</h1><h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h2><p>索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看<code>查询条件</code>是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code></p><p>对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即<code>二叉搜索树</code>，二叉搜索树的每个节点存储的是<code>(K,V)结构</code>，key是该字段，value是该key所在行的文件指针（地址）。</p><p>目的是为了<code>减少磁盘I/O的次数</code>，加速查询速率</p><h2 id="2-索引的优缺点"><a href="#2-索引的优缺点" class="headerlink" title="2. 索引的优缺点"></a>2. 索引的优缺点</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定相同。同时存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。</p><p>所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。</p><h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>,这也是创建索引最主要的原因。</li><li>通过创建<code>唯一索引</code>，可以保证数据库表中每一行数据的<code>唯一性</code>。</li><li>在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。</li></ol><p>​ <code>即对于有依赖关系的子表和父表联合查询时</code>，可以提高查询速度。</p><ol start="4"><li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的功耗。</li></ol><h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><ol><li>创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占用 <code>磁盘空间</code>，除了数据表占数据空间，每个索引还要占一定的物理空间，<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增删改，索引也需要动态地维护</li></ol><p>因此，选择使用索引时，要综合考虑索引的优点和缺点。</p><blockquote><p>提示：</p><p>索引可以提高查询的速度，但会影响插入记录的速度。这种情况，最好的办法是 先删除表中的索引，然后插入数据，插入完成后再创建索引</p></blockquote><h2 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3. InnoDB中索引的推演"></a>3. InnoDB中索引的推演</h2><h3 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h3><p>先来看一个精确匹配的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure><h4 id="1-在单页中查找"><a href="#1-在单页中查找" class="headerlink" title="1.在单页中查找"></a>1.在单页中查找</h4><blockquote><p>存储数据的基本单位：数据页。一个数据页的默认大小为:<code>16 KB</code></p></blockquote><ul><li>以主键为搜索条件</li></ul><p>​ 可以在页目录中使用 <code>二分法</code>快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录</p><ul><li>以其他列作为搜索条件</li></ul><p>​ 因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位。这种情况下只能从<code>最小记录</code>开始<code>依次遍历</code>单链表中的每条记录，然后对比。</p><h4 id="2-在很多页中查找"><a href="#2-在很多页中查找" class="headerlink" title="2.在很多页中查找"></a>2.在很多页中查找</h4><p>在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页</li><li>从所在的页内中查找相应的记录</li></ol><p>在没有索引的情况下，无论是根据主键列或其他列进行查找，只能从<code>第一个页</code>沿着<code>双向链表</code>一直往下找。</p><h3 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h3><h4 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h4><p>建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">	c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">INT</span>,</span><br><span class="line">    c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png" alt="行格式01"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录,<code>2</code>表示最小记录、<code>3</code>表示最大记录</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁</li><li><code>各个列的值</code>：这里只记录在index_demo表中的三个列，分别是<code>c1</code>、<code>c2</code>、<code>c3</code></li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>把一些记录放到页里的示意图就是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317202704784.png" alt="image-20220317202704784"></p><ul><li><h4 id="给所有的页建立一个目录项"><a href="#给所有的页建立一个目录项" class="headerlink" title="给所有的页建立一个目录项"></a>给所有的页建立一个目录项</h4></li></ul><p>由于数据页的<code>编号可能是不连续的</code>，所以在向index_demo表中插入许多记录后，可能是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317203309169.png" alt="image-20220317203309169"></p><p>因为这些<code>16KB</code>的页在物理存储上是<code>不连续</code>的，所以如果想从这么多页种根据主键值<code>快速定位某些记录所在的页</code>，我们需要给它们做个<code>目录</code>，每页对应一个目录项，每个目录项包括下边两个部分：</p><ul><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示</li><li>页号，我们用<code>page_no</code>表示</li></ul><p>所以我们为上边几个页做好的目录就像这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319142443944.png" alt="image-20220319142443944"></p><p>我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录：</p><ol><li>先从目录项中根据<code>二分法</code>快速确定出主键值<code>20</code>的记录在<code>目录项3</code>中，它对应的页为<code>页9</code></li><li>再根据<code>二分法</code>查找记录的方式去<code>页9</code>中定位具体的记录</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录我们可以称为<code>索引</code></p><h4 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h4><h5 id="①迭代1次：目录项记录的页"><a href="#①迭代1次：目录项记录的页" class="headerlink" title="①迭代1次：目录项记录的页"></a>①迭代1次：目录项记录的页</h5><p>设计的简易索引方案，是因为我们为了在根据主键值进行查找时，使用<code>二分法</code>快速定位具体的目录项而假设所有目录项都可以在物理存储器上<code>连续存储</code>,但是这样做有几个问题：</p><ul><li>InnoDB时使用页作为管理存储空间的基本单位，最多保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要<code>非常大的连续的存储空间</code>才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们经常会对<code>记录进行增删</code>，假设我们把<code>页28</code>中的记录都删除了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样导致了操作效率很差。</li></ul><p>所以，我们需要一种可以<code>灵活管理所有目录项</code>的方式。我们发现目录项其实长的跟我们用户记录差不多，只不过目录项中的两个列是<code>主键</code>和<code>页号</code>而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。InnoDB如何区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>么？使用记录头信息的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>1</code>：目录项记录</li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>把使用的目录项放到数据页中的样子就是这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319150119906.png" alt="image-20220319150119906"></p><p>从图中可以看出来，我们分配了一个编号为30的页来专门存储目录项记录。</p><p><code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都为0</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时，可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两部：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以</li></ol><h5 id="②迭代2次：多个目录项记录的页"><a href="#②迭代2次：多个目录项记录的页" class="headerlink" title="②迭代2次：多个目录项记录的页"></a>②迭代2次：多个目录项记录的页</h5><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号,比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多,以至于一个数据页不足以存放所有的<code>目录项记录</code>，如何处理呢？</p><p>这里我们假设一个存储目录项记录的页<code>最多只能存放4条目录项记录</code>,所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页:</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319153534036.png" alt="image-20220319153534036"></p><h5 id="③迭代3次：目录项记录页的目录页"><a href="#③迭代3次：目录项记录页的目录页" class="headerlink" title="③迭代3次：目录项记录页的目录页"></a>③迭代3次：目录项记录页的目录页</h5><p>在第二次迭代的查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些<code>页是不连续的</code>，如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像一个多级目录，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319174816454.png" alt="image-20220319174816454"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间,则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319175351088.png" alt="image-20220319175351088"></p><p>这个数据结构，就是<code>B+树</code></p><h5 id="④B-Tree"><a href="#④B-Tree" class="headerlink" title="④B+Tree"></a>④B+Tree</h5><p>无论是存放<code>用户记录</code>的数据页，还是存放<code>目录项记录</code>的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出，我们的实际用户记录其实都存放在B+树的<code>最底层</code>的节点上，即<code>叶子节点</code>,B+树最上边的节点称为<code>根节点</code>.</p><blockquote><p>用户记录存放在B+树的叶子节点上，每一个叶子节点中的<code>每一行数据通过单向链表</code>的方式存储，而<code>叶子节点之间是双向链表</code>。</p><p><strong>树的层次越低，IO次数越少</strong></p></blockquote><p>一般情况下，我们用到的<code>B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找三个目录项页和一个用户记录页），又因为在每个页面内又所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法来实现快速定位记录。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>叶子节点</code>：存储实际数据记录，其中又<code>record_type=2</code>标记<strong>最小主键值</strong>,<code>record_type=3</code>标记<strong>最大主键值</strong></p><p><code>内节点</code>：存储每一个数据页的<code>页码</code>以及每一页<code>record_type=2</code>的最小主键值，即数据的目录页，<code>record_type=1</code></p><p><code>根节点或第二层节点</code>：存储的是目录页的记录，<code>每一个目录页的最小主键值</code>以及<code>目录页的页码</code></p><h3 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为<code>二级索引</code>或<code>辅助索引</code></p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子节点），也就是所谓的<code>索引即数据，数据即索引</code>。</p><blockquote><p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p></blockquote><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><code>数据页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</li><li>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>我们把具有这两种特性的B+树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<code>INDEX</code>语句去创建，InnoDB存储引擎会<code>自动</code>的为我们创建聚簇索引.</p><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树种，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的IO操作</code></li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列作为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><p><strong>限制：</strong></p><ul><li>对于MySQL数据库目前著有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个MySQL的<code>表只能有一个聚簇索引</code>。一般情况就是该表的主键。</li><li>如果没有定义主键，InnoDB会选择<code>非空的唯一索引</code>代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量<code>选用有序的顺序id</code>，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul><h4 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h4><p><code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为B+树的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？</p><p>我们可以<code>多建几棵B+树</code>，不同的B+树种的数据采用不同的排序规则。比如我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如图：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320154136216.png" alt="image-20220320154136216"></p><p><strong>概念：回表</strong></p><p>我们根据以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一边，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树。</p><p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>（<code>secondary index</code>）,或者<code>辅助索引</code>。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。</p><p>非聚簇索引的存在不影响数据再聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p><p><strong>小结：</strong></p><ol><li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>，非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li><li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li><li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li></ol><h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引"></a>3. 联合索引</h4><p>我们也可以同时以多列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p>为c2和c3列建立的索引的示意图如下：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320160133477.png" alt="image-20220320160133477"></p><p>如图：</p><ul><li>每条<code>目录项记录</code>由<code>c2、c3、页号</code>这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。</li><li>B+树<code>叶子节点</code>处的用户记录由<code>c2、c3和主键c1列</code>组成。</li></ul><p>以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列建立索引的表述是不同的，不同点：</p><ul><li>建立<code>联合索引</code>只会建立如上图一样的<code>1棵</code>B+树。</li><li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立<code>2棵</code>B+树</li></ul><h3 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h3><h4 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h4><p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:</p><ul><li>每当为某个表创建一个B+树索引 (聚簇索引不是人为创建的，默认就有)的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><blockquote><p>这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p></blockquote><h4 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h4><p>B+树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是对于二级索引来说不严谨。以<code>index_demo</code>表为例，假设表中的数据是：</p><table><thead><tr><th><code>c1</code></th><th><code>c2</code></th><th><code>c3</code></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320161927231.png" alt="image-20220320161927231"></p><p>如果此时我们插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别为：<code>9</code>、<code>1</code>、<code>&#39;c&#39;</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便遇到了问题：</p><p>由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都为<code>1</code>，而我们<code>新插入的这条记录</code>的c2列的值也是<code>1</code>，那此时我们应该插入到<code>页4</code>中还是<code>页5</code>中呢？</p><p>为了让新插入记录能找到自己的位置，我们需要<strong>保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>这样就保证了B+树每一层节点中各条目录项记录除页号以外是<code>唯一的</code>所以我们为c2列建立二级索引后的示意图应该是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320162613758.png" alt="image-20220320162613758"></p><h4 id="3-一个页面最少存储2条记录"><a href="#3-一个页面最少存储2条记录" class="headerlink" title="3. 一个页面最少存储2条记录"></a>3. 一个页面最少存储2条记录</h4><h2 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h2><p><strong>B树索引使用存储引擎：</strong></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>InnoDB和MyISAM默认的索引是BTree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却<code>将索引和数据分开存储</code>：</p><ul><li>将表中的记录<code>按照记录的插入顺序</code>单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录。由于在插入数据的时候并<code>没有刻意按照主键大小排序</code>，所以我们并不能在这些数据上使用二分法进行查找。</li><li>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过索引的叶子节点存储的不是完整的用户记录，而是<code>主键值 + 数据记录的地址</code>。</li></ul><h2 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h2><ul><li><p><strong>空间上的代价</strong></p><p>每建立一个索引都要为它建立一颗B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一篇存储空间。</p></li><li><p><strong>时间上的代价</strong></p><p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树的索引。而且，B+树每层节点都是按照索引列的值<code>从小到大的顺序</code>而组成了<code>双向链表</code>。无论是叶子节点中的记录，还是内节点的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。</p></li></ul><blockquote><p>一个表上的索引创建的越多，就会占用越多的空间，增删改的性能越差。</p></blockquote><h2 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6. MySQL数据结构选择的合理性"></a>6. MySQL数据结构选择的合理性</h2><p>从MySQL的角度讲，不得不考虑的现实问题就是<code>磁盘IO</code>。如果我们能让索引的数据结构尽量减少磁盘的I/O操作，所消耗的时间也就越小。<code>磁盘的 I/O 操作次数</code>对索引的使用效率至关重要。</p><p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引时存储在外部磁盘上的。</strong>当我们利用索引查询的时候，只能<code>逐一加载</code>索引到内存中，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p><h3 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h3><p>性能极差！</p><h3 id="6-2-Hash结构"><a href="#6-2-Hash结构" class="headerlink" title="6.2 Hash结构"></a>6.2 Hash结构</h3><p>Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p><p>Hash算法时通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。<code>相同的输入永远可以得到相同的输出</code>。</p><p><strong>提升查询效率的数据结构，常见的有两类：</strong></p><ol><li>树，例如 <code>平衡二叉搜索树</code>，查询/插入/修改/删除的平均时间复杂度都是<code>O(log2N)</code>；</li><li>哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是<code>O(1)</code>;</li></ol><p>采用Hash进行检索效率非常高，基本一次检索就可以找到数据，而B+树需要自顶向下一次查找，多次访问节点才能找到数据，中间需要多次I/O操作，从效率来说<code>Hash 比 B+ 树更快</code></p><p><strong>Hash结构效率高，为什么索引结构要设计成树？</strong></p><ol><li>Hash索引仅能满足 <code>=</code> 、<code>!=</code> 和 <code>IN</code>查询。如果进行<code>范围查询</code>，哈希索引，时间复杂度会退化为<code>O(n)</code>；而<code>树</code>的有序特性，依然能够保持<code>O(log2N)</code>的高效。</li><li>Hash索引，数据存储是<code>无序的</code>,在<code>ORDER BY</code>的情况下，使用Hash索引还需要对数据重新排序。</li><li>对于联合索引的情况，Hash值是将联合索引键合并后一起计算的，无法对单独的一个键或者几个索引键进行查询。</li><li>对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<code>索引列的重复值如果很多。效率就会降低</code>。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如性别、年龄。</li></ol><p><strong>Hash索引使用存储引擎：</strong></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td><code>支持</code></td></tr></tbody></table><p><strong>Hash索引的适用性：</strong></p><p>MySQL中的Memory 存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<code>等值查询</code>的时候，可以采用Hash索引。</p><p>InnoDB本身不支持Hash索引，但是提供<code>自适应 Hash 索引</code>(Adaptive Hash Index)。</p><p>如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样就让B+树也具备了Hash索引的优点。</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320175329092.png" alt="image-20220320175329092"></p><p>采用自适应Hash索引目的是方便根据SQL的查询条件加速定位到叶子节点，特别是当B+树比较深的时候，通过自适应Hash索引可以明显提高数据的检索效率。</p><p>我们可以通过<code>innodb_adaptive_hash_index</code>变量来查看是否开启了自适应Hash，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Redis 存储的核心就是 Hash 表</p></blockquote><h3 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p>二叉树的一般情况的查找就不赘述了。</p><p><strong>极端情况：</strong></p><p>有时二叉树的深度非常大。比如我们给出的数据顺序是（5，22，23，34，77，89，91），此时二叉树就是这样的：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320175903317.png" alt="image-20220320175903317"></p><p>上面的树也属于二叉树，但是性能上退化为了链表，查找数据的时间复杂度变成了<code>O(n)</code>。</p><p>那么为了提高查询效率，就需要<code>减少磁盘IO次数</code>。为了减少磁盘IO次数，就需要尽量<code>降低树的高度</code>，将原来瘦高的树结构变成矮胖，树的每层的分叉越多越好。</p><h3 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h3><p>为了解决二叉树退化成链表的问题，我们就提出了<code>平衡二叉搜索树(Balanced Binary Tree)</code>，又称为<code>AVL树</code>，它在二叉搜索树的基础上增加了约束，具有以下性质：</p><p><strong>它是一棵空树或它的左右两个字数的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</strong>。</p><p>常见的平衡二叉树有很多种，包括了<code>平衡二叉搜索树</code>、<code>红黑树</code>、<code>数堆</code>、<code>伸展树</code>。</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320180447767.png" alt="image-20220320180447767"></p><p><code>每访问一次节点就需要进行一次磁盘 I/O 操作</code>，对于上面的树来说，我们需要进行5次I/O操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。</p><h3 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h3><p>B树（Balance Tree），也就是<code>多路平衡二叉树</code>。简写为B-Tree。它的高度远小于平衡二叉树的高度。</p><p>B树的结构如下图：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320180729812.png" alt="image-20220320180729812"></p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<code>M 称为 B 树的阶</code>。每个磁盘块中包括了<code>关键字</code>和<code>子节点的指针</code>。如果一个磁盘块中包含了 x 个关键字，那么指针数就是 x+1。对于一个100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的。</p><p>一个M阶的B树（M &gt; 2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2 , M).</li><li>每个中间节点包含k-1个关键字和k个孩子，孩子的数量 = 关键字的数量 + 1，k的取值范围为[ceil (M / 2), M]。</li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k的取值范围为[ceil (M / 2), M]。</li><li>假设中间节点，节点的关键字为：Key[1],Key[2],…,Key[k - 1],且关键字按照升序排序，即 Key[ i ]&lt;Key[i + 1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k],其中P[1]指向关键字小于Key[1]的子树。P[i]指向关键字属于（Key[i - 1],Key[i]）的子树，P[k]指向关键字大于 Key[k - 1]的子树。</li><li>所有叶子节点位于同一层。</li></ol><p><strong>小结：</strong></p><ol><li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ol><p>举例：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320182319384.png" alt="image-20220320182319384"></p><h3 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h3><p>B+树也是一种多路搜索树，<code>基于 B 树做出了改进</code>，主流的DBMS都支持 B+树的索引方式，比如 MySQL。相比于B-Tree，<code>B+Tree适合文件索引系统</code>。</p><p><strong>B+树和B树的差异：</strong></p><ol><li>有k个孩子的节点就有k个关键字。也就是孩子数量 = 关键字数，而 B树种，孩子数量 = 关键字数 + 1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子结点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，<code>非叶子节点既保存索引，也保存数据记录</code>。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到达顺序链接。</li></ol><p>B+ 树和 B 树有个根本的差异在于，<strong>B+ 树的中间节点并不直接存储数据。</strong>这样的好处都有什么呢？</p><ol><li><strong>B+树的查询效率更稳定</strong></li><li><strong>B+树的查询效率更高</strong>，这是因为通常B+ 树比B 树<code>更矮胖</code>（阶数更大，深度更低），查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</li></ol><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高。</strong>这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的。而在B树种则需要通过<code>中序遍历</code>才能完成查询范围的查找，效率要低很多。</p><blockquote><p>B树和B+树都可以作为索引的数据结构，在MySQL中采用的是B+树。</p><p>但B树和B+树各有自己的应用场景。</p></blockquote><p><strong>B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/（8B+8B）=1K个键值（因为是估值，方便计算，K的取值为10^3），也就是说一个深度为 3 的B+Tree索引可以维护 10 ^ 3 * 10 ^ 3 * 10 ^ 3 = 10 亿条记录。这里假定一个数据也也存储10 ^ 3条行记录</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在 2~4 层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时，最多只需要1~3次磁盘IO操作。</p></blockquote><p><strong>Hash 索引与 B+树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。因为Hash索引指向的数据是无序的，而B+树的叶子节点是一个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左前缀法则</code>（即联合索引的部分索引无法使用）。</p><p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，无法起到排序优化的作用。同理我们也无法使用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（%结尾）的话就可以起到优化作用</p><p>4、InnoDB不支持Hash索引</p></blockquote><h3 id="6-7-R树"><a href="#6-7-R树" class="headerlink" title="6.7 R树"></a>6.7 R树</h3><p>R-Tree在MySQL中很少使用，仅支持<code>geometry数据类型</code>。R树很好的解决了<code>高维空间搜索问题</code>。地图的搜索，20公里内所有的餐厅。</p><p>R树就是一棵用来<code>存储高维数据的平衡树</code>。</p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>R-Tree索引</td><td>支持</td><td>支持</td><td><code>不支持</code></td></tr></tbody></table></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://cuiyuangeng.cn/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="索引的数据结构" target="_blank" rel="external">https://cuiyuangeng.cn/2022/03/16/索引的数据结构/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/nineteeensr" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/nineteeensr" target="_blank"><span class="text-dark">崔源耕</span><small class="ml-1x">Java后端 &amp; 菜鸟</small></a></h3><div>失败不是悲剧，放弃才是</div></div></figure></div></div></div></article><section id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC81NTc4OS8zMjI1NQ=="><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2022/03/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="索引的创建和设计原则"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a></li><li class="next"><a href="/2022/03/14/InnoDB%E9%94%81%E7%AE%97%E6%B3%95%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/" title="InnoDB锁算法与锁机制"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/nineteeensr" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/u/6575186617" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer type="text/javascript">!function(e,t){var n=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((e=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",e.async=!0,n.parentNode.insertBefore(e,n))}(document,"script")</script></body></html>