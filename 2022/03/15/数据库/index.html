<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>数据库（未完成） | 崔源耕的个人博客</title><meta name="description" content="一、常用的两种存储引擎MyISAM与InnoDB 是否支持行级锁  MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。  是否支持事务  MyISAM不提供事务支持，InnoDB提供事务支持，具有提交（commit）和回滚（rollback）的事务能力。  是否支持外键  MyISAM不支持外键，InnoDB支持外键  是否支持数据库异常崩溃后的安全恢复  MyISAM不支持"><meta property="og:type" content="article"><meta property="og:title" content="数据库（未完成）"><meta property="og:url" content="http://example.com/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="一、常用的两种存储引擎MyISAM与InnoDB 是否支持行级锁  MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。  是否支持事务  MyISAM不提供事务支持，InnoDB提供事务支持，具有提交（commit）和回滚（rollback）的事务能力。  是否支持外键  MyISAM不支持外键，InnoDB支持外键  是否支持数据库异常崩溃后的安全恢复  MyISAM不支持"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317202704784.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317203309169.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319142443944.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319150119906.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319153534036.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319174816454.png"><meta property="og:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319175351088.png"><meta property="article:published_time" content="2022-03-15T13:43:03.000Z"><meta property="article:modified_time" content="2022-03-19T13:45:22.537Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="数据库"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png"><link rel="canonical" href="http://example.com/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/index.html"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/nineteeensr" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">崔源耕</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Java后端 &amp; 菜鸟</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">Repository</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/nineteeensr" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/u/6575186617" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">Tags</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis%E6%A1%86%E6%9E%B6/" rel="tag">Mybatis框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/Mybatis%E6%A1%86%E6%9E%B6/" style="font-size:13px">Mybatis框架</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size:13px">数据库</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:13px">设计模式</a></div></div><div class="widget"><h3 class="widget-title">Archive</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">4</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="title">数据库（未完成）</a></p><p class="item-date"><time datetime="2022-03-15T13:43:03.000Z" itemprop="datePublished">2022-03-15</time></p></div></li><li><div class="item-thumb"><a href="/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="title">Linux简单的开发环境搭建</a></p><p class="item-date"><time datetime="2022-03-06T10:14:00.000Z" itemprop="datePublished">2022-03-06</time></p></div></li><li><div class="item-thumb"><a href="/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/" class="title">Mybatis框架</a></p><p class="item-date"><time datetime="2021-12-11T13:47:08.000Z" itemprop="datePublished">2021-12-11</time></p></div></li><li><div class="item-thumb"><a href="/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="title">数据结构</a></p><p class="item-date"><time datetime="2021-12-11T13:44:05.000Z" itemprop="datePublished">2021-12-11</time></p></div></li><li><div class="item-thumb"><a href="/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/" class="title">设计模式（未完成）</a></p><p class="item-date"><time datetime="2021-12-11T13:43:03.000Z" itemprop="datePublished">2021-12-11</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-数据库" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">数据库（未完成）</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date"><time datetime="2022-03-15T13:43:03.000Z" itemprop="datePublished">2022-03-15</time> </a></span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/#comments" class="article-comment-link">Comments</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 7.3k(words)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 27(minutes)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="一、常用的两种存储引擎"><a href="#一、常用的两种存储引擎" class="headerlink" title="一、常用的两种存储引擎"></a>一、常用的两种存储引擎</h1><h2 id="MyISAM与InnoDB"><a href="#MyISAM与InnoDB" class="headerlink" title="MyISAM与InnoDB"></a>MyISAM与InnoDB</h2><ol><li>是否支持行级锁</li></ol><p>MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。</p><ol start="2"><li>是否支持事务</li></ol><p>MyISAM不提供事务支持，InnoDB提供事务支持，具有提交（commit）和回滚（rollback）的事务能力。</p><ol start="3"><li>是否支持外键</li></ol><p>MyISAM不支持外键，InnoDB支持外键</p><ol start="4"><li>是否支持数据库异常崩溃后的安全恢复</li></ol><p>MyISAM不支持，InnoDB支持。</p><p>使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log。</p><blockquote><p>InnoDB 使用redo log（重做日志）保证事务的持久性，使用undo log（回滚日志）来保证事务的原子性。</p><p>通过 锁机制，MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEATABLE-READ）</p><p>保证了事务的持久性，原子性，隔离性之后，一致性才能得到保障</p></blockquote><h2 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h2><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁。</li><li>InnoDB支持行级锁和表级锁默认为行级锁。</li></ul><p>表级锁和行级锁对比：</p><ul><li>表级锁：MySQL中锁定<strong>粒度最大</strong>的一种锁，对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。</li><li>行级锁：MySQL中锁定<strong>粒度最小</strong>的一种锁，对当前操作的行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p>InnoDB支持三种行锁定：</p><ul><li>行锁（Record Lock）：锁直接加在索引记录上面，锁住的是key。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而设计的。</li><li>后码锁（Next-Key Lock）：行锁和间隙锁组合起来就叫Next-Key Lock。</li></ul><p>默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><h3 id="行锁（Record-Lock）"><a href="#行锁（Record-Lock）" class="headerlink" title="行锁（Record Lock）"></a>行锁（Record Lock）</h3><ul><li>当需要对表中的某条数据进行写操作（insert，update，delete，select for update）时，需要先获取记录的排他锁（X锁），这个就称为行锁。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> x(`id` <span class="type">int</span>, `num` <span class="type">int</span>, index `idx_id` (`id`));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> x <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="comment">-- 如果事务A没有commit，id=1的记录拿不到X锁，将出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务C</span></span><br><span class="line"><span class="comment">-- id=2的记录可以拿到X锁，不会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>针对InnoDB RR隔离级别，行锁的特点：“锁定特定行不允许进行修改”，但<strong>行锁是基于表索引的</strong>，如果where条件中用的是num字段（非索引列）将产生不一样的现象：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="comment">-- 由于事务A中num字段上没有索引将产生表锁，导致整张表的写操作都会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务C</span></span><br><span class="line"><span class="comment">-- 同理，会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务D</span></span><br><span class="line"><span class="comment">-- 等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> x <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="Gap锁（Gap-Lock）"><a href="#Gap锁（Gap-Lock）" class="headerlink" title="Gap锁（Gap Lock）"></a>Gap锁（Gap Lock）</h3><p>在MySQL中select称为快照读，不需要锁，而insert、update、delete、select for update则称为当前读，需要给数据加锁，幻读中的“读”即是针对当前读。</p><p>RR事务隔离级别允许存在幻读，但InnoDB RR级别却通过Gap锁避免了幻读</p><p><strong>产生间隙锁的条件（RR事务隔离级别下）</strong></p><ul><li>使用普通索引锁定</li><li>使用多列唯一索引</li><li>使用唯一索引锁定多行记录</li></ul><p><strong>唯一索引的间隙锁</strong></p><p>数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="只使用记录锁，不会产生间隙锁"><a href="#只使用记录锁，不会产生间隙锁" class="headerlink" title="只使用记录锁，不会产生间隙锁"></a>只使用记录锁，不会产生间隙锁</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小张&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>以上，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以，只会对id=5的数据加上记录锁，而不会产生间隙锁。</p><h5 id="产生间隙锁"><a href="#产生间隙锁" class="headerlink" title="产生间隙锁"></a>产生间隙锁</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id 在 7 - 11 范围的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">7</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h5 id="锁住不存在的数据"><a href="#锁住不存在的数据" class="headerlink" title="锁住不存在的数据"></a>锁住不存在的数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 3 这一条不存在的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;小张1&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁</p><p>结论</p><ul><li>对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：WHERE <code>id</code> = 5 FOR UPDATE;</li><li>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE <code>id</code> BETWEEN 5 AND 7 FOR UPDATE;</li></ul><h5 id="普通索引的间隙锁"><a href="#普通索引的间隙锁" class="headerlink" title="普通索引的间隙锁"></a>普通索引的间隙锁</h5><p>数据准备</p><p>创建test1表：</p><ul><li>number 不是唯一值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `number` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `number` (`number`) <span class="keyword">USING</span> BTREE </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>id 是主键，number上建立了一个普通索引。先加一些数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>test1表中 number 索引存在的隐藏间隙：</p><p>(-infinity, 1]<br>(1, 3]<br>(3, 8]<br>(8, 12]<br>(12, +infinity]</p><h5 id="执行以下的事务（事务1最后提交"><a href="#执行以下的事务（事务1最后提交" class="headerlink" title="执行以下的事务（事务1最后提交)"></a>执行以下的事务（事务1最后提交)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 number = 0 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">0</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">1</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">2</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 number = 4 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">4</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">8</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">9</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 number = 10 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">10</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务1插入一条 id = 2， number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3， number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 6， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">8</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 8， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="number">8</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 9， number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="number">9</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 10， number = 12 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">12</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7修改 id = 11， number = 12 的数据 */</span></span><br><span class="line">UPDATE `test1` <span class="keyword">SET</span> `number` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">11</span> <span class="keyword">AND</span> `number` <span class="operator">=</span> <span class="number">12</span>; <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这里有一个奇怪的现象：</p><p>事务3添加 id = 6，number = 8 的数据，给阻塞了；<br>事务4添加 id = 8，number = 8 的数据，正常执行了。<br>事务7将 id = 11，number = 12 的数据修改为 id = 11， number = 5的操作，给阻塞了；</p><p>当 number 相同时，会根据主键 id 来排序，所以：</p><p>事务3添加的 id = 6，number = 8，这条数据是在 （3, 8） 的区间里边，所以会被阻塞；<br>事务4添加的 id = 8，number = 8，这条数据则是在（8, 12）区间里边，所以不会被阻塞；<br>事务7的修改语句相当于在 （3, 8） 的区间里边插入一条数据，所以也被阻塞了。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样</li><li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序</li></ul><h4 id="后码锁（Next-key-Lock）"><a href="#后码锁（Next-key-Lock）" class="headerlink" title="后码锁（Next-key Lock）"></a>后码锁（Next-key Lock）</h4><p>后码锁是记录锁与间隙锁的组合，也是为了避免幻读。如果把事务的隔离级别降级为RC，Next-key Lock 则也会失效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>记录锁、间隙锁、后码锁，都属于排它锁；</li><li>记录锁就是锁住一行记录；</li><li>间隙锁只有在事务级别RR中才会产生；</li><li>唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁；</li><li>普通索引不管是锁住单条，还是多条记录，都会产生间隙锁；</li><li>间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其他事务在这个区域插入、修改、删除数据，这是为了防止出现幻读现象；</li><li>普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序；</li><li>事务级别RC（读已提交）级别的话。间隙锁将会失效。</li></ul><h1 id="二、索引的数据结构"><a href="#二、索引的数据结构" class="headerlink" title="二、索引的数据结构"></a>二、索引的数据结构</h1><h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h2><p>索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看<code>查询条件</code>是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code></p><p>对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即<code>二叉搜索树</code>，二叉搜索树的每个节点存储的是<code>(K,V)结构</code>，key是该字段，value是该key所在行的文件指针（地址）。</p><p>目的是为了<code>减少磁盘I/O的次数</code>，加速查询速率</p><h2 id="2-索引的优缺点"><a href="#2-索引的优缺点" class="headerlink" title="2. 索引的优缺点"></a>2. 索引的优缺点</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定相同。同时存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。</p><p>所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。</p><h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>,这也是创建索引最主要的原因。</li><li>通过创建<code>唯一索引</code>，可以保证数据库表中每一行数据的<code>唯一性</code>。</li><li>在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。</li></ol><p>​ <code>即对于有依赖关系的子表和父表联合查询时</code>，可以提高查询速度。</p><ol start="4"><li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的功耗。</li></ol><h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><ol><li>创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占用 <code>磁盘空间</code>，除了数据表占数据空间，每个索引还要占一定的物理空间，<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增删改，索引也需要动态地维护</li></ol><p>因此，选择使用索引时，要综合考虑索引的优点和缺点。</p><blockquote><p>提示：</p><p>索引可以提高查询的速度，但会影响插入记录的速度。这种情况，最好的办法是 先删除表中的索引，然后插入数据，插入完成后再创建索引</p></blockquote><h2 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3.InnoDB中索引的推演"></a>3.InnoDB中索引的推演</h2><h3 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h3><p>先来看一个精确匹配的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure><h4 id="1-在单页中查找"><a href="#1-在单页中查找" class="headerlink" title="1.在单页中查找"></a>1.在单页中查找</h4><blockquote><p>存储数据的基本单位：数据页。一个数据页的默认大小为:<code>16 KB</code></p></blockquote><ul><li>以主键为搜索条件</li></ul><p>​ 可以在页目录中使用 <code>二分法</code>快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录</p><ul><li>以其他列作为搜索条件</li></ul><p>​ 因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位。这种情况下只能从<code>最小记录</code>开始<code>依次遍历</code>单链表中的每条记录，然后对比。</p><h4 id="2-在很多页中查找"><a href="#2-在很多页中查找" class="headerlink" title="2.在很多页中查找"></a>2.在很多页中查找</h4><p>在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页</li><li>从所在的页内中查找相应的记录</li></ol><p>在没有索引的情况下，无论是根据主键列或其他列进行查找，只能从<code>第一个页</code>沿着<code>双向链表</code>一直往下找。</p><h3 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h3><h4 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h4><p>建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">	c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">INT</span>,</span><br><span class="line">    c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png" alt="行格式01"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录,<code>2</code>表示最小记录、<code>3</code>表示最大记录</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁</li><li><code>各个列的值</code>：这里只记录在index_demo表中的三个列，分别是<code>c1</code>、<code>c2</code>、<code>c3</code></li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>把一些记录放到页里的示意图就是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317202704784.png" alt="image-20220317202704784"></p><ul><li><h4 id="给所有的页建立一个目录项"><a href="#给所有的页建立一个目录项" class="headerlink" title="给所有的页建立一个目录项"></a>给所有的页建立一个目录项</h4></li></ul><p>由于数据页的<code>编号可能是不连续的</code>，所以在向index_demo表中插入许多记录后，可能是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317203309169.png" alt="image-20220317203309169"></p><p>因为这些<code>16KB</code>的页在物理存储上是<code>不连续</code>的，所以如果想从这么多页种根据主键值<code>快速定位某些记录所在的页</code>，我们需要给它们做个<code>目录</code>，每页对应一个目录项，每个目录项包括下边两个部分：</p><ul><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示</li><li>页号，我们用<code>page_no</code>表示</li></ul><p>所以我们为上边几个页做好的目录就像这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319142443944.png" alt="image-20220319142443944"></p><p>我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录：</p><ol><li>先从目录项中根据<code>二分法</code>快速确定出主键值<code>20</code>的记录在<code>目录项3</code>中，它对应的页为<code>页9</code></li><li>再根据<code>二分法</code>查找记录的方式去<code>页9</code>中定位具体的记录</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录我们可以称为<code>索引</code></p><h4 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h4><h5 id="①迭代1次：目录项记录的页"><a href="#①迭代1次：目录项记录的页" class="headerlink" title="①迭代1次：目录项记录的页"></a>①迭代1次：目录项记录的页</h5><p>设计的简易索引方案，是因为我们为了在根据主键值进行查找时，使用<code>二分法</code>快速定位具体的目录项而假设所有目录项都可以在物理存储器上<code>连续存储</code>,但是这样做有几个问题：</p><ul><li>InnoDB时使用页作为管理存储空间的基本单位，最多保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要<code>非常大的连续的存储空间</code>才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们经常会对<code>记录进行增删</code>，假设我们把<code>页28</code>中的记录都删除了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样导致了操作效率很差。</li></ul><p>所以，我们需要一种可以<code>灵活管理所有目录项</code>的方式。我们发现目录项其实长的跟我们用户记录差不多，只不过目录项中的两个列是<code>主键</code>和<code>页号</code>而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。InnoDB如何区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>么？使用记录头信息的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>1</code>：目录项记录</li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>把使用的目录项放到数据页中的样子就是这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319150119906.png" alt="image-20220319150119906"></p><p>从图中可以看出来，我们分配了一个编号为30的页来专门存储目录项记录。</p><p><code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都为0</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时，可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两部：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以</li></ol><h5 id="②迭代2次：多个目录项记录的页"><a href="#②迭代2次：多个目录项记录的页" class="headerlink" title="②迭代2次：多个目录项记录的页"></a>②迭代2次：多个目录项记录的页</h5><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号,比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多,以至于一个数据页不足以存放所有的<code>目录项记录</code>，如何处理呢？</p><p>这里我们假设一个存储目录项记录的页<code>最多只能存放4条目录项记录</code>,所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页:</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319153534036.png" alt="image-20220319153534036"></p><h5 id="③迭代3次：目录项记录页的目录页"><a href="#③迭代3次：目录项记录页的目录页" class="headerlink" title="③迭代3次：目录项记录页的目录页"></a>③迭代3次：目录项记录页的目录页</h5><p>在第二次迭代的查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些<code>页是不连续的</code>，如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像一个多级目录，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319174816454.png" alt="image-20220319174816454"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间,则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319175351088.png" alt="image-20220319175351088"></p><p>这个数据结构，就是<code>B+树</code></p><h5 id="④B-Tree"><a href="#④B-Tree" class="headerlink" title="④B+Tree"></a>④B+Tree</h5><p>无论是存放<code>用户记录</code>的数据页，还是存放<code>目录项记录</code>的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出，我们的实际用户记录其实都存放在B+树的<code>最底层</code>的节点上，即<code>叶子节点</code>,B+树最上边的节点称为<code>根节点</code>.</p><blockquote><p>用户记录存放在B+树的叶子节点上，每一个叶子节点中的<code>每一行数据通过单向链表</code>的方式存储，而<code>叶子节点之间是双向链表</code>。</p><p><strong>树的层次越低，IO次数越少</strong></p></blockquote><p>一般情况下，我们用到的<code>B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找三个目录项页和一个用户记录页），又因为在每个页面内又所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法来实现快速定位记录。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>叶子节点</code>：存储实际数据记录，其中又<code>record_type=2</code>标记<strong>最小主键值</strong>,<code>record_type=3</code>标记<strong>最大主键值</strong></p><p><code>内节点</code>：存储每一个数据页的<code>页码</code>以及每一页<code>record_type=2</code>的最小主键值，即数据的目录页</p><p><code>根节点或第二层节点</code>：存储的是目录页的记录，<code>每一个目录页的最小主键值</code>以及<code>目录页的页码</code></p><h3 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为<code>二级索引</code>或<code>辅助索引</code></p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子节点），也就是所谓的<code>索引即数据，数据即索引</code>。</p><blockquote><p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p></blockquote><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</li><li>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>我们把具有这两种特性的B+树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<code>INDEX</code>语句去创建，InnoDB存储引擎会<code>自动</code>的为我们创建聚簇索引.</p><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树种，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的IO操作</code></li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖与插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列作为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><p><strong>限制：</strong></p><ul><li>对于MySQL数据库目前著有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个MySQL的<code>表只能有一个聚簇索引</code>。一般情况就是该表的主键。</li><li>如果没有定义主键，InnoDB会选择<code>非空的唯一索引</code>代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量<code>选用有序的顺序id</code>，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://example.com/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库（未完成）" target="_blank" rel="external">http://example.com/2022/03/15/数据库/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/nineteeensr" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/nineteeensr" target="_blank"><span class="text-dark">崔源耕</span><small class="ml-1x">Java后端 &amp; 菜鸟</small></a></h3><div>失败不是悲剧，放弃才是</div></div></figure></div></div></div></article><section id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC81NTc4OS8zMjI1NQ=="><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="next"><a href="/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Linux简单的开发环境搭建"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/nineteeensr" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/u/6575186617" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer type="text/javascript">!function(e,t){var n=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((e=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",e.async=!0,n.parentNode.insertBefore(e,n))}(document,"script")</script></body></html>