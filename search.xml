<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>索引的创建和设计原则</title>
      <link href="/2022/03/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2022/03/18/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="三、索引的创建与设计原则"><a href="#三、索引的创建与设计原则" class="headerlink" title="三、索引的创建与设计原则"></a>三、索引的创建与设计原则</h1><h2 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a>1. 索引的声明与使用</h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照<code>作用字段个数</code>进行划分，分为 单列索引和联合索引。</li></ul><h4 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1. 普通索引"></a>1. 普通索引</h4><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<code>任何数据类型</code>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在<code>student</code>表的字段<code>name</code>建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><h4 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2. 唯一索引"></a>2. 唯一索引</h4><p>使用<code>UNIQUE参数</code>可以设置索引为唯一索引，在创建唯一索引时，限制该索引的值必须是唯一的，但允许有空值。在一张表中<code>可以有多个</code>唯一索引。</p><p>例如，在表<code>student</code>的字段<code>email</code>中创建唯一性索引，那么字段email的值就必须唯一，通过唯一索引，可以快速地确定某条记录。</p><h4 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3. 主键索引"></a>3. 主键索引</h4><p>主键索引就是一种<code>特殊的唯一索引</code>，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL + UNIQUE,一张表里<code>最多只有一个</code>主键索引。</p><p>因为这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><h4 id="4-单列索引"><a href="#4-单列索引" class="headerlink" title="4. 单列索引"></a>4. 单列索引</h4><p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以<code>有多个</code>单列索引。</p><h4 id="5-多列（组合、联合）索引"><a href="#5-多列（组合、联合）索引" class="headerlink" title="5. 多列（组合、联合）索引"></a>5. 多列（组合、联合）索引</h4><p>多列索引是在表的<code>多个字段组合</code>上创建一个索引，该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引<code>idx_id_name_gender</code>，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循<code>最左前缀法则</code>。</p><h4 id="6-全文索引"><a href="#6-全文索引" class="headerlink" title="6. 全文索引"></a>6. 全文索引</h4><p>全文索引（也称全文检索）是目前<code>搜索引擎</code>使用的一种关键技术。它能够利用<code>分词技术</code>等多种算法只能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结构。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p><p>使用参数<code>FULLTEXT</code>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在<code>CHAR</code>、<code>VARCHAR</code>或<code>TEXT</code>类型及其系列类型的字段上，<strong>查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。</strong>例如，表<code>student</code>的字段<code>information</code>是<code>TEXT    </code>类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p><p>全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。</p><ul><li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数，<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高。</strong>相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li></ul><blockquote><p>MySQL数据库从3.23版开始支持全文索引，但MySQL5.6.4以前<code>只有MyISAM支持</code>，5.6.4版本以后<code>InnoDB才支持</code>，但是官方版本不支持<code>中文分词</code>，需要第三方分词插件。在5.7.6版本中，MySQL内置了<code>ngram全文解析器</code>，用来支持亚洲语种的分词。</p><p>随着大数据时代的到来，关系型数据库对全文索引的需求已力不从心，逐渐被<code>solr</code>、<code>ElastaicSearch</code>等专门的搜索引擎所替代。</p></blockquote><h4 id="7-空间索引"><a href="#7-空间索引" class="headerlink" title="7. 空间索引"></a>7. 空间索引</h4><p>使用<code>参数SPATIAL</code>可以设置索引为<code>空间索引</code>。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括<code>GEOMETRY</code>、<code>POINT</code>、<code>LINESTRING</code>和<code>POLYGON</code>等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。</p><h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h3><p>MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句<code>CREATE TABLE</code>中指定索引列，使用<code>ALTER TABLE</code>语句在存在的表上创建索引，或者使用<code>CREATE INDEX</code>语句在已存在的表上添加索引。</p><h4 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1. 创建表的时候创建索引"></a>1. 创建表的时候创建索引</h4><p>隐式的方式创建索引。在声明有<code>主键约束</code>、<code>唯一性约束</code>、<code>外键约束</code>的字段上，会自动的添加相关的索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">dept_id <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>显式的创建索引，基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [index_name] (col_name [length]) [ADC <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><ul><li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示 <code>唯一索引</code>、<code>全文索引</code>和<code>空间索引</code></li><li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引</li><li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名</li><li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列种选择</li><li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</li><li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li></ul><h5 id="①-创建普通索引"><a href="#①-创建普通索引" class="headerlink" title="① 创建普通索引"></a>① 创建普通索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">book_id <span class="type">INT</span>,</span><br><span class="line">book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">AUTHORS <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">COMMENT <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">year_publication <span class="keyword">YEAR</span>,</span><br><span class="line"># 声明索引</span><br><span class="line">INDEX idx_book_name(book_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>查看索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式<span class="number">1</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book\G;</span><br><span class="line"># 方式<span class="number">2</span></span><br><span class="line">SHWO INDEX <span class="keyword">FROM</span> book;</span><br></pre></td></tr></table></figure><h5 id="②-创建唯一索引-（UNIQUE）"><a href="#②-创建唯一索引-（UNIQUE）" class="headerlink" title="② 创建唯一索引 （UNIQUE）"></a>② 创建唯一索引 （UNIQUE）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book1(</span><br><span class="line">book_id <span class="type">INT</span>,</span><br><span class="line">book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">AUTHORS <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">COMMENT <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">year_publication <span class="keyword">YEAR</span>,</span><br><span class="line"># 声明索引</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX uk_idx_comment(COMMENT)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="③-主键索引"><a href="#③-主键索引" class="headerlink" title="③ 主键索引"></a>③ 主键索引</h5><p>通过定义主键约束的方式定义主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book2(</span><br><span class="line">book_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">AUTHORS <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">COMMENT <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">year_publication <span class="keyword">YEAR</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过删除主键约束的方式删除主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book2 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure><h5 id="④-创建组合索引"><a href="#④-创建组合索引" class="headerlink" title="④ 创建组合索引"></a>④ 创建组合索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book3(</span><br><span class="line">book_id <span class="type">INT</span>,</span><br><span class="line">book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">AUTHORS <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">COMMENT <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">year_publication <span class="keyword">YEAR</span>,</span><br><span class="line"># 声明联合索引</span><br><span class="line">INDEX mul_id_name(book_id,book_name,info)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="⑤-创建全文索引"><a href="#⑤-创建全文索引" class="headerlink" title="⑤ 创建全文索引"></a>⑤ 创建全文索引</h5><p>FULLTEXT全文索引可以用于全文搜索，并且只为<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>列创建索引。索引总是对整个列进行，不支持局部（前缀）索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book4(</span><br><span class="line">book_id <span class="type">INT</span>,</span><br><span class="line">book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">AUTHORS <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">COMMENT <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">year_publication <span class="keyword">YEAR</span>,</span><br><span class="line"># 声明全文索引</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不同于<code>like</code>方式的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;%查询字符串%&#x27;</span>；</span><br></pre></td></tr></table></figure><p>全文索引用match+ageinst方式查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,content) AGAINST (<span class="string">&#x27;查询字符串&#x27;</span>);</span><br></pre></td></tr></table></figure><p>明显的提高查询效率。</p><blockquote><p>注意：</p><ol><li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li><li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li></ol></blockquote><h5 id="⑥-创建空间索引"><a href="#⑥-创建空间索引" class="headerlink" title="⑥ 创建空间索引"></a>⑥ 创建空间索引</h5><p>空间索引创建中，要求空间类型的字段必须为<code>非空</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><h4 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2. 在已经存在的表上创建索引"></a>2. 在已经存在的表上创建索引</h4><h5 id="1-使用ALTER-TABLE-语句创建索引"><a href="#1-使用ALTER-TABLE-语句创建索引" class="headerlink" title="1. 使用ALTER TABLE 语句创建索引"></a>1. 使用ALTER TABLE 语句创建索引</h5><p>ALTER TABLE 语句创建索引的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><h5 id="2-使用CREATE-INDEX-创建索引"><a href="#2-使用CREATE-INDEX-创建索引" class="headerlink" title="2. 使用CREATE INDEX 创建索引"></a>2. 使用CREATE INDEX 创建索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATITAL] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h3><p>MySQL中删除索引使用<code>ALTER TABLE ... DROP </code> 或者<code>DROP INDEX</code>语句。</p><h4 id="1-使用ALTER-TABLE-删除索引"><a href="#1-使用ALTER-TABLE-删除索引" class="headerlink" title="1. 使用ALTER TABLE 删除索引"></a>1. 使用ALTER TABLE 删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><blockquote><p>添加AUTO_INCREMENT约束字段的唯一索引不能删除。</p></blockquote><h4 id="2-使用DROP-INDEX删除索引"><a href="#2-使用DROP-INDEX删除索引" class="headerlink" title="2. 使用DROP INDEX删除索引"></a>2. 使用DROP INDEX删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><blockquote><p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列被删除，则整个索引将被删除。</p></blockquote><h2 id="2-MySQL8-0-索引新特性（待完善）"><a href="#2-MySQL8-0-索引新特性（待完善）" class="headerlink" title="2. MySQL8.0 索引新特性（待完善）"></a>2. MySQL8.0 索引新特性（待完善）</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=130&spm_id_from=pageDriver">MySQL高级130P</a></p></blockquote><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h3><h2 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a>3. 索引的设计原则</h2><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。</strong>高效的索引对于获得良好的性能非常重要。</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p><strong>第一步：创建数据库、创建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE index_demo_db;</span><br><span class="line"></span><br><span class="line">USE index_demo_db;</span><br><span class="line">#<span class="number">1.</span>创建学生表和课程表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student_info`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`class_id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `course`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`course_name` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p><strong>第二步：创建模拟数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#函数<span class="number">1</span>：创建随机产生字符串函数</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO </span><br><span class="line">       <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">       <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@log</span>_bin_trust_function_creators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#函数<span class="number">2</span>：创建随机数函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>   </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>))   ;</span><br><span class="line"><span class="keyword">RETURN</span> i;  </span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>第三步：创建存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">1</span>：创建插入课程表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  insert_course( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    #设置手动提交事务</span><br><span class="line"> REPEAT  #循环</span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  #赋值</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> course (course_id, course_name ) <span class="keyword">VALUES</span> (rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_string(<span class="number">6</span>));  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>;  #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 存储过程<span class="number">2</span>：创建插入学生信息表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  insert_stu( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    #设置手动提交事务</span><br><span class="line"> REPEAT  #循环</span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  #赋值</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id ,student_id ,NAME ) <span class="keyword">VALUES</span> (rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_num(<span class="number">10000</span>,<span class="number">10200</span>),rand_num(<span class="number">1</span>,<span class="number">200000</span>),rand_string(<span class="number">6</span>));  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>;  #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>第四步：调用存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#调用存储过程：</span><br><span class="line"><span class="keyword">CALL</span> insert_course(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> course;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student_info;</span><br></pre></td></tr></table></figure><h3 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h3><h4 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1. 字段的数值有唯一性的限制"></a>1. 字段的数值有唯一性的限制</h4><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一性的</code>，就可以直接<code>创建唯一性索引</code>，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p><h4 id="2-频繁作为where查询条件的字段"><a href="#2-频繁作为where查询条件的字段" class="headerlink" title="2. 频繁作为where查询条件的字段"></a>2. 频繁作为<code>where查询条件</code>的字段</h4><h4 id="3-经常GROUP-BY-和-ORDER-BY的列"><a href="#3-经常GROUP-BY-和-ORDER-BY的列" class="headerlink" title="3. 经常GROUP BY 和 ORDER BY的列"></a>3. 经常<code>GROUP BY</code> 和 <code>ORDER BY</code>的列</h4><h4 id="4-UPDATE、DELETE和WHERE条件列"><a href="#4-UPDATE、DELETE和WHERE条件列" class="headerlink" title="4. UPDATE、DELETE和WHERE条件列"></a>4. <code>UPDATE</code>、<code>DELETE</code>和<code>WHERE</code>条件列</h4><h4 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5. DISTINCT 字段需要创建索引"></a>5. <code>DISTINCT </code>字段需要创建索引</h4><h4 id="6-多表JOIN连接操作时，创建索引注意事项"><a href="#6-多表JOIN连接操作时，创建索引注意事项" class="headerlink" title="6. 多表JOIN连接操作时，创建索引注意事项"></a>6. 多表<code>JOIN</code>连接操作时，创建索引注意事项</h4><h4 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a>7. 使用列的类型小的创建索引</h4><h4 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a>8. 使用字符串前缀创建索引</h4><h4 id="9-区分度高（散列性高）的列适合作为索引"><a href="#9-区分度高（散列性高）的列适合作为索引" class="headerlink" title="9. 区分度高（散列性高）的列适合作为索引"></a>9. 区分度高（散列性高）的列适合作为索引</h4><h4 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a>10. 使用最频繁的列放到联合索引的左侧</h4><h4 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11.在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11.在多个字段都要创建索引的情况下，联合索引优于单值索引</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库,MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引的数据结构</title>
      <link href="/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/16/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="二、索引的数据结构"><a href="#二、索引的数据结构" class="headerlink" title="二、索引的数据结构"></a>二、索引的数据结构</h1><h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h2><p>索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看<code>查询条件</code>是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code></p><p>对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即<code>二叉搜索树</code>，二叉搜索树的每个节点存储的是<code>(K,V)结构</code>，key是该字段，value是该key所在行的文件指针（地址）。</p><p>目的是为了<code>减少磁盘I/O的次数</code>，加速查询速率</p><h2 id="2-索引的优缺点"><a href="#2-索引的优缺点" class="headerlink" title="2. 索引的优缺点"></a>2. 索引的优缺点</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定相同。同时存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。</p><p>所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。</p><h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>,这也是创建索引最主要的原因。</li><li>通过创建<code>唯一索引</code>，可以保证数据库表中每一行数据的<code>唯一性</code>。</li><li>在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。</li></ol><p>​    <code>即对于有依赖关系的子表和父表联合查询时</code>，可以提高查询速度。</p><ol start="4"><li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的功耗。</li></ol><h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><ol><li>创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占用 <code>磁盘空间</code>，除了数据表占数据空间，每个索引还要占一定的物理空间，<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增删改，索引也需要动态地维护</li></ol><p>因此，选择使用索引时，要综合考虑索引的优点和缺点。    </p><blockquote><p>提示：</p><p>索引可以提高查询的速度，但会影响插入记录的速度。这种情况，最好的办法是 先删除表中的索引，然后插入数据，插入完成后再创建索引</p></blockquote><h2 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3. InnoDB中索引的推演"></a>3. InnoDB中索引的推演</h2><h3 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h3><p>先来看一个精确匹配的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure><h4 id="1-在单页中查找"><a href="#1-在单页中查找" class="headerlink" title="1.在单页中查找"></a>1.在单页中查找</h4><blockquote><p>存储数据的基本单位：数据页。一个数据页的默认大小为:<code>16 KB</code></p></blockquote><ul><li>以主键为搜索条件</li></ul><p>​    可以在页目录中使用 <code>二分法</code>快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录</p><ul><li>以其他列作为搜索条件</li></ul><p>​    因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位。这种情况下只能从<code>最小记录</code>开始<code>依次遍历</code>单链表中的每条记录，然后对比。</p><h4 id="2-在很多页中查找"><a href="#2-在很多页中查找" class="headerlink" title="2.在很多页中查找"></a>2.在很多页中查找</h4><p>在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页</li><li>从所在的页内中查找相应的记录</li></ol><p>在没有索引的情况下，无论是根据主键列或其他列进行查找，只能从<code>第一个页</code>沿着<code>双向链表</code>一直往下找。</p><h3 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h3><h4 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h4><p>建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">INT</span>,</span><br><span class="line">    c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png" alt="行格式01"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录,<code>2</code>表示最小记录、<code>3</code>表示最大记录</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁</li><li><code>各个列的值</code>：这里只记录在index_demo表中的三个列，分别是<code>c1</code>、<code>c2</code>、<code>c3</code></li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>把一些记录放到页里的示意图就是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317202704784.png" alt="image-20220317202704784"></p><ul><li><h4 id="给所有的页建立一个目录项"><a href="#给所有的页建立一个目录项" class="headerlink" title="给所有的页建立一个目录项"></a>给所有的页建立一个目录项</h4></li></ul><p>由于数据页的<code>编号可能是不连续的</code>，所以在向index_demo表中插入许多记录后，可能是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317203309169.png" alt="image-20220317203309169"></p><p>因为这些<code>16KB</code>的页在物理存储上是<code>不连续</code>的，所以如果想从这么多页种根据主键值<code>快速定位某些记录所在的页</code>，我们需要给它们做个<code>目录</code>，每页对应一个目录项，每个目录项包括下边两个部分：</p><ul><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示</li><li>页号，我们用<code>page_no</code>表示</li></ul><p>所以我们为上边几个页做好的目录就像这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319142443944.png" alt="image-20220319142443944"></p><p>我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录：</p><ol><li>先从目录项中根据<code>二分法</code>快速确定出主键值<code>20</code>的记录在<code>目录项3</code>中，它对应的页为<code>页9</code></li><li>再根据<code>二分法</code>查找记录的方式去<code>页9</code>中定位具体的记录</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录我们可以称为<code>索引</code></p><h4 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h4><h5 id="①迭代1次：目录项记录的页"><a href="#①迭代1次：目录项记录的页" class="headerlink" title="①迭代1次：目录项记录的页"></a>①迭代1次：目录项记录的页</h5><p>设计的简易索引方案，是因为我们为了在根据主键值进行查找时，使用<code>二分法</code>快速定位具体的目录项而假设所有目录项都可以在物理存储器上<code>连续存储</code>,但是这样做有几个问题：</p><ul><li>InnoDB时使用页作为管理存储空间的基本单位，最多保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要<code>非常大的连续的存储空间</code>才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们经常会对<code>记录进行增删</code>，假设我们把<code>页28</code>中的记录都删除了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样导致了操作效率很差。</li></ul><p>所以，我们需要一种可以<code>灵活管理所有目录项</code>的方式。我们发现目录项其实长的跟我们用户记录差不多，只不过目录项中的两个列是<code>主键</code>和<code>页号</code>而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。InnoDB如何区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>么？使用记录头信息的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>1</code>：目录项记录</li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>把使用的目录项放到数据页中的样子就是这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319150119906.png" alt="image-20220319150119906"></p><p>从图中可以看出来，我们分配了一个编号为30的页来专门存储目录项记录。</p><p><code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都为0</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时，可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两部：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法 </code>快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以</li></ol><h5 id="②迭代2次：多个目录项记录的页"><a href="#②迭代2次：多个目录项记录的页" class="headerlink" title="②迭代2次：多个目录项记录的页"></a>②迭代2次：多个目录项记录的页</h5><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号,比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多,以至于一个数据页不足以存放所有的<code>目录项记录</code>，如何处理呢？</p><p>这里我们假设一个存储目录项记录的页<code>最多只能存放4条目录项记录</code>,所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页: </p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319153534036.png" alt="image-20220319153534036"></p><h5 id="③迭代3次：目录项记录页的目录页"><a href="#③迭代3次：目录项记录页的目录页" class="headerlink" title="③迭代3次：目录项记录页的目录页"></a>③迭代3次：目录项记录页的目录页</h5><p>在第二次迭代的查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些<code>页是不连续的</code>，如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像一个多级目录，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319174816454.png" alt="image-20220319174816454"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间,则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319175351088.png" alt="image-20220319175351088"></p><p>这个数据结构，就是<code>B+树</code></p><h5 id="④B-Tree"><a href="#④B-Tree" class="headerlink" title="④B+Tree"></a>④B+Tree</h5><p>无论是存放<code>用户记录</code>的数据页，还是存放<code>目录项记录</code>的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出，我们的实际用户记录其实都存放在B+树的<code>最底层</code>的节点上，即<code>叶子节点</code>,B+树最上边的节点称为<code>根节点</code>.</p><blockquote><p>用户记录存放在B+树的叶子节点上，每一个叶子节点中的<code>每一行数据通过单向链表</code>的方式存储，而<code>叶子节点之间是双向链表</code>。</p><p><strong>树的层次越低，IO次数越少</strong></p></blockquote><p>一般情况下，我们用到的<code>B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找三个目录项页和一个用户记录页），又因为在每个页面内又所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法来实现快速定位记录。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>叶子节点</code>：存储实际数据记录，其中又<code>record_type=2</code>标记<strong>最小主键值</strong>,<code>record_type=3</code>标记<strong>最大主键值</strong></p><p><code>内节点</code>：存储每一个数据页的<code>页码</code>以及每一页<code>record_type=2</code>的最小主键值，即数据的目录页，<code>record_type=1</code></p><p><code>根节点或第二层节点</code>：存储的是目录页的记录，<code>每一个目录页的最小主键值</code>以及<code>目录页的页码</code></p><h3 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为<code>二级索引</code>或<code>辅助索引</code></p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子节点），也就是所谓的<code>索引即数据，数据即索引</code>。</p><blockquote><p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p></blockquote><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><code>数据页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</li><li>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p> 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>我们把具有这两种特性的B+树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<code>INDEX</code>语句去创建，InnoDB存储引擎会<code>自动</code>的为我们创建聚簇索引.</p><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树种，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的IO操作</code></li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列作为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><p><strong>限制：</strong></p><ul><li>对于MySQL数据库目前著有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个MySQL的<code>表只能有一个聚簇索引</code>。一般情况就是该表的主键。</li><li>如果没有定义主键，InnoDB会选择<code>非空的唯一索引</code>代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量<code>选用有序的顺序id</code>，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul><h4 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h4><p><code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为B+树的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？</p><p>我们可以<code>多建几棵B+树</code>，不同的B+树种的数据采用不同的排序规则。比如我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如图：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320154136216.png" alt="image-20220320154136216"></p><p><strong>概念：回表</strong></p><p>我们根据以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一边，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树。</p><p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>（<code>secondary index</code>）,或者<code>辅助索引</code>。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。</p><p>非聚簇索引的存在不影响数据再聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p><p><strong>小结：</strong></p><ol><li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>，非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li><li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li><li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li></ol><h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引"></a>3. 联合索引</h4><p>我们也可以同时以多列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p>为c2和c3列建立的索引的示意图如下：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320160133477.png" alt="image-20220320160133477"></p><p>如图：</p><ul><li>每条<code>目录项记录</code>由<code>c2、c3、页号</code>这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。</li><li>B+树<code>叶子节点</code>处的用户记录由<code>c2、c3和主键c1列</code>组成。</li></ul><p>以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列建立索引的表述是不同的，不同点：</p><ul><li>建立<code>联合索引</code>只会建立如上图一样的<code>1棵</code>B+树。</li><li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立<code>2棵</code>B+树</li></ul><h3 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h3><h4 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h4><p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:</p><ul><li>每当为某个表创建一个B+树索引 (聚簇索引不是人为创建的，默认就有)的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><blockquote><p>这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p></blockquote><h4 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h4><p>B+树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是对于二级索引来说不严谨。以<code>index_demo</code>表为例，假设表中的数据是：</p><table><thead><tr><th><code>c1</code></th><th><code>c2</code></th><th><code>c3</code></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320161927231.png" alt="image-20220320161927231"></p><p>如果此时我们插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别为：<code>9</code>、<code>1</code>、<code>&#39;c&#39;</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便遇到了问题：</p><p>由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都为<code>1</code>，而我们<code>新插入的这条记录</code>的c2列的值也是<code>1</code>，那此时我们应该插入到<code>页4</code>中还是<code>页5</code>中呢？</p><p>为了让新插入记录能找到自己的位置，我们需要<strong>保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>这样就保证了B+树每一层节点中各条目录项记录除页号以外是<code>唯一的</code>所以我们为c2列建立二级索引后的示意图应该是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320162613758.png" alt="image-20220320162613758"></p><h4 id="3-一个页面最少存储2条记录"><a href="#3-一个页面最少存储2条记录" class="headerlink" title="3. 一个页面最少存储2条记录"></a>3. 一个页面最少存储2条记录</h4><h2 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h2><p><strong>B树索引使用存储引擎：</strong></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>InnoDB和MyISAM默认的索引是BTree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却<code>将索引和数据分开存储</code>：</p><ul><li>将表中的记录<code>按照记录的插入顺序</code>单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录。由于在插入数据的时候并<code>没有刻意按照主键大小排序</code>，所以我们并不能在这些数据上使用二分法进行查找。</li><li>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过索引的叶子节点存储的不是完整的用户记录，而是<code>主键值 + 数据记录的地址</code>。</li></ul><h2 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h2><ul><li><p><strong>空间上的代价</strong></p><p>  每建立一个索引都要为它建立一颗B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一篇存储空间。</p></li><li><p><strong>时间上的代价</strong></p><p>  每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树的索引。而且，B+树每层节点都是按照索引列的值<code>从小到大的顺序</code>而组成了<code>双向链表</code>。无论是叶子节点中的记录，还是内节点的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。</p></li></ul><blockquote><p>一个表上的索引创建的越多，就会占用越多的空间，增删改的性能越差。</p></blockquote><h2 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6. MySQL数据结构选择的合理性"></a>6. MySQL数据结构选择的合理性</h2><p>从MySQL的角度讲，不得不考虑的现实问题就是<code>磁盘IO</code>。如果我们能让索引的数据结构尽量减少磁盘的I/O操作，所消耗的时间也就越小。<code>磁盘的 I/O 操作次数</code>对索引的使用效率至关重要。</p><p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引时存储在外部磁盘上的。</strong>当我们利用索引查询的时候，只能<code>逐一加载</code>索引到内存中，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p><h3 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h3><p>性能极差！</p><h3 id="6-2-Hash结构"><a href="#6-2-Hash结构" class="headerlink" title="6.2 Hash结构"></a>6.2 Hash结构</h3><p>Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p><p>Hash算法时通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。<code>相同的输入永远可以得到相同的输出</code>。</p><p><strong>提升查询效率的数据结构，常见的有两类：</strong></p><ol><li>树，例如 <code>平衡二叉搜索树</code>，查询/插入/修改/删除的平均时间复杂度都是<code>O(log2N)</code>；</li><li>哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是<code>O(1)</code>;</li></ol><p>采用Hash进行检索效率非常高，基本一次检索就可以找到数据，而B+树需要自顶向下一次查找，多次访问节点才能找到数据，中间需要多次I/O操作，从效率来说<code> Hash 比 B+ 树更快</code></p><p><strong>Hash结构效率高，为什么索引结构要设计成树？</strong></p><ol><li>Hash索引仅能满足 <code>=</code> 、<code>!=</code> 和 <code>IN</code>查询。如果进行<code>范围查询</code>，哈希索引，时间复杂度会退化为<code>O(n)</code>；而<code>树</code>的有序特性，依然能够保持<code>O(log2N)</code>的高效。</li><li>Hash索引，数据存储是<code>无序的</code>,在<code>ORDER BY </code>的情况下，使用Hash索引还需要对数据重新排序。</li><li>对于联合索引的情况，Hash值是将联合索引键合并后一起计算的，无法对单独的一个键或者几个索引键进行查询。</li><li>对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<code>索引列的重复值如果很多。效率就会降低</code>。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如性别、年龄。</li></ol><p><strong>Hash索引使用存储引擎：</strong></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td><code>支持</code></td></tr></tbody></table><p><strong>Hash索引的适用性：</strong></p><p>MySQL中的Memory 存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<code>等值查询</code>的时候，可以采用Hash索引。</p><p>InnoDB本身不支持Hash索引，但是提供<code>自适应 Hash 索引</code>(Adaptive Hash Index)。</p><p>如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样就让B+树也具备了Hash索引的优点。</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320175329092.png" alt="image-20220320175329092"></p><p>采用自适应Hash索引目的是方便根据SQL的查询条件加速定位到叶子节点，特别是当B+树比较深的时候，通过自适应Hash索引可以明显提高数据的检索效率。</p><p>我们可以通过<code>innodb_adaptive_hash_index</code>变量来查看是否开启了自适应Hash，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Redis 存储的核心就是 Hash 表</p></blockquote><h3 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p>二叉树的一般情况的查找就不赘述了。</p><p><strong>极端情况：</strong></p><p>有时二叉树的深度非常大。比如我们给出的数据顺序是（5，22，23，34，77，89，91），此时二叉树就是这样的：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320175903317.png" alt="image-20220320175903317"></p><p>上面的树也属于二叉树，但是性能上退化为了链表，查找数据的时间复杂度变成了<code>O(n)</code>。</p><p>那么为了提高查询效率，就需要<code>减少磁盘IO次数</code>。为了减少磁盘IO次数，就需要尽量<code>降低树的高度</code>，将原来瘦高的树结构变成矮胖，树的每层的分叉越多越好。</p><h3 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h3><p>为了解决二叉树退化成链表的问题，我们就提出了<code>平衡二叉搜索树(Balanced Binary Tree)</code>，又称为<code>AVL树</code>，它在二叉搜索树的基础上增加了约束，具有以下性质：</p><p><strong>它是一棵空树或它的左右两个字数的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</strong>。</p><p>常见的平衡二叉树有很多种，包括了<code>平衡二叉搜索树</code>、<code>红黑树</code>、<code>数堆</code>、<code>伸展树</code>。</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320180447767.png" alt="image-20220320180447767"></p><p><code>每访问一次节点就需要进行一次磁盘 I/O 操作</code>，对于上面的树来说，我们需要进行5次I/O操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。</p><h3 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h3><p>B树（Balance Tree），也就是<code>多路平衡二叉树</code>。简写为B-Tree。它的高度远小于平衡二叉树的高度。</p><p>B树的结构如下图：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320180729812.png" alt="image-20220320180729812"></p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<code>M 称为 B 树的阶</code>。每个磁盘块中包括了<code>关键字</code>和<code>子节点的指针</code>。如果一个磁盘块中包含了 x 个关键字，那么指针数就是 x+1。对于一个100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的。</p><p>一个M阶的B树（M &gt; 2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2 , M).</li><li>每个中间节点包含k-1个关键字和k个孩子，孩子的数量 = 关键字的数量 + 1，k的取值范围为[ceil (M / 2), M]。</li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k的取值范围为[ceil (M / 2), M]。</li><li>假设中间节点，节点的关键字为：Key[1],Key[2],…,Key[k - 1],且关键字按照升序排序，即 Key[ i ]&lt;Key[i + 1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k],其中P[1]指向关键字小于Key[1]的子树。P[i]指向关键字属于（Key[i - 1],Key[i]）的子树，P[k]指向关键字大于 Key[k - 1]的子树。</li><li>所有叶子节点位于同一层。</li></ol><p><strong>小结：</strong></p><ol><li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ol><p>举例：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220320182319384.png" alt="image-20220320182319384"></p><h3 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h3><p>B+树也是一种多路搜索树，<code>基于 B 树做出了改进</code>，主流的DBMS都支持 B+树的索引方式，比如 MySQL。相比于B-Tree，<code>B+Tree适合文件索引系统</code>。</p><p><strong>B+树和B树的差异：</strong></p><ol><li>有k个孩子的节点就有k个关键字。也就是孩子数量 = 关键字数，而 B树种，孩子数量 = 关键字数 + 1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子结点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，<code>非叶子节点既保存索引，也保存数据记录</code>。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到达顺序链接。</li></ol><p>B+ 树和 B 树有个根本的差异在于，<strong>B+ 树的中间节点并不直接存储数据。</strong>这样的好处都有什么呢？</p><ol><li><strong>B+树的查询效率更稳定</strong></li><li><strong>B+树的查询效率更高</strong>，这是因为通常B+ 树比B 树<code>更矮胖</code>（阶数更大，深度更低），查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</li></ol><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高。</strong>这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的。而在B树种则需要通过<code>中序遍历</code>才能完成查询范围的查找，效率要低很多。</p><blockquote><p>B树和B+树都可以作为索引的数据结构，在MySQL中采用的是B+树。</p><p>但B树和B+树各有自己的应用场景。</p></blockquote><p><strong>B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/（8B+8B）=1K个键值（因为是估值，方便计算，K的取值为10^3），也就是说一个深度为 3 的B+Tree索引可以维护 10 ^ 3 * 10 ^ 3 * 10 ^ 3 = 10 亿条记录。这里假定一个数据也也存储10 ^ 3条行记录</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在 2~4 层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时，最多只需要1~3次磁盘IO操作。</p></blockquote><p><strong>Hash 索引与 B+树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。因为Hash索引指向的数据是无序的，而B+树的叶子节点是一个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左前缀法则</code>（即联合索引的部分索引无法使用）。</p><p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，无法起到排序优化的作用。同理我们也无法使用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（%结尾）的话就可以起到优化作用</p><p>4、InnoDB不支持Hash索引</p></blockquote><h3 id="6-7-R树"><a href="#6-7-R树" class="headerlink" title="6.7 R树"></a>6.7 R树</h3><p>R-Tree在MySQL中很少使用，仅支持<code>geometry数据类型</code>。R树很好的解决了<code>高维空间搜索问题</code>。地图的搜索，20公里内所有的餐厅。</p><p>R树就是一棵用来<code>存储高维数据的平衡树</code>。</p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>R-Tree索引</td><td>支持</td><td>支持</td><td><code>不支持</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库,MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB锁算法与锁机制</title>
      <link href="/2022/03/14/InnoDB%E9%94%81%E7%AE%97%E6%B3%95%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/03/14/InnoDB%E9%94%81%E7%AE%97%E6%B3%95%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、常用的两种存储引擎"><a href="#一、常用的两种存储引擎" class="headerlink" title="一、常用的两种存储引擎"></a>一、常用的两种存储引擎</h1><h2 id="1-MyISAM与InnoDB"><a href="#1-MyISAM与InnoDB" class="headerlink" title="1. MyISAM与InnoDB"></a>1. MyISAM与InnoDB</h2><ol><li>是否支持行级锁</li></ol><p>MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。</p><ol start="2"><li>是否支持事务</li></ol><p>MyISAM不提供事务支持，InnoDB提供事务支持，具有提交（commit）和回滚（rollback）的事务能力。</p><ol start="3"><li>是否支持外键</li></ol><p>MyISAM不支持外键，InnoDB支持外键</p><ol start="4"><li>是否支持数据库异常崩溃后的安全恢复</li></ol><p>MyISAM不支持，InnoDB支持。</p><p>使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log。</p><blockquote><p>InnoDB 使用redo log（重做日志）保证事务的持久性，使用undo log（回滚日志）来保证事务的原子性。</p><p>通过 锁机制，MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEATABLE-READ）</p><p>保证了事务的持久性，原子性，隔离性之后，一致性才能得到保障</p></blockquote><h2 id="2-锁机制与InnoDB锁算法"><a href="#2-锁机制与InnoDB锁算法" class="headerlink" title="2. 锁机制与InnoDB锁算法"></a>2. 锁机制与InnoDB锁算法</h2><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁。</li><li>InnoDB支持行级锁和表级锁默认为行级锁。</li></ul><p>表级锁和行级锁对比：</p><ul><li>表级锁：MySQL中锁定<strong>粒度最大</strong>的一种锁，对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。</li><li>行级锁：MySQL中锁定<strong>粒度最小</strong>的一种锁，对当前操作的行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p>InnoDB支持三种行锁定：</p><ul><li>行锁（Record Lock）：锁直接加在索引记录上面，锁住的是key。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而设计的。</li><li>后码锁（Next-Key Lock）：行锁和间隙锁组合起来就叫Next-Key Lock。</li></ul><p>默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><h3 id="2-1-行锁（Record-Lock）"><a href="#2-1-行锁（Record-Lock）" class="headerlink" title="2.1 行锁（Record Lock）"></a>2.1 行锁（Record Lock）</h3><ul><li>当需要对表中的某条数据进行写操作（insert，update，delete，select for update）时，需要先获取记录的排他锁（X锁），这个就称为行锁。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> x(`id` <span class="type">int</span>, `num` <span class="type">int</span>, index `idx_id` (`id`));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> x <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="comment">-- 如果事务A没有commit，id=1的记录拿不到X锁，将出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务C</span></span><br><span class="line"><span class="comment">-- id=2的记录可以拿到X锁，不会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>针对InnoDB RR隔离级别，行锁的特点：“锁定特定行不允许进行修改”，但<strong>行锁是基于表索引的</strong>，如果where条件中用的是num字段（非索引列）将产生不一样的现象：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="comment">-- 由于事务A中num字段上没有索引将产生表锁，导致整张表的写操作都会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务C</span></span><br><span class="line"><span class="comment">-- 同理，会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务D</span></span><br><span class="line"><span class="comment">-- 等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> x <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-Gap锁（Gap-Lock）"><a href="#2-2-Gap锁（Gap-Lock）" class="headerlink" title="2.2 Gap锁（Gap Lock）"></a>2.2 Gap锁（Gap Lock）</h3><p>在MySQL中select称为快照读，不需要锁，而insert、update、delete、select for update则称为当前读，需要给数据加锁，幻读中的“读”即是针对当前读。</p><p>RR事务隔离级别允许存在幻读，但InnoDB RR级别却通过Gap锁避免了幻读</p><p><strong>产生间隙锁的条件（RR事务隔离级别下）</strong></p><ul><li>使用普通索引锁定</li><li>使用多列唯一索引</li><li>使用唯一索引锁定多行记录</li></ul><p><strong>唯一索引的间隙锁</strong></p><p>数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="只使用记录锁，不会产生间隙锁"><a href="#只使用记录锁，不会产生间隙锁" class="headerlink" title="只使用记录锁，不会产生间隙锁"></a>只使用记录锁，不会产生间隙锁</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小张&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>以上，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以，只会对id=5的数据加上记录锁，而不会产生间隙锁。</p><h5 id="产生间隙锁"><a href="#产生间隙锁" class="headerlink" title="产生间隙锁"></a>产生间隙锁</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id 在 7 - 11 范围的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">7</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h5 id="锁住不存在的数据"><a href="#锁住不存在的数据" class="headerlink" title="锁住不存在的数据"></a>锁住不存在的数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 3 这一条不存在的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;小张1&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁</p><p>结论</p><ul><li>对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：WHERE <code>id</code> = 5 FOR UPDATE;</li><li>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE <code>id</code> BETWEEN 5 AND 7 FOR UPDATE;</li></ul><h5 id="普通索引的间隙锁"><a href="#普通索引的间隙锁" class="headerlink" title="普通索引的间隙锁"></a>普通索引的间隙锁</h5><p>数据准备</p><p>创建test1表：</p><ul><li>number 不是唯一值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `number` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `number` (`number`) <span class="keyword">USING</span> BTREE </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>id 是主键，number上建立了一个普通索引。先加一些数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>test1表中 number 索引存在的隐藏间隙：</p><p>(-infinity, 1]<br>(1, 3]<br>(3, 8]<br>(8, 12]<br>(12, +infinity]</p><h5 id="执行以下的事务（事务1最后提交"><a href="#执行以下的事务（事务1最后提交" class="headerlink" title="执行以下的事务（事务1最后提交)"></a>执行以下的事务（事务1最后提交)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 number = 0 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">0</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">1</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">2</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 number = 4 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">4</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">8</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">9</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 number = 10 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">10</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务1插入一条 id = 2， number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3， number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 6， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">8</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 8， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="number">8</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 9， number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="number">9</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 10， number = 12 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">12</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7修改 id = 11， number = 12 的数据 */</span></span><br><span class="line">UPDATE `test1` <span class="keyword">SET</span> `number` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">11</span> <span class="keyword">AND</span> `number` <span class="operator">=</span> <span class="number">12</span>; <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这里有一个奇怪的现象：</p><p>事务3添加 id = 6，number = 8 的数据，给阻塞了；<br>事务4添加 id = 8，number = 8 的数据，正常执行了。<br>事务7将 id = 11，number = 12 的数据修改为 id = 11， number = 5的操作，给阻塞了；</p><p>当 number 相同时，会根据主键 id 来排序，所以：</p><p>事务3添加的 id = 6，number = 8，这条数据是在 （3, 8） 的区间里边，所以会被阻塞；<br>事务4添加的 id = 8，number = 8，这条数据则是在（8, 12）区间里边，所以不会被阻塞；<br>事务7的修改语句相当于在 （3, 8） 的区间里边插入一条数据，所以也被阻塞了。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样</li><li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序</li></ul><h3 id="2-3-后码锁（Next-key-Lock）"><a href="#2-3-后码锁（Next-key-Lock）" class="headerlink" title="2.3 后码锁（Next-key Lock）"></a>2.3 后码锁（Next-key Lock）</h3><p>后码锁是记录锁与间隙锁的组合，也是为了避免幻读。如果把事务的隔离级别降级为RC，Next-key Lock 则也会失效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>记录锁、间隙锁、后码锁，都属于排它锁；</li><li>记录锁就是锁住一行记录；</li><li>间隙锁只有在事务级别RR中才会产生；</li><li>唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁；</li><li>普通索引不管是锁住单条，还是多条记录，都会产生间隙锁；</li><li>间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其他事务在这个区域插入、修改、删除数据，这是为了防止出现幻读现象；</li><li>普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序；</li><li>事务级别RC（读已提交）级别的话。间隙锁将会失效。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库,MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简单的开发环境搭建</title>
      <link href="/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux开发环境搭建-CentOS-7"><a href="#Linux开发环境搭建-CentOS-7" class="headerlink" title="Linux开发环境搭建( CentOS-7 )"></a>Linux开发环境搭建( CentOS-7 )</h1><h2 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h2><ol><li>将<code>jdk</code>通过 <code>xftp5</code> 上传到 /opt 下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压缩到/opt下</span></span><br><span class="line">tar -zxvf jdk-8u231-linux-x64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在profile文件末尾追加以下指令</span></span><br><span class="line">JAVA_HOME=/OPT/jdk1.8.0_231</span><br><span class="line">PATH=/opt/jdk1.8.0_231/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 让配置文件生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-安装MySql"><a href="#2-安装MySql" class="headerlink" title="2. 安装MySql"></a>2. 安装MySql</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql mysql-server mysql-devel -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">yum install -y mariadb-server</span><br><span class="line">systemctl start mariadb.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放3306端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动mysql客户端</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认没有密码 回车即可</span></span><br><span class="line">use mysql;</span><br><span class="line">update user set password=password(&#x27;root&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权远程访问</span></span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动</span></span><br><span class="line">systemctl enable mariadb.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改字符编码</span></span><br><span class="line">cd /usr/share/mysql</span><br><span class="line">cp my-small.cnf /etc/my.cnf</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改内容</span></span><br><span class="line">character_set_server=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启mysql服务</span></span><br><span class="line">systemctl restart mariadb.service</span><br></pre></td></tr></table></figure><h2 id="3-安装Tomcat"><a href="#3-安装Tomcat" class="headerlink" title="3. 安装Tomcat"></a>3. 安装Tomcat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.34.tar.gz</span><br><span class="line">cd apache-tomcat-9.0.34/</span><br><span class="line">cd bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动tomcat</span></span><br><span class="line">./startup.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放8080端口 防火墙关闭则不用</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><h2 id="4-安装Redis-3-0-0"><a href="#4-安装Redis-3-0-0" class="headerlink" title="4. 安装Redis-3.0.0"></a>4. 安装Redis-3.0.0</h2><blockquote><p>Redis是C语言开发，需要gcc环境</p><p>yum -y install gcc</p></blockquote><ol><li>将redis-x-x-x.tar.gz 上传至/usr/local下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入redis目录 使用make命令编译redis</span></span><br><span class="line">cd redis-3.0.0</span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立软连接 类似于windows下的快捷方式</span></span><br><span class="line">ln -s /usr/local/redis-3.0.0/src/redis-server /usr/bin/redis-server</span><br><span class="line">ln -s /usr/local/redis-3.0.0/src/redis-cli /usr/bin/redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改redis.conf</span> </span><br><span class="line">daemonize=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台模式启动redis</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><h2 id="5-安装Docker"><a href="#5-安装Docker" class="headerlink" title="5. 安装Docker"></a>5. 安装Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker版本</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机启动docker</span> </span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止docker</span></span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h2 id="6-安装Zookeeper，部署Dubbo"><a href="#6-安装Zookeeper，部署Dubbo" class="headerlink" title="6.安装Zookeeper，部署Dubbo"></a>6.安装Zookeeper，部署Dubbo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取zookeeper镜像</span></span><br><span class="line">docker pull zookeeper</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动镜像</span></span><br><span class="line">docker run --name zookeeper01 -p 2181:2181 --restart always -d 镜像id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取tomcat镜像</span></span><br><span class="line">docker pull tomcat:9.0.59-jdk8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动tomcat</span></span><br><span class="line">docker run --name tomcat_dubbo -d -p 8080:8080 --privileged=true tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入tomcat容器</span></span><br><span class="line">docker exec -it tomcat_dubbo /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> webapps是空的此时测试tomcat为404 将webapps.dist 改名为webapps</span></span><br><span class="line">mv webapps webapps2</span><br><span class="line">mv webapps.dist webapps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制 dubbo-admin-2.6.0.war 到容器内的webapps下</span></span><br><span class="line">docker cp dubbo-admin-2.5.7.war tomcat_dubbo:/usr/local/tomcat/webapps/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启tomcat容器</span></span><br><span class="line">docker restart tomcat_dubbo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -it tomcat_dubbo /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内安装vim编辑器</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改dubbo.properties</span></span><br><span class="line">vim /usr/local/tomcat/webapps/dubbo-admin-2.5.7/WEB-INF/dubbo.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改内容如下</span></span><br><span class="line">dubbo.registry.address=zookeeper://82.157.232.222:2181</span><br><span class="line">dubbo.admin.root.password=root</span><br><span class="line">dubbo.admin.guest.password=guest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启tomcat</span></span><br><span class="line">docker restart tomcat_dubbo</span><br></pre></td></tr></table></figure><p><strong>测试Dubbo</strong> <a href="http://82.157.232.222:2181/dubbo-admin-2.5.7/">http://82.157.232.222:2181/dubbo-admin-2.5.7/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架</title>
      <link href="/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java框架（Framework）"><a href="#Java框架（Framework）" class="headerlink" title="Java框架（Framework）"></a>Java框架（Framework）</h1><h3 id="框架技术"><a href="#框架技术" class="headerlink" title="框架技术"></a>框架技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是一个应用程序的半成品</span><br><span class="line">提供可重用的公共结构</span><br><span class="line">按一定规则组织的一组组件</span><br></pre></td></tr></table></figure><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不用再考虑公共问题</span><br><span class="line"></span><br><span class="line">专心在业务实现上</span><br><span class="line"></span><br><span class="line">结构统一，易于学习、维护</span><br></pre></td></tr></table></figure><h3 id="主流框架介绍"><a href="#主流框架介绍" class="headerlink" title="主流框架介绍"></a>主流框架介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Struts2</span><br><span class="line"></span><br><span class="line">MVC设计模式的重现</span><br><span class="line"></span><br><span class="line">拦截器</span><br><span class="line"></span><br><span class="line">可变和可重用的标签</span><br><span class="line"></span><br><span class="line">HIBERNATE</span><br><span class="line"></span><br><span class="line">ORM,简化数据库操作</span><br><span class="line"></span><br><span class="line">Dao层</span><br><span class="line"></span><br><span class="line">Spring</span><br><span class="line">依赖注入容器/AOP实现</span><br><span class="line"></span><br><span class="line">声明式事务</span><br><span class="line"></span><br><span class="line">简化Java EE应用</span><br><span class="line"></span><br><span class="line">粘合剂，将大家组装到一起</span><br><span class="line"></span><br><span class="line">Spring MVC</span><br><span class="line"></span><br><span class="line">结构最清晰的MVC Model2实现</span><br><span class="line"></span><br><span class="line">高度可配置，支持多种视图技术</span><br><span class="line"></span><br><span class="line">定制化开发</span><br><span class="line"></span><br><span class="line">MyBatis</span><br><span class="line"></span><br><span class="line">半自动化的ORM实现</span><br><span class="line"></span><br><span class="line">DAO层</span><br><span class="line"></span><br><span class="line">动态SQL</span><br></pre></td></tr></table></figure><h3 id="持久化与ORM（Object-Relational-Mapping）"><a href="#持久化与ORM（Object-Relational-Mapping）" class="headerlink" title="持久化与ORM（Object Relational Mapping）"></a>持久化与ORM（Object Relational Mapping）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">持久化是程序数据在瞬时状态和持久状态转换的过程</span><br><span class="line">ORM</span><br><span class="line">编写程序的时候，以面向对象的方式处理数据</span><br><span class="line">保存数据的时候，却以关系型数据库的方式存储</span><br><span class="line">ORM解决方案包含下面四个部分</span><br><span class="line">在持久化对象上执行基本的增删改查操作</span><br><span class="line">对持久化对象提供一种查询语言或者API</span><br><span class="line">对象关系映射工具</span><br><span class="line">提供与事务对象交互、执行检查、延迟加载以及其他优化功能</span><br></pre></td></tr></table></figure><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis "></a>MyBatis <img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211108200011135.png" alt="image-20211108200011135" style="zoom: 33%;" /></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyBatis前身是iBatis，本是Apache的一个开源项目</span><br><span class="line">官网</span><br><span class="line">http：//mybatis.org</span><br><span class="line">ORM框架</span><br><span class="line">实体类和SQL语句之间建立映射关系</span><br><span class="line">特点</span><br><span class="line">基于SQL语法，简单易学</span><br><span class="line">能了解底层封装过程</span><br><span class="line">SQL语句封装在配置文件中，便于统一管理与维护，降低程序的耦合度</span><br><span class="line">方便程序代码调试</span><br><span class="line">MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</span><br></pre></td></tr></table></figure><h2 id="一、安装MyBatis"><a href="#一、安装MyBatis" class="headerlink" title="一、安装MyBatis"></a>一、安装MyBatis</h2><h3 id="pom-xml依赖"><a href="#pom-xml依赖" class="headerlink" title="pom.xml依赖"></a>pom.xml依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mabits-version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">mabits-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mabits-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、使用MyBatis的开发步骤"><a href="#二、使用MyBatis的开发步骤" class="headerlink" title="二、使用MyBatis的开发步骤"></a>二、使用MyBatis的开发步骤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下载mybatis-3.2.2jar包并导入工程</span><br><span class="line">编写MyBatis核心配置文件(configuration.xml)</span><br><span class="line">创建实体类-POJO</span><br><span class="line">DAO层-SQL映射文件(mapper.xml)</span><br><span class="line">创建测试类</span><br><span class="line">读取全局配置文件mybatis-config.xml</span><br><span class="line">创建SqlSessionFactory对象，读取配置文件</span><br><span class="line">创建SqlSession对象</span><br></pre></td></tr></table></figure><h3 id="database-properties"><a href="#database-properties" class="headerlink" title="database.properties"></a>database.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/leavedb?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入外部文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;database.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.cyg.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h3><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p><p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取sqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatisconfig.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line">    <span class="comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭SqlSession</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSqlSession</span><span class="params">(SqlSession sqlSession)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h3><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、编写代码"><a href="#三、编写代码" class="headerlink" title="三、编写代码"></a>三、编写代码</h2><h3 id="实体类–-gt-pojo"><a href="#实体类–-gt-pojo" class="headerlink" title="实体类–&gt;pojo"></a>实体类–&gt;pojo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer studentNo;</span><br><span class="line">    <span class="keyword">private</span> String loginPwd;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Integer gradeId;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String gName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口–-gt-mapper"><a href="#接口–-gt-mapper" class="headerlink" title="接口–&gt;mapper"></a>接口–&gt;mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有学生</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getAllStudent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据学号studentNo查询学生</span></span><br><span class="line">    <span class="function">Student <span class="title">getStudentByStudentNo</span><span class="params">(Integer studentNo)</span></span>;</span><br><span class="line">    <span class="comment">//根据姓名studentName模糊查询</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudentByStudentName</span><span class="params">(<span class="meta">@Param(&quot;studentName&quot;)</span> String studentName, <span class="meta">@Param(&quot;gradeId&quot;)</span>Integer gradeId)</span></span>;</span><br><span class="line">    <span class="comment">//查询用户总记录数</span></span><br><span class="line">    <span class="function">Integer <span class="title">countStudentInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id修改用户信息</span></span><br><span class="line">    <span class="function">Integer <span class="title">updateStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function">Integer <span class="title">addStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function">Integer <span class="title">deleteStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mapper-xml配置"><a href="#Mapper-xml配置" class="headerlink" title="Mapper.xml配置"></a>Mapper.xml配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!---mapper路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.cyg.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--增删改查标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span>&gt;</span><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span>&gt;</span><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span>&gt;</span><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、动态mysql"><a href="#四、动态mysql" class="headerlink" title="四、动态mysql"></a>四、动态mysql</h2><p style="color:red;font-size:20px;font-weight:bolder">动态SQL是MyBatis的强大特性之一</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set和trim"><a href="#set和trim" class="headerlink" title="set和trim"></a>set和trim</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>​    动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p></blockquote><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogsLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">标签</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">if</td><td align="center">单条件分支，相当于java的if</td></tr><tr><td align="center">choose、when、otherwise</td><td align="center">不想使用所有的条件，而只是想从多个条件中选择一个使用。相当于switch语句；如果都没有传入when标签，那么就会执行otherwise</td></tr><tr><td align="center">where、set</td><td align="center">只会在子元素返回任何内容的情况下才插入where子句，而且where元素会自动去除and和or；set会自动去除 –&gt; ， &lt;–</td></tr><tr><td align="center">trim</td><td align="center">可以通过自定义trim元素来定制where和set；prefix前缀；prefixOverrides去除前缀；suffix后缀；suffixOverrides去除后缀</td></tr><tr><td align="center">foreach</td><td align="center">对集合进行遍历（构建IN条件语句时）声明可以在元素体内使用集合项（item）和索引（index）变量。也允许指定开头与结尾的字符串以及集合迭代之间的分隔符。当使用Map对象时，index是键，item是值</td></tr><tr><td align="center">bind</td><td align="center">允许在OGNL表达式以外创建一个变量，并将其绑定到当前的上下文 name；value</td></tr></tbody></table><h3 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h3><p>Object Graphic Navigation Language(对象 图 导航 语言)==对象导航图语言</p><p>语法：#{}</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="1-parameterType-输入类型"><a href="#1-parameterType-输入类型" class="headerlink" title="1.parameterType(输入类型)"></a>1.parameterType(输入类型)</h4><p>​    1）传递简单类型</p><p>​    2）传递pojo对象</p><p>​        Mybatis使用ognl表达式解析对象字段的值，#{}或者${}中的值为pojo属性名称</p><p>​    3）传递pojo包装对象</p><p>​        开发中通过pojo传递查询条件，不仅包括用户查询条件还包括其他的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数</p><h4 id="2-resultType-输出类型"><a href="#2-resultType-输出类型" class="headerlink" title="2.resultType(输出类型)"></a>2.resultType(输出类型)</h4><p>​    1）输出简单类型</p><p>​    <img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111190924176.png" alt="image-20211111190924176" style="zoom: 80%;" /></p><p>​    2）输出pojo对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    3）输出pojo列表</p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111191027548.png" alt="image-20211111191027548" style="zoom:80%;" /><h4 id="3-resultMap结果类型"><a href="#3-resultMap结果类型" class="headerlink" title="3.resultMap结果类型"></a>3.resultMap结果类型</h4><p>​    resultType可以指定将查询结果映射为pojo，但是需要pojo的属性名和sql查询的列名一致方可映射成功</p><p>​    如果sql查询字段名和pojo属性名不一致，可以通过resultMap将字段名和属性名作为一个对应关系，resultMap实质上还需要将查询结果映射到pojo对象中</p><p>​    resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询</p><h5 id="返回列名和实体类属性不一致"><a href="#返回列名和实体类属性不一致" class="headerlink" title="返回列名和实体类属性不一致"></a>返回列名和实体类属性不一致</h5><p>解决方案一：别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select id,userName name from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方案二：使用resultMap</p><p>优势：开发效率高，降低代码耦合度</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;uesrList&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h3><p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId == &#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">      select seq_users.nextval from dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId == &#x27;db2&#x27;&quot;</span>&gt;</span></span><br><span class="line">      select nextval for seq_users from sysibm.sysdummy1&quot;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="五、Mybatis中的多表查询"><a href="#五、Mybatis中的多表查询" class="headerlink" title="五、Mybatis中的多表查询"></a>五、Mybatis中的多表查询</h2><h3 id="1-一对一查询"><a href="#1-一对一查询" class="headerlink" title="1.一对一查询"></a>1.一对一查询</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;aMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Account&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一对一的映射关系：配置封装user的内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-一对多查询"><a href="#2-一对多查询" class="headerlink" title="2.一对多查询"></a>2.一对多查询</h3><p>用户信息和账户信息为一对多关系，如果用户没有账户，也要将该用户查出来，所以此时使用左外连接查询</p><blockquote><p>一对多关系映射，主表实体包含从表实体的集合引用</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;uMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置user对象中account集合的映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;accountList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Account&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;aId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;uId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-多对多查询"><a href="#3-多对多查询" class="headerlink" title="3.多对多查询"></a>3.多对多查询</h3><p>一个用户可以有多个角色，一个角色可以赋予多个用户</p><blockquote><p>RoleMapper.xml文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;rMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;roleName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllRoleAndUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;rMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT r.*, u.id uId, u.userName, u.sex, u.birthday</span><br><span class="line">        FROM role r</span><br><span class="line">                 LEFT JOIN user_role ur ON r.id = ur.rid</span><br><span class="line">                 LEFT JOIN USER u ON u.id = ur.uId</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>UserMapper.xml文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;uMap1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Role&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;rId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;uMap1&quot;</span>&gt;</span></span><br><span class="line">        SELECT u.*, r.roleName, r.id rId, r.roleDesc</span><br><span class="line">        FROM USER u</span><br><span class="line">                 LEFT JOIN user_role ur ON ur.uId = u.id</span><br><span class="line">                 LEFT JOIN role r ON ur.rId = r.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六、Mybatis延迟加载"><a href="#六、Mybatis延迟加载" class="headerlink" title="六、Mybatis延迟加载"></a>六、Mybatis延迟加载</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.mybatis中的延迟加载，也称为懒加载</p><p>2.是指在进行关联查询时，按照设置延迟规则对关联对象的select查询。</p><blockquote><p>延迟加载可以有效的减少数据库的压力</p></blockquote><p>3.延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓的延迟加载就是挡在真正需要的时候，才真正执行数据的加载</p><h3 id="二、关联对象加载时机"><a href="#二、关联对象加载时机" class="headerlink" title="二、关联对象加载时机"></a>二、关联对象加载时机</h3><ul><li><h4 id="直接加载："><a href="#直接加载：" class="headerlink" title="直接加载："></a>直接加载：</h4><p>  ​    执行完对主加载对象的select语句，马上执行对关联对象的select查询</p></li><li><h4 id="侵入式加载："><a href="#侵入式加载：" class="headerlink" title="侵入式加载："></a>侵入式加载：</h4><p>  ​    侵入式延迟加载，执行主对象属性时，会走关联对象SQL语句，如果不访问主对象的属性，则不会走关联对象</p></li><li><h4 id="深度延迟加载："><a href="#深度延迟加载：" class="headerlink" title="深度延迟加载："></a>深度延迟加载：</h4><p>  ​    执行对主加载对象的查询时，不会执行对关联对象的查询，访问主加载对象的详情时，也不会执行关联对象的select查询，只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。</p><blockquote><p>访问主对象的属性，只执行了主对象的sql操作，并没有走关联对象的sql语句</p></blockquote></li><li><h4 id="延迟加载的应用要求："><a href="#延迟加载的应用要求：" class="headerlink" title="延迟加载的应用要求："></a>延迟加载的应用要求：</h4></li></ul><p style="color:red;margin-left:30px;font-weight:bolder">关联对象的查询与主加载对象的查询必须是分别进行的select语句，不能使用多表连接所进行的select查询</p><h3 id="三、直接加载、侵入式加载、深度加载"><a href="#三、直接加载、侵入式加载、深度加载" class="headerlink" title="三、直接加载、侵入式加载、深度加载"></a>三、直接加载、侵入式加载、深度加载</h3><h4 id="1-核心配置文件"><a href="#1-核心配置文件" class="headerlink" title="1.核心配置文件"></a>1.核心配置文件</h4><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111202620289.png" alt="image-20211111202620289"></p><h4 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h4><h5 id="直接加载：-1"><a href="#直接加载：-1" class="headerlink" title="直接加载："></a>直接加载：</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211114161147888.png" alt="image-20211114161147888"></p><h5 id="侵入式加载：-1"><a href="#侵入式加载：-1" class="headerlink" title="侵入式加载："></a>侵入式加载：</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211114161201219.png" alt="image-20211114161201219"></p><h5 id="深度延迟加载：-1"><a href="#深度延迟加载：-1" class="headerlink" title="深度延迟加载："></a>深度延迟加载：</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211114161217185.png" alt="image-20211114161217185"></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><h4 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h4><ul><li>延迟加载对主对象都是直接加载，只有对关联对象时延迟加载</li><li>延迟加载可以减轻数据库压力</li><li>延迟加载不可以是一条SQL查询多表信息，这样构不成延迟加载，会形成直接加载</li></ul><h2 id="七、Mybatis中的缓存"><a href="#七、Mybatis中的缓存" class="headerlink" title="七、Mybatis中的缓存"></a>七、Mybatis中的缓存</h2><h4 id="1-什么是缓存？"><a href="#1-什么是缓存？" class="headerlink" title="1.什么是缓存？"></a>1.什么是缓存？</h4><p>缓存就是数据交换的缓冲区（Cache），是存储数据（使用频繁的数据）的临时空间</p><blockquote><p>当要读取数据时，会首先从缓存查询数据，有就直接执行，不存在时从内存/数据库中获取</p></blockquote><p>默认情况下，mabatis只开启一级缓存</p><h4 id="2-为什么使用缓存"><a href="#2-为什么使用缓存" class="headerlink" title="2.为什么使用缓存"></a>2.为什么使用缓存</h4><p style="color:red;text-align:left">减少和数据库交互的次数，提高执行效率</p><h4 id="3-什么样的数据能使用缓存"><a href="#3-什么样的数据能使用缓存" class="headerlink" title="3.什么样的数据能使用缓存"></a>3.什么样的数据能使用缓存</h4><p>适用于缓存：    </p><p>​    1）经常查询并且经常使用</p><p>​    2）数据的正确与否对最终结果影响不大</p><p>不适用于缓存：</p><p>​    1）经常改变的数据</p><p>​    2）数据的正确与否对最终结果影响很大</p><p>​    3）比如：商品的库存，银行汇率，股票价格</p><h3 id="Mybatis的一级缓存"><a href="#Mybatis的一级缓存" class="headerlink" title="Mybatis的一级缓存"></a>Mybatis的一级缓存</h3><ul><li>它指的是Mybatis中SqlSession对象的缓存</li><li>同一个SqlSession对象，在参数和SQL完全一样的情况下，只执行一次SQL语句</li><li>当我们执行查询之后，查询的结果会同时存入到SqlSession提供一块区域，该区域的结构是一个Map，当我们再次查询同样的数据，mybatis会先去SqlSession中查询，如果有直接使用；当SqlSession消失时，mybatis的一级缓存也就消失了</li></ul><h4 id="清空一级缓存的方法："><a href="#清空一级缓存的方法：" class="headerlink" title="清空一级缓存的方法："></a>清空一级缓存的方法：</h4><ol><li>关闭SqlSession对象==&gt;sqlSession.close()</li><li>调用SqlSession对象的clearCache()方法==&gt;sqlSession.clearCache()</li><li>调用增删改方法</li></ol><h3 id="Mybatis的二级缓存"><a href="#Mybatis的二级缓存" class="headerlink" title="Mybatis的二级缓存"></a>Mybatis的二级缓存</h3><p>​    它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存</p><h4 id="二级缓存开关"><a href="#二级缓存开关" class="headerlink" title="二级缓存开关"></a>二级缓存开关</h4><h5 id="全局开关核心配置"><a href="#全局开关核心配置" class="headerlink" title="全局开关核心配置"></a>全局开关核心配置</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111205929805.png" alt="image-20211111205929805"></p><h5 id="分开关"><a href="#分开关" class="headerlink" title="分开关"></a>分开关</h5><ol><li><p>Mapper.xml文件中配置</p><blockquote><p>让当前的映射文件支持二级缓存</p></blockquote><p> <img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111210828079.png" alt="image-20211111210828079"></p></li><li><p>select标签中配置</p><blockquote><p>让当前的操作支持二级缓存</p></blockquote></li></ol><blockquote><p>flushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存</p><p>useCache默认为true，表示会将本条语句的结果进行二级缓存。</p></blockquote><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111210711930.png" alt="image-20211111210711930"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据是表述客观事务的符号，是计算机中可以被操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符以及声音、图像、视频等非数值类型。</span><br></pre></td></tr></table></figure><h5 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</span><br></pre></td></tr></table></figure><h5 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</span><br></pre></td></tr></table></figure><h5 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据对象是性质相同的数据元素的集合，是数据的子集。</span><br></pre></td></tr></table></figure><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据结构没有官方统一定义</span><br><span class="line">&quot;数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。&quot;</span><br><span class="line">Sartaj Sahni，《数据结构、算法与应用》</span><br><span class="line">&quot;数据结构是ADT(抽象数据类型Abstract Data Type)的物理实现&quot;</span><br><span class="line">Clifford A.Shaffer，《数据结构与算法分析》</span><br><span class="line">&quot;数据结构(data structure) 是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。&quot;</span><br><span class="line">中文维基百科</span><br><span class="line">在计算机中数据元素并不是孤立杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式--《大话数据结构》</span><br></pre></td></tr></table></figure><p>数据怎么组织 跟数据的规模有关系，不一样的规模处理起来的难度不一样。</p><p>解决问题方法的效率，跟数据的组织方式有关。</p><h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑结构：是指数据对象中元素之间的相互关系</span><br></pre></td></tr></table></figure><h5 id="1-集合结构"><a href="#1-集合结构" class="headerlink" title="1.集合结构"></a>1.集合结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据是“平等”的，他们的共同属性是“同属于一个集合”</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915083919994.png" alt="image-20210915083919994" style="zoom:30%;" /><h5 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2.线性结构"></a>2.线性结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线性结构中的数据元素之间是一对一的关系</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084015078.png" alt="image-20210915084015078" style="zoom:33%;" /><h5 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3.树形结构"></a>3.树形结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树形结构中的数据元素存在一种一对多的层次关系</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084107625.png" alt="image-20210915084107625" style="zoom:33%;" /><h5 id="4-图形结构"><a href="#4-图形结构" class="headerlink" title="4.图形结构"></a>4.图形结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图形结构的数据元素是多对多的关系</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084140587.png" alt="image-20210915084140587" style="zoom:33%;" /><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><h5 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1.顺序存储结构"></a>1.顺序存储结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</span><br><span class="line">要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所占位置的大小乘以9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样依次摆放。</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084305835.png" alt="image-20210915084305835" style="zoom: 50%;" /><h5 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2.链式存储结构"></a>2.链式存储结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084552592.png" alt="image-20210915084552592" style="zoom:33%;" /><p>逻辑结构是面向问题的，而物理结构就是面向计算机的，其最基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</span><br></pre></td></tr></table></figure><h5 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Abstract Data Type，ADT：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915090903806.png" alt="image-20210915090903806" style="zoom: 80%;" /><h2 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</span><br><span class="line">一个有限指令集</span><br><span class="line">接受一些输入</span><br><span class="line">产生输出</span><br><span class="line">一定在有限步骤之后终止</span><br><span class="line">每一条指令必须：</span><br><span class="line">有充分明确的目标，不可以有歧义</span><br><span class="line">计算机能处理的范围之内</span><br><span class="line">描述应不依赖于任何一种计算机语言以及具体的实现手段</span><br></pre></td></tr></table></figure><h5 id="算法的五个基本特性"><a href="#算法的五个基本特性" class="headerlink" title="算法的五个基本特性"></a>算法的五个基本特性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入、输出、有穷性、确定性和可行性</span><br><span class="line">·输入和输出：算法具有零个或多个输入，至少有一个输出或输出</span><br><span class="line">·有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</span><br><span class="line">·确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义</span><br><span class="line">·可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</span><br></pre></td></tr></table></figure><h5 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正确性：指算法至少应该具有输入。输出和加工处理无歧义性。能正确反映问题的需求、能够得到问题的正确答案。</span><br><span class="line">1.算法程序没有语法错误。</span><br><span class="line">2.算法程序对于合法的输入数据能够产生满足要求的输出的结果</span><br><span class="line">3.算法程序对于非法的输入数据能够得出满足规格说明的结果。</span><br><span class="line">4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果</span><br><span class="line">可读性：算法设计的另一个目的是为了便于阅读、理解和交流。</span><br><span class="line">健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</span><br><span class="line">时间效率高和存储量低</span><br></pre></td></tr></table></figure><h5 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度:调用时间</span><br><span class="line">空间复杂度:所占内存</span><br></pre></td></tr></table></figure><h5 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.事后统计法:通过统计,监控,利用计算机计时器对不同算法的运行时间进行比较,从而确定算法效率的高低,但是有非常大的局限性.</span><br><span class="line">2.事前分析估算:在计算机程序编制前,依据统计方法对算法进行估算.</span><br><span class="line">一个高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</span><br><span class="line">1.算法采用的策略、方法算法好坏的根本</span><br><span class="line">2.编译产生的代码质量软件来支持</span><br><span class="line">3.问题的输入规模</span><br><span class="line">4.机器执行指令的速度计算机硬件性能</span><br></pre></td></tr></table></figure><h5 id="事后统计法"><a href="#事后统计法" class="headerlink" title="事后统计法:"></a>事后统计法:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fun1</span><span class="params">(<span class="keyword">long</span> n )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> fun1(n-<span class="number">1</span>)+fun1(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归:自己调用自己</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n ;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=first+second;</span><br><span class="line">        first=second;</span><br><span class="line">        second=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(fun1(n:<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事前分析估算"><a href="#事前分析估算" class="headerlink" title="事前分析估算:"></a>事前分析估算:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal01</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="number">6</span><span class="comment">//1*unit-time  O(1)</span></span><br><span class="line">    <span class="keyword">if</span>(age&gt;<span class="number">58</span>)&#123;<span class="comment">//unit-time</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阿姨&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;<span class="number">28</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小姐姐&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美少女&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal02</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//3+3n unit-time O(n)</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line">    <span class="comment">//i执行n次 执行n次</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;<span class="comment">//n //n</span></span><br><span class="line">        sum=sum+i;<span class="comment">//执行n次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//执行1次//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal03</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+3n unit-time O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//n n n +1 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;崔源耕&quot;</span>);<span class="comment">//执行n次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal04</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+2n+n*(1+3n)=3n^2+3n+1 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//1 n  n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;n(<span class="number">1</span>+n+n+n)</span><br><span class="line">            System.out.println(<span class="string">&quot;Cui&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal05</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+2n+n*(1+20+20+20)=1+2n+61n=63n</span></span><br><span class="line">    <span class="comment">//T(n)=O(n) </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cui&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal06</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//log2(n)</span></span><br><span class="line">    <span class="comment">//T(n)=O(logn)//</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        i=i*<span class="number">2</span>;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal07</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+2*log2(n)+log2(n)*(1+3n)</span></span><br><span class="line">    <span class="comment">//T(n)=O(nlog(n))</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i=2i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ayi&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(n) 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</span><br></pre></td></tr></table></figure><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T(n)=O(f(n))</span><br><span class="line">T(n)表示代码执行时间;</span><br><span class="line">n表示数据规模的大小;</span><br><span class="line">f(n)表示每行代码执行的次数总和.</span><br><span class="line">因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比.</span><br><span class="line">大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210723091417415.png" alt="image-20210723091417415"></p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210723091458491.png" alt="image-20210723091458491"></p><h5 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算法A 要做2n+3次操作 算法B要做3n+1次操作</span><br></pre></td></tr></table></figure><table><thead><tr><th>次数</th><th>算法A（2n+3）</th><th>算法A‘（2n）</th><th>算法B（3n+1）</th><th>算法B’（3n）</th></tr></thead><tbody><tr><td>n=1</td><td>5</td><td>2</td><td>4</td><td>3</td></tr><tr><td>n=2</td><td>7</td><td>4</td><td>7</td><td>6</td></tr><tr><td>n=3</td><td>9</td><td>6</td><td>10</td><td>9</td></tr><tr><td>n=10</td><td>23</td><td>20</td><td>31</td><td>30</td></tr><tr><td>n=100</td><td>203</td><td>200</td><td>301</td><td>300</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的</span><br><span class="line">函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。</span><br></pre></td></tr></table></figure><hr><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个线性表是0个或n个具有相同特性的数据元素的有限且有序数列</span><br><span class="line">数组按照顺讯存储在连续位置的存储器中</span><br><span class="line">数组与列表相比,在特定位置添加或者删除元素成本过高</span><br><span class="line">优点:</span><br><span class="line">空间利用率高</span><br><span class="line">查询速度高效,通过下标来直接存取</span><br><span class="line">缺点</span><br><span class="line">插入和删除比较慢,比如:插入或者删除一个元素时,整个表需要遍历移动元素来重新排一次排序</span><br><span class="line">不可以增长长度,有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现&quot;溢出&quot;问题,当元素个数远少于预先分配空间时,空间浪费巨大</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211009200640073.png" alt="image-20211009200640073"></p><hr><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210723110717072.png" alt="image-20210723110717072"></p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 比冒泡排序交换次数少，比较次数不变</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 10217</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortNum</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> min = -<span class="number">1</span>;<span class="comment">// 最小值下标</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//外层循环：比较几轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">min = i;<span class="comment">//每轮min初始值</span></span><br><span class="line"><span class="comment">//内层循环：当前元素和后面的元素比较，记录最新的最小元素下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果min值发生变化，说明发现了更小的值，则当前值和更小值交换，保证小值放在数组前面</span></span><br><span class="line"><span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">temp = arr[min];</span><br><span class="line">arr[min] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num :arr) &#123;</span><br><span class="line">System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分（折半）查找法"><a href="#二分（折半）查找法" class="headerlink" title="二分（折半）查找法"></a>二分（折半）查找法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(arr);<span class="comment">//快速排序 如果给定数组不是升序数组那么使用快排，是则忽略</span></span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">            <span class="keyword">int</span> midIndex = startIndex + (endIndex - startIndex) / <span class="number">2</span>;<span class="comment">//如果使用（endIndex+startIndex）/2计算 如果数组长度太大会导致溢出</span></span><br><span class="line">            <span class="keyword">if</span> (num == arr[midIndex]) &#123;<span class="comment">//如果num就是midindex所指向的元素 return true；</span></span><br><span class="line">                <span class="keyword">return</span> midIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; arr[midIndex]) &#123;<span class="comment">//如果num&gt;midindex 开始下标则是midindex的下一位</span></span><br><span class="line">                startIndex = midIndex + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果num&lt;midindex 结束下标则是midindex的前一位</span></span><br><span class="line">                endIndex = midIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（未完成）</title>
      <link href="/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/"/>
      <url>/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式（Design-pattern）"><a href="#设计模式（Design-pattern）" class="headerlink" title="设计模式（Design pattern）"></a>设计模式（Design pattern）</h1><p>设计模式是一套被反复使用的，多数人知晓的，经过分类编目的、代码设计经验的总结。</p><h2 id="为什么使用设计模式？"><a href="#为什么使用设计模式？" class="headerlink" title="为什么使用设计模式？"></a>为什么使用设计模式？</h2><p>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p><h2 id="什么是GOF？"><a href="#什么是GOF？" class="headerlink" title="什么是GOF？"></a>什么是GOF？</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承</li></ul><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>共计23种设计模式</p><p>分为三大类：</p><ul><li>创建型模式（Creational Patterns）</li><li>结构型模式（Structural Patterns）</li><li>行为型模式（Behavioral Patterns）</li></ul><p>​    J2EE 设计模式</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><blockquote><p>提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定示例需要创建那些对象时更加灵活</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">·工厂模式(Factory Pattern)</span><br><span class="line">·抽象工厂模式(Abstract Factory Pattern)</span><br><span class="line">·单例模式(Singleton Pattern)</span><br><span class="line">·建造者模式(Builder Pattern)</span><br><span class="line">·原型模式(Prototype Pattern)</span><br></pre></td></tr></table></figure><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><blockquote><p>关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·适配器模式（Adapter Pattern）</span><br><span class="line">·桥接模式（Bridge Pattern）</span><br><span class="line">·过滤器模式（Filter、Criteria Pattern）</span><br><span class="line">·组合模式（Composite Pattern）</span><br><span class="line">·装饰器模式（Decorator Pattern）</span><br><span class="line">·外观模式（Facade Pattern）</span><br><span class="line">·享元模式（Flyweight Pattern） </span><br><span class="line">·代理模式（Proxy Pattern）</span><br></pre></td></tr></table></figure><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><blockquote><p>关注对象之间的通信</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">·责任链模式（Chain of Responsibility Pattern）</span><br><span class="line">·命令模式（Command Pattern）</span><br><span class="line">·解释器模式（Interpreter Pattern）</span><br><span class="line">·迭代器模式（Iterator Pattern）</span><br><span class="line">·中介者模式（Mediator Pattern）</span><br><span class="line">·备忘录模式（Memento Pattern）</span><br><span class="line">·观察者模式（Observer Pattern）</span><br><span class="line">·状态模式（State Pattern）</span><br><span class="line">·空对象模式（Null Object Pattern）</span><br><span class="line">·策略模式（Strategy Pattern）</span><br><span class="line">·模板模式（Template Pattern）</span><br><span class="line">·访问者模式（Visitor Pattern）</span><br></pre></td></tr></table></figure><h3 id="J2EE模式"><a href="#J2EE模式" class="headerlink" title="J2EE模式"></a>J2EE模式</h3><blockquote><p>特别关注表示层</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·MVC 模式（MVC Pattern）</span><br><span class="line">·业务代表模式（Business Delegate Pattern）</span><br><span class="line">·组合实体模式（Composite Entity Pattern）</span><br><span class="line">·数据访问对象模式（Data Access Object Pattern）</span><br><span class="line">·前端控制器模式（Front Controller Pattern）</span><br><span class="line">·拦截过滤器模式（Intercepting Filter Pattern）</span><br><span class="line">·服务定位器模式（Service Locator Pattern）</span><br><span class="line">·传输对象模式（Transfer Object Pattern）</span><br></pre></td></tr></table></figure><h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h3><p>对扩展开放、对修改关闭。在程序需要进行扩展时，不能去修改原有代码，实现一个热插拔的效果，为了使程序的扩展性好。易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类</p><h3 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2.里氏代换原则"></a>2.里氏代换原则</h3><p>里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方。子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则时对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体规范</p><h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h3><p>是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h3><p>使用多个隔离的接口，比使用单个接口要好。降低类的耦合度。</p><blockquote><p>由此可见其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p></blockquote><h3 id="5-迪米特法则，又称最少知道原则"><a href="#5-迪米特法则，又称最少知道原则" class="headerlink" title="5.迪米特法则，又称最少知道原则"></a>5.迪米特法则，又称最少知道原则</h3><p>一个实体应当尽量少地与其他实体之间发生相互作用，使用系统功能模块相对独立</p><h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承</p><h3 id="7-单一职责原则"><a href="#7-单一职责原则" class="headerlink" title="7.单一职责原则"></a>7.单一职责原则</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度的计算</title>
      <link href="/2021/12/11/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2021/12/11/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p><ul><li>一个有限指令集</li><li>接受一些输入</li><li>产生输出</li><li>一定在有限步骤后终止</li><li>每一条指令必须：<br>  有充分明确的目标，不可以有歧义<br>  计算机能处理的范围之内<br>  描述应不依赖于任何一种计算机语言以及具体的实现手段</li></ul><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><p>正确性、可读性、健壮性、<strong>时间效率高和存储量低</strong></p><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><p>事后统计法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</p><h4 id="例：求第n个斐波那契数列"><a href="#例：求第n个斐波那契数列" class="headerlink" title="例：求第n个斐波那契数列"></a>例：求第n个斐波那契数列</h4><img src="C:\Users\10217\Desktop\Fibonacci.png" alt="image-20210720090355878" style="zoom: 50%;" />**事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算**程序在计算机上运行时所消耗的时间取决于以下几个因素：<ol><li>算法采用的策略、方法==&gt;算法好坏的根本</li><li>编译产生的代码质量==&gt;由IDE、软件支持</li><li><strong>问题的输入规模</strong></li><li>机器执行指令的速度==&gt;看计算机硬件的性能</li></ol><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="什么是时间复杂度"><a href="#什么是时间复杂度" class="headerlink" title="什么是时间复杂度"></a>什么是时间复杂度</h2><ul><li>T(n)=O(f(n))</li></ul><ul><li>T(n)表示代码执行时间;</li><li>n表示数据规模的大小;</li><li>f(n)表示每行代码执行的次数总和.</li><li>因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比.</li><li>大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度</li></ul><h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算法A 要做2n+3次操作 算法B要做3n+1次操作</span><br></pre></td></tr></table></figure><table><thead><tr><th>次数</th><th>算法A（2n+3）</th><th>算法A‘（2n）</th><th>算法B（3n+1）</th><th>算法B’（3n）</th></tr></thead><tbody><tr><td>n=1</td><td>5</td><td>2</td><td>4</td><td>3</td></tr><tr><td>n=2</td><td>7</td><td>4</td><td>7</td><td>6</td></tr><tr><td>n=3</td><td>9</td><td>6</td><td>10</td><td>9</td></tr><tr><td>n=10</td><td>23</td><td>20</td><td>31</td><td>30</td></tr><tr><td>n=100</td><td>203</td><td>200</td><td>301</td><td>300</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的</span><br><span class="line">函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。</span><br></pre></td></tr></table></figure><hr><h2 id="一秒之内能解决问题的数据规模"><a href="#一秒之内能解决问题的数据规模" class="headerlink" title="一秒之内能解决问题的数据规模"></a>一秒之内能解决问题的数据规模</h2><table><thead><tr><th></th><th>数据规模</th><th>时间复杂度</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>n！</td></tr><tr><td>2</td><td>20~30</td><td>2^n</td></tr><tr><td>3</td><td>50</td><td>n^4</td></tr><tr><td>4</td><td>100</td><td>n^3</td></tr><tr><td>5</td><td>1000</td><td>n^2</td></tr><tr><td>6</td><td>10^6</td><td>nlogn</td></tr><tr><td>7</td><td>10^7</td><td>n</td></tr><tr><td>8</td><td>10^9</td><td>sqrt(n)</td></tr><tr><td>9</td><td>10^10</td><td>logn</td></tr><tr><td>10</td><td>无穷大</td><td>1</td></tr></tbody></table><h2 id="阿里面试题"><a href="#阿里面试题" class="headerlink" title="阿里面试题"></a>阿里面试题</h2><p>假设给出一个算法的时间复杂度递推关系式：T(n）=T(n-1)+n，T(0)=1；（n为整数）求该算法的时间复杂度</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
