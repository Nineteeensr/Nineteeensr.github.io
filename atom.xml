<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-19T13:45:22.537Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库（未完成）</title>
    <link href="http://example.com/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-03-15T13:43:03.000Z</published>
    <updated>2022-03-19T13:45:22.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用的两种存储引擎"><a href="#一、常用的两种存储引擎" class="headerlink" title="一、常用的两种存储引擎"></a>一、常用的两种存储引擎</h1><h2 id="MyISAM与InnoDB"><a href="#MyISAM与InnoDB" class="headerlink" title="MyISAM与InnoDB"></a>MyISAM与InnoDB</h2><ol><li>是否支持行级锁</li></ol><p>MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。</p><ol start="2"><li>是否支持事务</li></ol><p>MyISAM不提供事务支持，InnoDB提供事务支持，具有提交（commit）和回滚（rollback）的事务能力。</p><ol start="3"><li>是否支持外键</li></ol><p>MyISAM不支持外键，InnoDB支持外键</p><ol start="4"><li>是否支持数据库异常崩溃后的安全恢复</li></ol><p>MyISAM不支持，InnoDB支持。</p><p>使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log。</p><blockquote><p>InnoDB 使用redo log（重做日志）保证事务的持久性，使用undo log（回滚日志）来保证事务的原子性。</p><p>通过 锁机制，MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEATABLE-READ）</p><p>保证了事务的持久性，原子性，隔离性之后，一致性才能得到保障</p></blockquote><h2 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h2><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁。</li><li>InnoDB支持行级锁和表级锁默认为行级锁。</li></ul><p>表级锁和行级锁对比：</p><ul><li>表级锁：MySQL中锁定<strong>粒度最大</strong>的一种锁，对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。</li><li>行级锁：MySQL中锁定<strong>粒度最小</strong>的一种锁，对当前操作的行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p>InnoDB支持三种行锁定：</p><ul><li>行锁（Record Lock）：锁直接加在索引记录上面，锁住的是key。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而设计的。</li><li>后码锁（Next-Key Lock）：行锁和间隙锁组合起来就叫Next-Key Lock。</li></ul><p>默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><h3 id="行锁（Record-Lock）"><a href="#行锁（Record-Lock）" class="headerlink" title="行锁（Record Lock）"></a>行锁（Record Lock）</h3><ul><li>当需要对表中的某条数据进行写操作（insert，update，delete，select for update）时，需要先获取记录的排他锁（X锁），这个就称为行锁。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> x(`id` <span class="type">int</span>, `num` <span class="type">int</span>, index `idx_id` (`id`));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> x <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="comment">-- 如果事务A没有commit，id=1的记录拿不到X锁，将出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务C</span></span><br><span class="line"><span class="comment">-- id=2的记录可以拿到X锁，不会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>针对InnoDB RR隔离级别，行锁的特点：“锁定特定行不允许进行修改”，但<strong>行锁是基于表索引的</strong>，如果where条件中用的是num字段（非索引列）将产生不一样的现象：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="comment">-- 由于事务A中num字段上没有索引将产生表锁，导致整张表的写操作都会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务C</span></span><br><span class="line"><span class="comment">-- 同理，会出现等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">update x <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务D</span></span><br><span class="line"><span class="comment">-- 等待</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> x <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="Gap锁（Gap-Lock）"><a href="#Gap锁（Gap-Lock）" class="headerlink" title="Gap锁（Gap Lock）"></a>Gap锁（Gap Lock）</h3><p>在MySQL中select称为快照读，不需要锁，而insert、update、delete、select for update则称为当前读，需要给数据加锁，幻读中的“读”即是针对当前读。</p><p>RR事务隔离级别允许存在幻读，但InnoDB RR级别却通过Gap锁避免了幻读</p><p><strong>产生间隙锁的条件（RR事务隔离级别下）</strong></p><ul><li>使用普通索引锁定</li><li>使用多列唯一索引</li><li>使用唯一索引锁定多行记录</li></ul><p><strong>唯一索引的间隙锁</strong></p><p>数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="只使用记录锁，不会产生间隙锁"><a href="#只使用记录锁，不会产生间隙锁" class="headerlink" title="只使用记录锁，不会产生间隙锁"></a>只使用记录锁，不会产生间隙锁</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小张&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>以上，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以，只会对id=5的数据加上记录锁，而不会产生间隙锁。</p><h5 id="产生间隙锁"><a href="#产生间隙锁" class="headerlink" title="产生间隙锁"></a>产生间隙锁</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id 在 7 - 11 范围的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">7</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h5 id="锁住不存在的数据"><a href="#锁住不存在的数据" class="headerlink" title="锁住不存在的数据"></a>锁住不存在的数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 3 这一条不存在的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;小张1&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁</p><p>结论</p><ul><li>对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：WHERE <code>id</code> = 5 FOR UPDATE;</li><li>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE <code>id</code> BETWEEN 5 AND 7 FOR UPDATE;</li></ul><h5 id="普通索引的间隙锁"><a href="#普通索引的间隙锁" class="headerlink" title="普通索引的间隙锁"></a>普通索引的间隙锁</h5><p>数据准备</p><p>创建test1表：</p><ul><li>number 不是唯一值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `number` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `number` (`number`) <span class="keyword">USING</span> BTREE </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>id 是主键，number上建立了一个普通索引。先加一些数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>test1表中 number 索引存在的隐藏间隙：</p><p>(-infinity, 1]<br>(1, 3]<br>(3, 8]<br>(8, 12]<br>(12, +infinity]</p><h5 id="执行以下的事务（事务1最后提交"><a href="#执行以下的事务（事务1最后提交" class="headerlink" title="执行以下的事务（事务1最后提交)"></a>执行以下的事务（事务1最后提交)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 number = 0 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">0</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">1</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">2</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 number = 4 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">4</span>); <span class="comment">-- 被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">8</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">9</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 number = 10 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">10</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> UPDATE;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务1插入一条 id = 2， number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3， number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 6， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">8</span>); <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 8， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="number">8</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 9， number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="number">9</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 10， number = 12 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">12</span>); <span class="comment">-- 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7修改 id = 11， number = 12 的数据 */</span></span><br><span class="line">UPDATE `test1` <span class="keyword">SET</span> `number` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">11</span> <span class="keyword">AND</span> `number` <span class="operator">=</span> <span class="number">12</span>; <span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这里有一个奇怪的现象：</p><p>事务3添加 id = 6，number = 8 的数据，给阻塞了；<br>事务4添加 id = 8，number = 8 的数据，正常执行了。<br>事务7将 id = 11，number = 12 的数据修改为 id = 11， number = 5的操作，给阻塞了；</p><p>当 number 相同时，会根据主键 id 来排序，所以：</p><p>事务3添加的 id = 6，number = 8，这条数据是在 （3, 8） 的区间里边，所以会被阻塞；<br>事务4添加的 id = 8，number = 8，这条数据则是在（8, 12）区间里边，所以不会被阻塞；<br>事务7的修改语句相当于在 （3, 8） 的区间里边插入一条数据，所以也被阻塞了。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样</li><li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序</li></ul><h4 id="后码锁（Next-key-Lock）"><a href="#后码锁（Next-key-Lock）" class="headerlink" title="后码锁（Next-key Lock）"></a>后码锁（Next-key Lock）</h4><p>后码锁是记录锁与间隙锁的组合，也是为了避免幻读。如果把事务的隔离级别降级为RC，Next-key Lock 则也会失效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>记录锁、间隙锁、后码锁，都属于排它锁；</li><li>记录锁就是锁住一行记录；</li><li>间隙锁只有在事务级别RR中才会产生；</li><li>唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁；</li><li>普通索引不管是锁住单条，还是多条记录，都会产生间隙锁；</li><li>间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其他事务在这个区域插入、修改、删除数据，这是为了防止出现幻读现象；</li><li>普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序；</li><li>事务级别RC（读已提交）级别的话。间隙锁将会失效。</li></ul><h1 id="二、索引的数据结构"><a href="#二、索引的数据结构" class="headerlink" title="二、索引的数据结构"></a>二、索引的数据结构</h1><h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h2><p>索引是存储引擎用于快速查找到数据记录的一种数据结构，举例：查字典和查字典目录。进行数据查找时，首先查看<code>查询条件</code>是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code></p><p>对字段添加索引，相当于在硬盘上为该字段维护了一个索引的数据结构，即<code>二叉搜索树</code>，二叉搜索树的每个节点存储的是<code>(K,V)结构</code>，key是该字段，value是该key所在行的文件指针（地址）。</p><p>目的是为了<code>减少磁盘I/O的次数</code>，加速查询速率</p><h2 id="2-索引的优缺点"><a href="#2-索引的优缺点" class="headerlink" title="2. 索引的优缺点"></a>2. 索引的优缺点</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定相同。同时存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。</p><p>所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。</p><h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>,这也是创建索引最主要的原因。</li><li>通过创建<code>唯一索引</code>，可以保证数据库表中每一行数据的<code>唯一性</code>。</li><li>在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。</li></ol><p>​    <code>即对于有依赖关系的子表和父表联合查询时</code>，可以提高查询速度。</p><ol start="4"><li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的功耗。</li></ol><h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><ol><li>创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占用 <code>磁盘空间</code>，除了数据表占数据空间，每个索引还要占一定的物理空间，<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增删改，索引也需要动态地维护</li></ol><p>因此，选择使用索引时，要综合考虑索引的优点和缺点。    </p><blockquote><p>提示：</p><p>索引可以提高查询的速度，但会影响插入记录的速度。这种情况，最好的办法是 先删除表中的索引，然后插入数据，插入完成后再创建索引</p></blockquote><h2 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3.InnoDB中索引的推演"></a>3.InnoDB中索引的推演</h2><h3 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h3><p>先来看一个精确匹配的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure><h4 id="1-在单页中查找"><a href="#1-在单页中查找" class="headerlink" title="1.在单页中查找"></a>1.在单页中查找</h4><blockquote><p>存储数据的基本单位：数据页。一个数据页的默认大小为:<code>16 KB</code></p></blockquote><ul><li>以主键为搜索条件</li></ul><p>​    可以在页目录中使用 <code>二分法</code>快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录</p><ul><li>以其他列作为搜索条件</li></ul><p>​    因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位。这种情况下只能从<code>最小记录</code>开始<code>依次遍历</code>单链表中的每条记录，然后对比。</p><h4 id="2-在很多页中查找"><a href="#2-在很多页中查找" class="headerlink" title="2.在很多页中查找"></a>2.在很多页中查找</h4><p>在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页</li><li>从所在的页内中查找相应的记录</li></ol><p>在没有索引的情况下，无论是根据主键列或其他列进行查找，只能从<code>第一个页</code>沿着<code>双向链表</code>一直往下找。</p><h3 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h3><h4 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h4><p>建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">INT</span>,</span><br><span class="line">    c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/%E8%A1%8C%E6%A0%BC%E5%BC%8F01.png" alt="行格式01"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录,<code>2</code>表示最小记录、<code>3</code>表示最大记录</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁</li><li><code>各个列的值</code>：这里只记录在index_demo表中的三个列，分别是<code>c1</code>、<code>c2</code>、<code>c3</code></li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>把一些记录放到页里的示意图就是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317202704784.png" alt="image-20220317202704784"></p><ul><li><h4 id="给所有的页建立一个目录项"><a href="#给所有的页建立一个目录项" class="headerlink" title="给所有的页建立一个目录项"></a>给所有的页建立一个目录项</h4></li></ul><p>由于数据页的<code>编号可能是不连续的</code>，所以在向index_demo表中插入许多记录后，可能是：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220317203309169.png" alt="image-20220317203309169"></p><p>因为这些<code>16KB</code>的页在物理存储上是<code>不连续</code>的，所以如果想从这么多页种根据主键值<code>快速定位某些记录所在的页</code>，我们需要给它们做个<code>目录</code>，每页对应一个目录项，每个目录项包括下边两个部分：</p><ul><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示</li><li>页号，我们用<code>page_no</code>表示</li></ul><p>所以我们为上边几个页做好的目录就像这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319142443944.png" alt="image-20220319142443944"></p><p>我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录：</p><ol><li>先从目录项中根据<code>二分法</code>快速确定出主键值<code>20</code>的记录在<code>目录项3</code>中，它对应的页为<code>页9</code></li><li>再根据<code>二分法</code>查找记录的方式去<code>页9</code>中定位具体的记录</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录我们可以称为<code>索引</code></p><h4 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h4><h5 id="①迭代1次：目录项记录的页"><a href="#①迭代1次：目录项记录的页" class="headerlink" title="①迭代1次：目录项记录的页"></a>①迭代1次：目录项记录的页</h5><p>设计的简易索引方案，是因为我们为了在根据主键值进行查找时，使用<code>二分法</code>快速定位具体的目录项而假设所有目录项都可以在物理存储器上<code>连续存储</code>,但是这样做有几个问题：</p><ul><li>InnoDB时使用页作为管理存储空间的基本单位，最多保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要<code>非常大的连续的存储空间</code>才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们经常会对<code>记录进行增删</code>，假设我们把<code>页28</code>中的记录都删除了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样导致了操作效率很差。</li></ul><p>所以，我们需要一种可以<code>灵活管理所有目录项</code>的方式。我们发现目录项其实长的跟我们用户记录差不多，只不过目录项中的两个列是<code>主键</code>和<code>页号</code>而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。InnoDB如何区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>么？使用记录头信息的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>1</code>：目录项记录</li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>把使用的目录项放到数据页中的样子就是这样：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319150119906.png" alt="image-20220319150119906"></p><p>从图中可以看出来，我们分配了一个编号为30的页来专门存储目录项记录。</p><p><code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都为0</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时，可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两部：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法 </code>快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以</li></ol><h5 id="②迭代2次：多个目录项记录的页"><a href="#②迭代2次：多个目录项记录的页" class="headerlink" title="②迭代2次：多个目录项记录的页"></a>②迭代2次：多个目录项记录的页</h5><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号,比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多,以至于一个数据页不足以存放所有的<code>目录项记录</code>，如何处理呢？</p><p>这里我们假设一个存储目录项记录的页<code>最多只能存放4条目录项记录</code>,所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页: </p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319153534036.png" alt="image-20220319153534036"></p><h5 id="③迭代3次：目录项记录页的目录页"><a href="#③迭代3次：目录项记录页的目录页" class="headerlink" title="③迭代3次：目录项记录页的目录页"></a>③迭代3次：目录项记录页的目录页</h5><p>在第二次迭代的查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些<code>页是不连续的</code>，如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像一个多级目录，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319174816454.png" alt="image-20220319174816454"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间,则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20220319175351088.png" alt="image-20220319175351088"></p><p>这个数据结构，就是<code>B+树</code></p><h5 id="④B-Tree"><a href="#④B-Tree" class="headerlink" title="④B+Tree"></a>④B+Tree</h5><p>无论是存放<code>用户记录</code>的数据页，还是存放<code>目录项记录</code>的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出，我们的实际用户记录其实都存放在B+树的<code>最底层</code>的节点上，即<code>叶子节点</code>,B+树最上边的节点称为<code>根节点</code>.</p><blockquote><p>用户记录存放在B+树的叶子节点上，每一个叶子节点中的<code>每一行数据通过单向链表</code>的方式存储，而<code>叶子节点之间是双向链表</code>。</p><p><strong>树的层次越低，IO次数越少</strong></p></blockquote><p>一般情况下，我们用到的<code>B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找三个目录项页和一个用户记录页），又因为在每个页面内又所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法来实现快速定位记录。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>叶子节点</code>：存储实际数据记录，其中又<code>record_type=2</code>标记<strong>最小主键值</strong>,<code>record_type=3</code>标记<strong>最大主键值</strong></p><p><code>内节点</code>：存储每一个数据页的<code>页码</code>以及每一页<code>record_type=2</code>的最小主键值，即数据的目录页</p><p><code>根节点或第二层节点</code>：存储的是目录页的记录，<code>每一个目录页的最小主键值</code>以及<code>目录页的页码</code></p><h3 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为<code>二级索引</code>或<code>辅助索引</code></p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p><strong>聚簇索引</strong>并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子节点），也就是所谓的<code>索引即数据，数据即索引</code>。</p><blockquote><p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p></blockquote><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</li><li>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p> 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>我们把具有这两种特性的B+树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<code>INDEX</code>语句去创建，InnoDB存储引擎会<code>自动</code>的为我们创建聚簇索引.</p><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树种，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的IO操作</code></li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖与插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列作为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><p><strong>限制：</strong></p><ul><li>对于MySQL数据库目前著有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个MySQL的<code>表只能有一个聚簇索引</code>。一般情况就是该表的主键。</li><li>如果没有定义主键，InnoDB会选择<code>非空的唯一索引</code>代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量<code>选用有序的顺序id</code>，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、常用的两种存储引擎&quot;&gt;&lt;a href=&quot;#一、常用的两种存储引擎&quot; class=&quot;headerlink&quot; title=&quot;一、常用的两种存储引擎&quot;&gt;&lt;/a&gt;一、常用的两种存储引擎&lt;/h1&gt;&lt;h2 id=&quot;MyISAM与InnoDB&quot;&gt;&lt;a href=&quot;#MyIS</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux简单的开发环境搭建</title>
    <link href="http://example.com/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2022/03/06/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-03-06T10:14:00.000Z</published>
    <updated>2022-03-09T08:25:23.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux开发环境搭建-CentOS-7"><a href="#Linux开发环境搭建-CentOS-7" class="headerlink" title="Linux开发环境搭建( CentOS-7 )"></a>Linux开发环境搭建( CentOS-7 )</h1><h2 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h2><ol><li>将<code>jdk</code>通过 <code>xftp5</code> 上传到 /opt 下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压缩到/opt下</span></span><br><span class="line">tar -zxvf jdk-8u231-linux-x64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在profile文件末尾追加以下指令</span></span><br><span class="line">JAVA_HOME=/OPT/jdk1.8.0_231</span><br><span class="line">PATH=/opt/jdk1.8.0_231/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 让配置文件生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-安装MySql"><a href="#2-安装MySql" class="headerlink" title="2. 安装MySql"></a>2. 安装MySql</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql mysql-server mysql-devel -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">yum install -y mariadb-server</span><br><span class="line">systemctl start mariadb.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放3306端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动mysql客户端</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认没有密码 回车即可</span></span><br><span class="line">use mysql;</span><br><span class="line">update user set password=password(&#x27;root&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权远程访问</span></span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动</span></span><br><span class="line">systemctl enable mariadb.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改字符编码</span></span><br><span class="line">cd /usr/share/mysql</span><br><span class="line">cp my-small.cnf /etc/my.cnf</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改内容</span></span><br><span class="line">character_set_server=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启mysql服务</span></span><br><span class="line">systemctl restart mariadb.service</span><br></pre></td></tr></table></figure><h2 id="3-安装Tomcat"><a href="#3-安装Tomcat" class="headerlink" title="3. 安装Tomcat"></a>3. 安装Tomcat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.34.tar.gz</span><br><span class="line">cd apache-tomcat-9.0.34/</span><br><span class="line">cd bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动tomcat</span></span><br><span class="line">./startup.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放8080端口 防火墙关闭则不用</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><h2 id="4-安装Redis-3-0-0"><a href="#4-安装Redis-3-0-0" class="headerlink" title="4. 安装Redis-3.0.0"></a>4. 安装Redis-3.0.0</h2><blockquote><p>Redis是C语言开发，需要gcc环境</p><p>yum -y install gcc</p></blockquote><ol><li>将redis-x-x-x.tar.gz 上传至/usr/local下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入redis目录 使用make命令编译redis</span></span><br><span class="line">cd redis-3.0.0</span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立软连接 类似于windows下的快捷方式</span></span><br><span class="line">ln -s /usr/local/redis-3.0.0/src/redis-server /usr/bin/redis-server</span><br><span class="line">ln -s /usr/local/redis-3.0.0/src/redis-cli /usr/bin/redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改redis.conf</span> </span><br><span class="line">daemonize=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台模式启动redis</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><h2 id="5-安装Docker"><a href="#5-安装Docker" class="headerlink" title="5. 安装Docker"></a>5. 安装Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker版本</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机启动docker</span> </span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止docker</span></span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h2 id="6-安装Zookeeper，部署Dubbo"><a href="#6-安装Zookeeper，部署Dubbo" class="headerlink" title="6.安装Zookeeper，部署Dubbo"></a>6.安装Zookeeper，部署Dubbo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取zookeeper镜像</span></span><br><span class="line">docker pull zookeeper</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动镜像</span></span><br><span class="line">docker run --name zookeeper01 -p 2181:2181 --restart always -d 镜像id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取tomcat镜像</span></span><br><span class="line">docker pull tomcat:9.0.59-jdk8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动tomcat</span></span><br><span class="line">docker run --name tomcat_dubbo -d -p 8080:8080 --privileged=true tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入tomcat容器</span></span><br><span class="line">docker exec -it tomcat_dubbo /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> webapps是空的此时测试tomcat为404 将webapps.dist 改名为webapps</span></span><br><span class="line">mv webapps webapps2</span><br><span class="line">mv webapps.dist webapps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制 dubbo-admin-2.6.0.war 到容器内的webapps下</span></span><br><span class="line">docker cp dubbo-admin-2.5.7.war tomcat_dubbo:/usr/local/tomcat/webapps/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启tomcat容器</span></span><br><span class="line">docker restart tomcat_dubbo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -it tomcat_dubbo /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内安装vim编辑器</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改dubbo.properties</span></span><br><span class="line">vim /usr/local/tomcat/webapps/dubbo-admin-2.5.7/WEB-INF/dubbo.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改内容如下</span></span><br><span class="line">dubbo.registry.address=zookeeper://82.157.232.222:2181</span><br><span class="line">dubbo.admin.root.password=root</span><br><span class="line">dubbo.admin.guest.password=guest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启tomcat</span></span><br><span class="line">docker restart tomcat_dubbo</span><br></pre></td></tr></table></figure><p><strong>测试Dubbo</strong> <a href="http://82.157.232.222:2181/dubbo-admin-2.5.7/">http://82.157.232.222:2181/dubbo-admin-2.5.7/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux开发环境搭建-CentOS-7&quot;&gt;&lt;a href=&quot;#Linux开发环境搭建-CentOS-7&quot; class=&quot;headerlink&quot; title=&quot;Linux开发环境搭建( CentOS-7 )&quot;&gt;&lt;/a&gt;Linux开发环境搭建( CentOS-7 )</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis框架</title>
    <link href="http://example.com/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2021/12/11/Mybatis%E6%A1%86%E6%9E%B6/</id>
    <published>2021-12-11T13:47:08.000Z</published>
    <updated>2022-03-19T13:54:21.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java框架（Framework）"><a href="#Java框架（Framework）" class="headerlink" title="Java框架（Framework）"></a>Java框架（Framework）</h1><h3 id="框架技术"><a href="#框架技术" class="headerlink" title="框架技术"></a>框架技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是一个应用程序的半成品</span><br><span class="line">提供可重用的公共结构</span><br><span class="line">按一定规则组织的一组组件</span><br></pre></td></tr></table></figure><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不用再考虑公共问题</span><br><span class="line"></span><br><span class="line">专心在业务实现上</span><br><span class="line"></span><br><span class="line">结构统一，易于学习、维护</span><br></pre></td></tr></table></figure><h3 id="主流框架介绍"><a href="#主流框架介绍" class="headerlink" title="主流框架介绍"></a>主流框架介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Struts2</span><br><span class="line"></span><br><span class="line">MVC设计模式的重现</span><br><span class="line"></span><br><span class="line">拦截器</span><br><span class="line"></span><br><span class="line">可变和可重用的标签</span><br><span class="line"></span><br><span class="line">HIBERNATE</span><br><span class="line"></span><br><span class="line">ORM,简化数据库操作</span><br><span class="line"></span><br><span class="line">Dao层</span><br><span class="line"></span><br><span class="line">Spring</span><br><span class="line">依赖注入容器/AOP实现</span><br><span class="line"></span><br><span class="line">声明式事务</span><br><span class="line"></span><br><span class="line">简化Java EE应用</span><br><span class="line"></span><br><span class="line">粘合剂，将大家组装到一起</span><br><span class="line"></span><br><span class="line">Spring MVC</span><br><span class="line"></span><br><span class="line">结构最清晰的MVC Model2实现</span><br><span class="line"></span><br><span class="line">高度可配置，支持多种视图技术</span><br><span class="line"></span><br><span class="line">定制化开发</span><br><span class="line"></span><br><span class="line">MyBatis</span><br><span class="line"></span><br><span class="line">半自动化的ORM实现</span><br><span class="line"></span><br><span class="line">DAO层</span><br><span class="line"></span><br><span class="line">动态SQL</span><br></pre></td></tr></table></figure><h3 id="持久化与ORM（Object-Relational-Mapping）"><a href="#持久化与ORM（Object-Relational-Mapping）" class="headerlink" title="持久化与ORM（Object Relational Mapping）"></a>持久化与ORM（Object Relational Mapping）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">持久化是程序数据在瞬时状态和持久状态转换的过程</span><br><span class="line">ORM</span><br><span class="line">编写程序的时候，以面向对象的方式处理数据</span><br><span class="line">保存数据的时候，却以关系型数据库的方式存储</span><br><span class="line">ORM解决方案包含下面四个部分</span><br><span class="line">在持久化对象上执行基本的增删改查操作</span><br><span class="line">对持久化对象提供一种查询语言或者API</span><br><span class="line">对象关系映射工具</span><br><span class="line">提供与事务对象交互、执行检查、延迟加载以及其他优化功能</span><br></pre></td></tr></table></figure><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis "></a>MyBatis <img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211108200011135.png" alt="image-20211108200011135" style="zoom: 33%;" /></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyBatis前身是iBatis，本是Apache的一个开源项目</span><br><span class="line">官网</span><br><span class="line">http：//mybatis.org</span><br><span class="line">ORM框架</span><br><span class="line">实体类和SQL语句之间建立映射关系</span><br><span class="line">特点</span><br><span class="line">基于SQL语法，简单易学</span><br><span class="line">能了解底层封装过程</span><br><span class="line">SQL语句封装在配置文件中，便于统一管理与维护，降低程序的耦合度</span><br><span class="line">方便程序代码调试</span><br><span class="line">MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</span><br></pre></td></tr></table></figure><h2 id="一、安装MyBatis"><a href="#一、安装MyBatis" class="headerlink" title="一、安装MyBatis"></a>一、安装MyBatis</h2><h3 id="pom-xml依赖"><a href="#pom-xml依赖" class="headerlink" title="pom.xml依赖"></a>pom.xml依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mabits-version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">mabits-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mabits-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、使用MyBatis的开发步骤"><a href="#二、使用MyBatis的开发步骤" class="headerlink" title="二、使用MyBatis的开发步骤"></a>二、使用MyBatis的开发步骤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下载mybatis-3.2.2jar包并导入工程</span><br><span class="line">编写MyBatis核心配置文件(configuration.xml)</span><br><span class="line">创建实体类-POJO</span><br><span class="line">DAO层-SQL映射文件(mapper.xml)</span><br><span class="line">创建测试类</span><br><span class="line">读取全局配置文件mybatis-config.xml</span><br><span class="line">创建SqlSessionFactory对象，读取配置文件</span><br><span class="line">创建SqlSession对象</span><br></pre></td></tr></table></figure><h3 id="database-properties"><a href="#database-properties" class="headerlink" title="database.properties"></a>database.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/leavedb?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入外部文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;database.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.cyg.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h3><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p><p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取sqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatisconfig.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line">    <span class="comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭SqlSession</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSqlSession</span><span class="params">(SqlSession sqlSession)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h3><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、编写代码"><a href="#三、编写代码" class="headerlink" title="三、编写代码"></a>三、编写代码</h2><h3 id="实体类–-gt-pojo"><a href="#实体类–-gt-pojo" class="headerlink" title="实体类–&gt;pojo"></a>实体类–&gt;pojo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer studentNo;</span><br><span class="line">    <span class="keyword">private</span> String loginPwd;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Integer gradeId;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String gName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口–-gt-mapper"><a href="#接口–-gt-mapper" class="headerlink" title="接口–&gt;mapper"></a>接口–&gt;mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有学生</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getAllStudent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据学号studentNo查询学生</span></span><br><span class="line">    <span class="function">Student <span class="title">getStudentByStudentNo</span><span class="params">(Integer studentNo)</span></span>;</span><br><span class="line">    <span class="comment">//根据姓名studentName模糊查询</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudentByStudentName</span><span class="params">(<span class="meta">@Param(&quot;studentName&quot;)</span> String studentName, <span class="meta">@Param(&quot;gradeId&quot;)</span>Integer gradeId)</span></span>;</span><br><span class="line">    <span class="comment">//查询用户总记录数</span></span><br><span class="line">    <span class="function">Integer <span class="title">countStudentInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id修改用户信息</span></span><br><span class="line">    <span class="function">Integer <span class="title">updateStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function">Integer <span class="title">addStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function">Integer <span class="title">deleteStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mapper-xml配置"><a href="#Mapper-xml配置" class="headerlink" title="Mapper.xml配置"></a>Mapper.xml配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!---mapper路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.cyg.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--增删改查标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span>&gt;</span><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span>&gt;</span><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span>&gt;</span><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、动态mysql"><a href="#四、动态mysql" class="headerlink" title="四、动态mysql"></a>四、动态mysql</h2><p style="color:red;font-size:20px;font-weight:bolder">动态SQL是MyBatis的强大特性之一</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set和trim"><a href="#set和trim" class="headerlink" title="set和trim"></a>set和trim</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>​    动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p></blockquote><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogsLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">标签</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">if</td><td align="center">单条件分支，相当于java的if</td></tr><tr><td align="center">choose、when、otherwise</td><td align="center">不想使用所有的条件，而只是想从多个条件中选择一个使用。相当于switch语句；如果都没有传入when标签，那么就会执行otherwise</td></tr><tr><td align="center">where、set</td><td align="center">只会在子元素返回任何内容的情况下才插入where子句，而且where元素会自动去除and和or；set会自动去除 –&gt; ， &lt;–</td></tr><tr><td align="center">trim</td><td align="center">可以通过自定义trim元素来定制where和set；prefix前缀；prefixOverrides去除前缀；suffix后缀；suffixOverrides去除后缀</td></tr><tr><td align="center">foreach</td><td align="center">对集合进行遍历（构建IN条件语句时）声明可以在元素体内使用集合项（item）和索引（index）变量。也允许指定开头与结尾的字符串以及集合迭代之间的分隔符。当使用Map对象时，index是键，item是值</td></tr><tr><td align="center">bind</td><td align="center">允许在OGNL表达式以外创建一个变量，并将其绑定到当前的上下文 name；value</td></tr></tbody></table><h3 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h3><p>Object Graphic Navigation Language(对象 图 导航 语言)==对象导航图语言</p><p>语法：#{}</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="1-parameterType-输入类型"><a href="#1-parameterType-输入类型" class="headerlink" title="1.parameterType(输入类型)"></a>1.parameterType(输入类型)</h4><p>​    1）传递简单类型</p><p>​    2）传递pojo对象</p><p>​        Mybatis使用ognl表达式解析对象字段的值，#{}或者${}中的值为pojo属性名称</p><p>​    3）传递pojo包装对象</p><p>​        开发中通过pojo传递查询条件，不仅包括用户查询条件还包括其他的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数</p><h4 id="2-resultType-输出类型"><a href="#2-resultType-输出类型" class="headerlink" title="2.resultType(输出类型)"></a>2.resultType(输出类型)</h4><p>​    1）输出简单类型</p><p>​    <img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111190924176.png" alt="image-20211111190924176" style="zoom: 80%;" /></p><p>​    2）输出pojo对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    3）输出pojo列表</p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111191027548.png" alt="image-20211111191027548" style="zoom:80%;" /><h4 id="3-resultMap结果类型"><a href="#3-resultMap结果类型" class="headerlink" title="3.resultMap结果类型"></a>3.resultMap结果类型</h4><p>​    resultType可以指定将查询结果映射为pojo，但是需要pojo的属性名和sql查询的列名一致方可映射成功</p><p>​    如果sql查询字段名和pojo属性名不一致，可以通过resultMap将字段名和属性名作为一个对应关系，resultMap实质上还需要将查询结果映射到pojo对象中</p><p>​    resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询</p><h5 id="返回列名和实体类属性不一致"><a href="#返回列名和实体类属性不一致" class="headerlink" title="返回列名和实体类属性不一致"></a>返回列名和实体类属性不一致</h5><p>解决方案一：别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select id,userName name from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方案二：使用resultMap</p><p>优势：开发效率高，降低代码耦合度</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;uesrList&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h3><p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId == &#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">      select seq_users.nextval from dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId == &#x27;db2&#x27;&quot;</span>&gt;</span></span><br><span class="line">      select nextval for seq_users from sysibm.sysdummy1&quot;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="五、Mybatis中的多表查询"><a href="#五、Mybatis中的多表查询" class="headerlink" title="五、Mybatis中的多表查询"></a>五、Mybatis中的多表查询</h2><h3 id="1-一对一查询"><a href="#1-一对一查询" class="headerlink" title="1.一对一查询"></a>1.一对一查询</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;aMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Account&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一对一的映射关系：配置封装user的内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-一对多查询"><a href="#2-一对多查询" class="headerlink" title="2.一对多查询"></a>2.一对多查询</h3><p>用户信息和账户信息为一对多关系，如果用户没有账户，也要将该用户查出来，所以此时使用左外连接查询</p><blockquote><p>一对多关系映射，主表实体包含从表实体的集合引用</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;uMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置user对象中account集合的映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;accountList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Account&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;aId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;uId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-多对多查询"><a href="#3-多对多查询" class="headerlink" title="3.多对多查询"></a>3.多对多查询</h3><p>一个用户可以有多个角色，一个角色可以赋予多个用户</p><blockquote><p>RoleMapper.xml文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;rMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;roleName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllRoleAndUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;rMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT r.*, u.id uId, u.userName, u.sex, u.birthday</span><br><span class="line">        FROM role r</span><br><span class="line">                 LEFT JOIN user_role ur ON r.id = ur.rid</span><br><span class="line">                 LEFT JOIN USER u ON u.id = ur.uId</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>UserMapper.xml文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;uMap1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Role&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;rId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;uMap1&quot;</span>&gt;</span></span><br><span class="line">        SELECT u.*, r.roleName, r.id rId, r.roleDesc</span><br><span class="line">        FROM USER u</span><br><span class="line">                 LEFT JOIN user_role ur ON ur.uId = u.id</span><br><span class="line">                 LEFT JOIN role r ON ur.rId = r.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六、Mybatis延迟加载"><a href="#六、Mybatis延迟加载" class="headerlink" title="六、Mybatis延迟加载"></a>六、Mybatis延迟加载</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.mybatis中的延迟加载，也称为懒加载</p><p>2.是指在进行关联查询时，按照设置延迟规则对关联对象的select查询。</p><blockquote><p>延迟加载可以有效的减少数据库的压力</p></blockquote><p>3.延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓的延迟加载就是挡在真正需要的时候，才真正执行数据的加载</p><h3 id="二、关联对象加载时机"><a href="#二、关联对象加载时机" class="headerlink" title="二、关联对象加载时机"></a>二、关联对象加载时机</h3><ul><li><h4 id="直接加载："><a href="#直接加载：" class="headerlink" title="直接加载："></a>直接加载：</h4><p>  ​    执行完对主加载对象的select语句，马上执行对关联对象的select查询</p></li><li><h4 id="侵入式加载："><a href="#侵入式加载：" class="headerlink" title="侵入式加载："></a>侵入式加载：</h4><p>  ​    侵入式延迟加载，执行主对象属性时，会走关联对象SQL语句，如果不访问主对象的属性，则不会走关联对象</p></li><li><h4 id="深度延迟加载："><a href="#深度延迟加载：" class="headerlink" title="深度延迟加载："></a>深度延迟加载：</h4><p>  ​    执行对主加载对象的查询时，不会执行对关联对象的查询，访问主加载对象的详情时，也不会执行关联对象的select查询，只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。</p><blockquote><p>访问主对象的属性，只执行了主对象的sql操作，并没有走关联对象的sql语句</p></blockquote></li><li><h4 id="延迟加载的应用要求："><a href="#延迟加载的应用要求：" class="headerlink" title="延迟加载的应用要求："></a>延迟加载的应用要求：</h4></li></ul><p style="color:red;margin-left:30px;font-weight:bolder">关联对象的查询与主加载对象的查询必须是分别进行的select语句，不能使用多表连接所进行的select查询</p><h3 id="三、直接加载、侵入式加载、深度加载"><a href="#三、直接加载、侵入式加载、深度加载" class="headerlink" title="三、直接加载、侵入式加载、深度加载"></a>三、直接加载、侵入式加载、深度加载</h3><h4 id="1-核心配置文件"><a href="#1-核心配置文件" class="headerlink" title="1.核心配置文件"></a>1.核心配置文件</h4><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111202620289.png" alt="image-20211111202620289"></p><h4 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h4><h5 id="直接加载：-1"><a href="#直接加载：-1" class="headerlink" title="直接加载："></a>直接加载：</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211114161147888.png" alt="image-20211114161147888"></p><h5 id="侵入式加载：-1"><a href="#侵入式加载：-1" class="headerlink" title="侵入式加载："></a>侵入式加载：</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211114161201219.png" alt="image-20211114161201219"></p><h5 id="深度延迟加载：-1"><a href="#深度延迟加载：-1" class="headerlink" title="深度延迟加载："></a>深度延迟加载：</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211114161217185.png" alt="image-20211114161217185"></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><h4 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h4><ul><li>延迟加载对主对象都是直接加载，只有对关联对象时延迟加载</li><li>延迟加载可以减轻数据库压力</li><li>延迟加载不可以是一条SQL查询多表信息，这样构不成延迟加载，会形成直接加载</li></ul><h2 id="七、Mybatis中的缓存"><a href="#七、Mybatis中的缓存" class="headerlink" title="七、Mybatis中的缓存"></a>七、Mybatis中的缓存</h2><h4 id="1-什么是缓存？"><a href="#1-什么是缓存？" class="headerlink" title="1.什么是缓存？"></a>1.什么是缓存？</h4><p>缓存就是数据交换的缓冲区（Cache），是存储数据（使用频繁的数据）的临时空间</p><blockquote><p>当要读取数据时，会首先从缓存查询数据，有就直接执行，不存在时从内存/数据库中获取</p></blockquote><p>默认情况下，mabatis只开启一级缓存</p><h4 id="2-为什么使用缓存"><a href="#2-为什么使用缓存" class="headerlink" title="2.为什么使用缓存"></a>2.为什么使用缓存</h4><p style="color:red;text-align:left">减少和数据库交互的次数，提高执行效率</p><h4 id="3-什么样的数据能使用缓存"><a href="#3-什么样的数据能使用缓存" class="headerlink" title="3.什么样的数据能使用缓存"></a>3.什么样的数据能使用缓存</h4><p>适用于缓存：    </p><p>​    1）经常查询并且经常使用</p><p>​    2）数据的正确与否对最终结果影响不大</p><p>不适用于缓存：</p><p>​    1）经常改变的数据</p><p>​    2）数据的正确与否对最终结果影响很大</p><p>​    3）比如：商品的库存，银行汇率，股票价格</p><h3 id="Mybatis的一级缓存"><a href="#Mybatis的一级缓存" class="headerlink" title="Mybatis的一级缓存"></a>Mybatis的一级缓存</h3><ul><li>它指的是Mybatis中SqlSession对象的缓存</li><li>同一个SqlSession对象，在参数和SQL完全一样的情况下，只执行一次SQL语句</li><li>当我们执行查询之后，查询的结果会同时存入到SqlSession提供一块区域，该区域的结构是一个Map，当我们再次查询同样的数据，mybatis会先去SqlSession中查询，如果有直接使用；当SqlSession消失时，mybatis的一级缓存也就消失了</li></ul><h4 id="清空一级缓存的方法："><a href="#清空一级缓存的方法：" class="headerlink" title="清空一级缓存的方法："></a>清空一级缓存的方法：</h4><ol><li>关闭SqlSession对象==&gt;sqlSession.close()</li><li>调用SqlSession对象的clearCache()方法==&gt;sqlSession.clearCache()</li><li>调用增删改方法</li></ol><h3 id="Mybatis的二级缓存"><a href="#Mybatis的二级缓存" class="headerlink" title="Mybatis的二级缓存"></a>Mybatis的二级缓存</h3><p>​    它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存</p><h4 id="二级缓存开关"><a href="#二级缓存开关" class="headerlink" title="二级缓存开关"></a>二级缓存开关</h4><h5 id="全局开关核心配置"><a href="#全局开关核心配置" class="headerlink" title="全局开关核心配置"></a>全局开关核心配置</h5><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111205929805.png" alt="image-20211111205929805"></p><h5 id="分开关"><a href="#分开关" class="headerlink" title="分开关"></a>分开关</h5><ol><li><p>Mapper.xml文件中配置</p><blockquote><p>让当前的映射文件支持二级缓存</p></blockquote><p> <img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111210828079.png" alt="image-20211111210828079"></p></li><li><p>select标签中配置</p><blockquote><p>让当前的操作支持二级缓存</p></blockquote></li></ol><blockquote><p>flushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存</p><p>useCache默认为true，表示会将本条语句的结果进行二级缓存。</p></blockquote><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211111210711930.png" alt="image-20211111210711930"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java框架（Framework）&quot;&gt;&lt;a href=&quot;#Java框架（Framework）&quot; class=&quot;headerlink&quot; title=&quot;Java框架（Framework）&quot;&gt;&lt;/a&gt;Java框架（Framework）&lt;/h1&gt;&lt;h3 id=&quot;框架技术&quot;</summary>
      
    
    
    
    
    <category term="Mybatis框架" scheme="http://example.com/tags/Mybatis%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-12-11T13:44:05.000Z</published>
    <updated>2022-03-19T13:53:11.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据是表述客观事务的符号，是计算机中可以被操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符以及声音、图像、视频等非数值类型。</span><br></pre></td></tr></table></figure><h5 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</span><br></pre></td></tr></table></figure><h5 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</span><br></pre></td></tr></table></figure><h5 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据对象是性质相同的数据元素的集合，是数据的子集。</span><br></pre></td></tr></table></figure><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据结构没有官方统一定义</span><br><span class="line">&quot;数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。&quot;</span><br><span class="line">Sartaj Sahni，《数据结构、算法与应用》</span><br><span class="line">&quot;数据结构是ADT(抽象数据类型Abstract Data Type)的物理实现&quot;</span><br><span class="line">Clifford A.Shaffer，《数据结构与算法分析》</span><br><span class="line">&quot;数据结构(data structure) 是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。&quot;</span><br><span class="line">中文维基百科</span><br><span class="line">在计算机中数据元素并不是孤立杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式--《大话数据结构》</span><br></pre></td></tr></table></figure><p>数据怎么组织 跟数据的规模有关系，不一样的规模处理起来的难度不一样。</p><p>解决问题方法的效率，跟数据的组织方式有关。</p><h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑结构：是指数据对象中元素之间的相互关系</span><br></pre></td></tr></table></figure><h5 id="1-集合结构"><a href="#1-集合结构" class="headerlink" title="1.集合结构"></a>1.集合结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据是“平等”的，他们的共同属性是“同属于一个集合”</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915083919994.png" alt="image-20210915083919994" style="zoom:30%;" /><h5 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2.线性结构"></a>2.线性结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线性结构中的数据元素之间是一对一的关系</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084015078.png" alt="image-20210915084015078" style="zoom:33%;" /><h5 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3.树形结构"></a>3.树形结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树形结构中的数据元素存在一种一对多的层次关系</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084107625.png" alt="image-20210915084107625" style="zoom:33%;" /><h5 id="4-图形结构"><a href="#4-图形结构" class="headerlink" title="4.图形结构"></a>4.图形结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图形结构的数据元素是多对多的关系</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084140587.png" alt="image-20210915084140587" style="zoom:33%;" /><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><h5 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1.顺序存储结构"></a>1.顺序存储结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</span><br><span class="line">要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所占位置的大小乘以9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样依次摆放。</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084305835.png" alt="image-20210915084305835" style="zoom: 50%;" /><h5 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2.链式存储结构"></a>2.链式存储结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915084552592.png" alt="image-20210915084552592" style="zoom:33%;" /><p>逻辑结构是面向问题的，而物理结构就是面向计算机的，其最基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</span><br></pre></td></tr></table></figure><h5 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Abstract Data Type，ADT：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</span><br></pre></td></tr></table></figure><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210915090903806.png" alt="image-20210915090903806" style="zoom: 80%;" /><h2 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</span><br><span class="line">一个有限指令集</span><br><span class="line">接受一些输入</span><br><span class="line">产生输出</span><br><span class="line">一定在有限步骤之后终止</span><br><span class="line">每一条指令必须：</span><br><span class="line">有充分明确的目标，不可以有歧义</span><br><span class="line">计算机能处理的范围之内</span><br><span class="line">描述应不依赖于任何一种计算机语言以及具体的实现手段</span><br></pre></td></tr></table></figure><h5 id="算法的五个基本特性"><a href="#算法的五个基本特性" class="headerlink" title="算法的五个基本特性"></a>算法的五个基本特性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入、输出、有穷性、确定性和可行性</span><br><span class="line">·输入和输出：算法具有零个或多个输入，至少有一个输出或输出</span><br><span class="line">·有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</span><br><span class="line">·确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义</span><br><span class="line">·可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</span><br></pre></td></tr></table></figure><h5 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正确性：指算法至少应该具有输入。输出和加工处理无歧义性。能正确反映问题的需求、能够得到问题的正确答案。</span><br><span class="line">1.算法程序没有语法错误。</span><br><span class="line">2.算法程序对于合法的输入数据能够产生满足要求的输出的结果</span><br><span class="line">3.算法程序对于非法的输入数据能够得出满足规格说明的结果。</span><br><span class="line">4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果</span><br><span class="line">可读性：算法设计的另一个目的是为了便于阅读、理解和交流。</span><br><span class="line">健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</span><br><span class="line">时间效率高和存储量低</span><br></pre></td></tr></table></figure><h5 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度:调用时间</span><br><span class="line">空间复杂度:所占内存</span><br></pre></td></tr></table></figure><h5 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.事后统计法:通过统计,监控,利用计算机计时器对不同算法的运行时间进行比较,从而确定算法效率的高低,但是有非常大的局限性.</span><br><span class="line">2.事前分析估算:在计算机程序编制前,依据统计方法对算法进行估算.</span><br><span class="line">一个高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</span><br><span class="line">1.算法采用的策略、方法算法好坏的根本</span><br><span class="line">2.编译产生的代码质量软件来支持</span><br><span class="line">3.问题的输入规模</span><br><span class="line">4.机器执行指令的速度计算机硬件性能</span><br></pre></td></tr></table></figure><h5 id="事后统计法"><a href="#事后统计法" class="headerlink" title="事后统计法:"></a>事后统计法:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fun1</span><span class="params">(<span class="keyword">long</span> n )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> fun1(n-<span class="number">1</span>)+fun1(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归:自己调用自己</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n ;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=first+second;</span><br><span class="line">        first=second;</span><br><span class="line">        second=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(fun1(n:<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事前分析估算"><a href="#事前分析估算" class="headerlink" title="事前分析估算:"></a>事前分析估算:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal01</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="number">6</span><span class="comment">//1*unit-time  O(1)</span></span><br><span class="line">    <span class="keyword">if</span>(age&gt;<span class="number">58</span>)&#123;<span class="comment">//unit-time</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阿姨&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;<span class="number">28</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小姐姐&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美少女&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal02</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//3+3n unit-time O(n)</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line">    <span class="comment">//i执行n次 执行n次</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;<span class="comment">//n //n</span></span><br><span class="line">        sum=sum+i;<span class="comment">//执行n次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//执行1次//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal03</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+3n unit-time O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//n n n +1 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;崔源耕&quot;</span>);<span class="comment">//执行n次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal04</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+2n+n*(1+3n)=3n^2+3n+1 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//1 n  n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;n(<span class="number">1</span>+n+n+n)</span><br><span class="line">            System.out.println(<span class="string">&quot;Cui&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal05</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+2n+n*(1+20+20+20)=1+2n+61n=63n</span></span><br><span class="line">    <span class="comment">//T(n)=O(n) </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cui&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal06</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//log2(n)</span></span><br><span class="line">    <span class="comment">//T(n)=O(logn)//</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        i=i*<span class="number">2</span>;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal07</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1+2*log2(n)+log2(n)*(1+3n)</span></span><br><span class="line">    <span class="comment">//T(n)=O(nlog(n))</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i=2i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ayi&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(n) 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</span><br></pre></td></tr></table></figure><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T(n)=O(f(n))</span><br><span class="line">T(n)表示代码执行时间;</span><br><span class="line">n表示数据规模的大小;</span><br><span class="line">f(n)表示每行代码执行的次数总和.</span><br><span class="line">因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比.</span><br><span class="line">大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210723091417415.png" alt="image-20210723091417415"></p><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210723091458491.png" alt="image-20210723091458491"></p><h5 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算法A 要做2n+3次操作 算法B要做3n+1次操作</span><br></pre></td></tr></table></figure><table><thead><tr><th>次数</th><th>算法A（2n+3）</th><th>算法A‘（2n）</th><th>算法B（3n+1）</th><th>算法B’（3n）</th></tr></thead><tbody><tr><td>n=1</td><td>5</td><td>2</td><td>4</td><td>3</td></tr><tr><td>n=2</td><td>7</td><td>4</td><td>7</td><td>6</td></tr><tr><td>n=3</td><td>9</td><td>6</td><td>10</td><td>9</td></tr><tr><td>n=10</td><td>23</td><td>20</td><td>31</td><td>30</td></tr><tr><td>n=100</td><td>203</td><td>200</td><td>301</td><td>300</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的</span><br><span class="line">函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。</span><br></pre></td></tr></table></figure><hr><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个线性表是0个或n个具有相同特性的数据元素的有限且有序数列</span><br><span class="line">数组按照顺讯存储在连续位置的存储器中</span><br><span class="line">数组与列表相比,在特定位置添加或者删除元素成本过高</span><br><span class="line">优点:</span><br><span class="line">空间利用率高</span><br><span class="line">查询速度高效,通过下标来直接存取</span><br><span class="line">缺点</span><br><span class="line">插入和删除比较慢,比如:插入或者删除一个元素时,整个表需要遍历移动元素来重新排一次排序</span><br><span class="line">不可以增长长度,有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现&quot;溢出&quot;问题,当元素个数远少于预先分配空间时,空间浪费巨大</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20211009200640073.png" alt="image-20211009200640073"></p><hr><p><img src="https://gitee.com/cuiyuangeng/notepic-cyg/raw/master/img/image-20210723110717072.png" alt="image-20210723110717072"></p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 比冒泡排序交换次数少，比较次数不变</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 10217</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortNum</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> min = -<span class="number">1</span>;<span class="comment">// 最小值下标</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//外层循环：比较几轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">min = i;<span class="comment">//每轮min初始值</span></span><br><span class="line"><span class="comment">//内层循环：当前元素和后面的元素比较，记录最新的最小元素下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果min值发生变化，说明发现了更小的值，则当前值和更小值交换，保证小值放在数组前面</span></span><br><span class="line"><span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">temp = arr[min];</span><br><span class="line">arr[min] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num :arr) &#123;</span><br><span class="line">System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分（折半）查找法"><a href="#二分（折半）查找法" class="headerlink" title="二分（折半）查找法"></a>二分（折半）查找法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(arr);<span class="comment">//快速排序 如果给定数组不是升序数组那么使用快排，是则忽略</span></span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">            <span class="keyword">int</span> midIndex = startIndex + (endIndex - startIndex) / <span class="number">2</span>;<span class="comment">//如果使用（endIndex+startIndex）/2计算 如果数组长度太大会导致溢出</span></span><br><span class="line">            <span class="keyword">if</span> (num == arr[midIndex]) &#123;<span class="comment">//如果num就是midindex所指向的元素 return true；</span></span><br><span class="line">                <span class="keyword">return</span> midIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; arr[midIndex]) &#123;<span class="comment">//如果num&gt;midindex 开始下标则是midindex的下一位</span></span><br><span class="line">                startIndex = midIndex + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果num&lt;midindex 结束下标则是midindex的前一位</span></span><br><span class="line">                endIndex = midIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h1&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式（未完成）</title>
    <link href="http://example.com/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/"/>
    <id>http://example.com/2021/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%AE%8C%E6%88%90)/</id>
    <published>2021-12-11T13:43:03.000Z</published>
    <updated>2022-03-09T08:24:52.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式（Design-pattern）"><a href="#设计模式（Design-pattern）" class="headerlink" title="设计模式（Design pattern）"></a>设计模式（Design pattern）</h1><p>设计模式是一套被反复使用的，多数人知晓的，经过分类编目的、代码设计经验的总结。</p><h2 id="为什么使用设计模式？"><a href="#为什么使用设计模式？" class="headerlink" title="为什么使用设计模式？"></a>为什么使用设计模式？</h2><p>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p><h2 id="什么是GOF？"><a href="#什么是GOF？" class="headerlink" title="什么是GOF？"></a>什么是GOF？</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承</li></ul><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>共计23种设计模式</p><p>分为三大类：</p><ul><li>创建型模式（Creational Patterns）</li><li>结构型模式（Structural Patterns）</li><li>行为型模式（Behavioral Patterns）</li></ul><p>​    J2EE 设计模式</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><blockquote><p>提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定示例需要创建那些对象时更加灵活</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">·工厂模式(Factory Pattern)</span><br><span class="line">·抽象工厂模式(Abstract Factory Pattern)</span><br><span class="line">·单例模式(Singleton Pattern)</span><br><span class="line">·建造者模式(Builder Pattern)</span><br><span class="line">·原型模式(Prototype Pattern)</span><br></pre></td></tr></table></figure><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><blockquote><p>关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·适配器模式（Adapter Pattern）</span><br><span class="line">·桥接模式（Bridge Pattern）</span><br><span class="line">·过滤器模式（Filter、Criteria Pattern）</span><br><span class="line">·组合模式（Composite Pattern）</span><br><span class="line">·装饰器模式（Decorator Pattern）</span><br><span class="line">·外观模式（Facade Pattern）</span><br><span class="line">·享元模式（Flyweight Pattern） </span><br><span class="line">·代理模式（Proxy Pattern）</span><br></pre></td></tr></table></figure><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><blockquote><p>关注对象之间的通信</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">·责任链模式（Chain of Responsibility Pattern）</span><br><span class="line">·命令模式（Command Pattern）</span><br><span class="line">·解释器模式（Interpreter Pattern）</span><br><span class="line">·迭代器模式（Iterator Pattern）</span><br><span class="line">·中介者模式（Mediator Pattern）</span><br><span class="line">·备忘录模式（Memento Pattern）</span><br><span class="line">·观察者模式（Observer Pattern）</span><br><span class="line">·状态模式（State Pattern）</span><br><span class="line">·空对象模式（Null Object Pattern）</span><br><span class="line">·策略模式（Strategy Pattern）</span><br><span class="line">·模板模式（Template Pattern）</span><br><span class="line">·访问者模式（Visitor Pattern）</span><br></pre></td></tr></table></figure><h3 id="J2EE模式"><a href="#J2EE模式" class="headerlink" title="J2EE模式"></a>J2EE模式</h3><blockquote><p>特别关注表示层</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·MVC 模式（MVC Pattern）</span><br><span class="line">·业务代表模式（Business Delegate Pattern）</span><br><span class="line">·组合实体模式（Composite Entity Pattern）</span><br><span class="line">·数据访问对象模式（Data Access Object Pattern）</span><br><span class="line">·前端控制器模式（Front Controller Pattern）</span><br><span class="line">·拦截过滤器模式（Intercepting Filter Pattern）</span><br><span class="line">·服务定位器模式（Service Locator Pattern）</span><br><span class="line">·传输对象模式（Transfer Object Pattern）</span><br></pre></td></tr></table></figure><h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h3><p>对扩展开放、对修改关闭。在程序需要进行扩展时，不能去修改原有代码，实现一个热插拔的效果，为了使程序的扩展性好。易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类</p><h3 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2.里氏代换原则"></a>2.里氏代换原则</h3><p>里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方。子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则时对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体规范</p><h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h3><p>是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h3><p>使用多个隔离的接口，比使用单个接口要好。降低类的耦合度。</p><blockquote><p>由此可见其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p></blockquote><h3 id="5-迪米特法则，又称最少知道原则"><a href="#5-迪米特法则，又称最少知道原则" class="headerlink" title="5.迪米特法则，又称最少知道原则"></a>5.迪米特法则，又称最少知道原则</h3><p>一个实体应当尽量少地与其他实体之间发生相互作用，使用系统功能模块相对独立</p><h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承</p><h3 id="7-单一职责原则"><a href="#7-单一职责原则" class="headerlink" title="7.单一职责原则"></a>7.单一职责原则</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式（Design-pattern）&quot;&gt;&lt;a href=&quot;#设计模式（Design-pattern）&quot; class=&quot;headerlink&quot; title=&quot;设计模式（Design pattern）&quot;&gt;&lt;/a&gt;设计模式（Design pattern）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度的计算</title>
    <link href="http://example.com/2021/12/11/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2021/12/11/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/</id>
    <published>2021-12-11T11:35:58.000Z</published>
    <updated>2022-03-19T13:54:38.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p><ul><li>一个有限指令集</li><li>接受一些输入</li><li>产生输出</li><li>一定在有限步骤后终止</li><li>每一条指令必须：<br>  有充分明确的目标，不可以有歧义<br>  计算机能处理的范围之内<br>  描述应不依赖于任何一种计算机语言以及具体的实现手段</li></ul><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><p>正确性、可读性、健壮性、<strong>时间效率高和存储量低</strong></p><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><p>事后统计法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</p><h4 id="例：求第n个斐波那契数列"><a href="#例：求第n个斐波那契数列" class="headerlink" title="例：求第n个斐波那契数列"></a>例：求第n个斐波那契数列</h4><img src="C:\Users\10217\Desktop\Fibonacci.png" alt="image-20210720090355878" style="zoom: 50%;" />**事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算**程序在计算机上运行时所消耗的时间取决于以下几个因素：<ol><li>算法采用的策略、方法==&gt;算法好坏的根本</li><li>编译产生的代码质量==&gt;由IDE、软件支持</li><li><strong>问题的输入规模</strong></li><li>机器执行指令的速度==&gt;看计算机硬件的性能</li></ol><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="什么是时间复杂度"><a href="#什么是时间复杂度" class="headerlink" title="什么是时间复杂度"></a>什么是时间复杂度</h2><ul><li>T(n)=O(f(n))</li></ul><ul><li>T(n)表示代码执行时间;</li><li>n表示数据规模的大小;</li><li>f(n)表示每行代码执行的次数总和.</li><li>因为这是一个公式,所有用f(n)来表示.公式中的O,表示代码的执行时间T(n)与f(n)成正比.</li><li>大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,所以,也叫作渐进时间复杂度(asymptotic time complexity),简称时间复杂度</li></ul><h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算法A 要做2n+3次操作 算法B要做3n+1次操作</span><br></pre></td></tr></table></figure><table><thead><tr><th>次数</th><th>算法A（2n+3）</th><th>算法A‘（2n）</th><th>算法B（3n+1）</th><th>算法B’（3n）</th></tr></thead><tbody><tr><td>n=1</td><td>5</td><td>2</td><td>4</td><td>3</td></tr><tr><td>n=2</td><td>7</td><td>4</td><td>7</td><td>6</td></tr><tr><td>n=3</td><td>9</td><td>6</td><td>10</td><td>9</td></tr><tr><td>n=10</td><td>23</td><td>20</td><td>31</td><td>30</td></tr><tr><td>n=100</td><td>203</td><td>200</td><td>301</td><td>300</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的</span><br><span class="line">函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。</span><br></pre></td></tr></table></figure><hr><h2 id="一秒之内能解决问题的数据规模"><a href="#一秒之内能解决问题的数据规模" class="headerlink" title="一秒之内能解决问题的数据规模"></a>一秒之内能解决问题的数据规模</h2><table><thead><tr><th></th><th>数据规模</th><th>时间复杂度</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>n！</td></tr><tr><td>2</td><td>20~30</td><td>2^n</td></tr><tr><td>3</td><td>50</td><td>n^4</td></tr><tr><td>4</td><td>100</td><td>n^3</td></tr><tr><td>5</td><td>1000</td><td>n^2</td></tr><tr><td>6</td><td>10^6</td><td>nlogn</td></tr><tr><td>7</td><td>10^7</td><td>n</td></tr><tr><td>8</td><td>10^9</td><td>sqrt(n)</td></tr><tr><td>9</td><td>10^10</td><td>logn</td></tr><tr><td>10</td><td>无穷大</td><td>1</td></tr></tbody></table><h2 id="阿里面试题"><a href="#阿里面试题" class="headerlink" title="阿里面试题"></a>阿里面试题</h2><p>假设给出一个算法的时间复杂度递推关系式：T(n）=T(n-1)+n，T(0)=1；（n为整数）求该算法的时间复杂度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;算法是</summary>
      
    
    
    
    
  </entry>
  
</feed>
